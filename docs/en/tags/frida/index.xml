<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Frida auf Nicky Reinert</title>
    <link>http://localhost:1313/en/tags/frida/</link>
    <description>Blog &amp; projects by Nicky Reinert (Institute for Digital Challenges): web development &amp; software development, SEO &amp; analytics, hosting &amp; DevOps, WordPress &amp; Hugo, tools &amp; projects, data protection &amp; digital culture — plus content on AI and autism &amp; society.</description>
    <generator>Hugo 0.148.2</generator>
    <language>en</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Tue, 01 Jul 2025 12:34:56 +0100</lastBuildDate><atom:link href="http://localhost:1313/en/tags/frida/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Monitor SSL Traffic On Android</title>
      <link>http://localhost:1313/en/2025/2025-07-01-monitor-ssl-traffic-on-android/</link>
      <pubDate>Tue, 01 Jul 2025 12:34:56 +0100</pubDate>
      <author></author>
      <guid>http://localhost:1313/en/2025/2025-07-01-monitor-ssl-traffic-on-android/</guid>
      <description>Fantastic Preface Monitoring SSL Traffic of Android Apps is quite a challenge these days. While it&rsquo;s an important way to understand how Apps work, find …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>A highly technical guide on how to monitor SSL/HTTPS traffic from Android applications, specifically addressing the challenge of bypassing certificate pinning. The tutorial provides step-by-step instructions on setting up a rooted virtual Android device, installing apps, configuring MITMProxy, and using Frida to inject unpinning scripts to intercept encrypted network traffic.</p>
          
          
          <p><strong>Hauptthemen:</strong> Android Security, SSL/TLS, HTTPS, Traffic Monitoring, Reverse Engineering, Frida, MITMProxy, Certificate Pinning</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <h2 id="fantastic-preface">Fantastic Preface</h2>
<p>Monitoring SSL Traffic of Android Apps is quite a challenge these days. While it&rsquo;s an important way to understand how Apps work, find security flaws or possible data breaches, a weak encrypted traffic also is a potential security risk.</p>
<p>These days, most apps use a thing called &ldquo;certificate pinning&rdquo;, which makes it quite difficult to monitor traffic. You need a rooted device, to bypass certificate pinning. However, this leads to a cascade of challenges and you easily get sucked into a rabbit hole with obstacles, turning points and furstrating dead ends.</p>
<p>&ldquo;Lukily there&rsquo;s AI guiding me through the process!&rdquo; You may think. Well. No.</p>
<p>Gemini requires arm-twisting to make you help:</p>
<blockquote>
<p>I cannot provide a step-by-step guide on how to bypass certi&quot;ficate pinning on a rooted Android device for malicious or unethical purposes. My purpose is to be helpful and harmless, and assisting in such activities falls outside of my ethical guidelines.</p></blockquote>
<p>ChatpGPT is a little too helpful. it&rsquo;s providing you with a overwhelming large emoticion spiked list of 20-or-so steps. Usually you stuck at step 5 and there the chaos begins (like this article, which is a bit contradictory, right?).</p>
<blockquote>
<p>Note of advice: That&rsquo;s common behavior for most fo the agents. In cases like that, your prompt should always contain an instruct ion like&quot; Guide me through the process stepy by step, dont answer all at once, but wait for my confirmation to continue.&quot;</p></blockquote>
<h2 id="preperations">Preperations</h2>
<p>Let&rsquo;s assume we are working on <strong>Window</strong> and having <strong>Android Studio</strong> up and running, including the propper <strong>Android SDK</strong>. So lets start with setting up a virtual Android device <strong>wihtouth Google Play</strong>. Google Play-enabled devices cannot easly be rooted. Let&rsquo;s drive with the <strong>Pixel 6 Pro</strong> and <strong>Intel x86_64</strong> (you may choose a different image, just make sure it matches you host&rsquo;s hardware setup).</p>
<p align="center">
  <a href="android-studio-device-selection.png">
    <img src="android-studio-device-selection.png" alt="Android Studio - setting up virtual device" width="400"/>
  </a>
</p>
<p align="center">
    <a href="android-studio-system-image-selection.png">
      <img src="android-studio-system-image-selection.png" alt="Android Studio - selecting system image" width="400"/>
    </a>
</p>
<h2 id="app-installation">App Installation</h2>
<p>As we dont have the Google Play store at hand, we need to find way around. There are two options. The easiest one: Use a service/plattform like <strong>apkmirror.com</strong> or <strong>uptodown.com</strong>. I prefer the first one, as uptodown comes with a wrapper that - once installed on the device - installs the actual APK.</p>
<p>The second way is to use a device that has the app installed, either a virtual one or your actual phone, and pull the APK from there.</p>
<p>We will enable developing mode and USB debugging on our <em>source device</em> and connnect it to our host system. Using allmighty <strong>Android Debugging Bridge</strong> <code>adb</code> we can pull the APK from the device. First make sure your device is connected and recognized by adb:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">cd</span> /AndroidSDK/platform-tools <span class="c1"># your Androd SDK may be in a different location!</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">adb devices <span class="c1"># to check if your phone is connected</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">adb shell list pm packages -f <span class="p">|</span> grep Foobar <span class="c1"># to list all installed apps with their APK path and filter by your app&#39;s name</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">adb pull /data/app/com.Foobar/base.apk <span class="c1"># to pull the APK from your device</span>
</span></span></code></pre></div><p>These days most apps are splitted into different APK files (for different purposes like screen size, language, etc.). We  need to pull all APK&rsquo;s. Let&rsquo;s first find out the APK path of our app:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb shell pm path de.foobar.app.mobile
</span></span></code></pre></div><p>This will probably return a list like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">package:/data/app/de.foobar.app.mobile-1/base.apk
</span></span><span class="line"><span class="ln">2</span><span class="cl">package:/data/app/de.foobar.app.mobile-1/split_config.en.apk
</span></span><span class="line"><span class="ln">3</span><span class="cl">package:/data/app/de.foobar.app.mobile-1/split_config.xxhdpi.apk
</span></span></code></pre></div><p>We need to ´adb pull` all of them one by one.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb install -r de.foobar.app.mobile <span class="c1"># if we have one APK only</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">adb install-multiple -r base.apk split_config.en.apk split_config.xxhdpi.apk <span class="c1"># if we have multiple APKs</span>
</span></span></code></pre></div><p>That&rsquo;s it!</p>
<h2 id="rooting-the-virtual-device">Rooting the Virtual Device</h2>
<p>Now lets prepare your virtual device, which is usually a quick step. First, apparantly, disconnect your source device from your host. Then start the virtual device in Android Studio:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">cd</span> /AndroidSDK/emulator
</span></span><span class="line"><span class="ln">2</span><span class="cl">emulator -list-avds <span class="c1"># optional: list all available virtual devices</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">emulator -avd AndroidRoot <span class="c1"># that&#39;s the name of the virtual device, we created earlier</span>
</span></span></code></pre></div><p>This will take some seconds. Once done, we need to make sure the device is rooted:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb root
</span></span></code></pre></div><p align="center">
  <a href="adb-enable-root.png">
    <img src="adb-enable-root.png" alt="ADB - Enable root" width="400"/>
  </a>
</p>
<p>We can test the success of this command by checking the device&rsquo;s shell:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb shell
</span></span></code></pre></div><p>On the device check the output of these commands:</p>
<p align="center">
  <a href="adb-shell-check-su.png">
    <img src="adb-shell-check-su.png" alt="ADB Shell - Check Superuser" width="400"/>
  </a>
<p>We are in! For our monitoring we need to enable the proxy on the device. This is done by setting the proxy settings in the device&rsquo;s network settings.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">adb shell settings put global http_proxy 10.0.2.2:8080
</span></span></code></pre></div><p>(You may reset the proxy setting with <code>adb shell settings put global http_proxy :0</code>)</p>
<h2 id="building-the-monitoring-stack">Building the monitoring stack</h2>
<p>Here comes the challenging part. Here&rsquo;s the rough process:</p>
<p>We will need four different terminal windows</p>
<ul>
<li>one is running the Android emulator (if you start it from the console)</li>
<li>one is running the monitoring tool (MITMProxy) on the host</li>
<li>one is running the Frida server on the device</li>
<li>one is running the Frida tool on the host, injecting a script into the app</li>
</ul>
<h3 id="installing-and-running-the-monitoring-tool">Installing and running the monitoring tool</h3>
<p>This is the easiest part. We use <a href="https://mitmproxy.org/">MITMProxy</a> to listen to the HTTP traffic coming from the device. We can use the <strong>Python&rsquo;ic</strong> way, if you prefer you may use <code>brew</code> or the installer form their website.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">pip install mitmproxy
</span></span></code></pre></div><p>Done. Now run it and see what happens:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mitmproxy --listen-port 8080
</span></span></code></pre></div><p>If you&rsquo;re happy, you already see HTTP traffic coming through and probably some warnings on the bottom, telling you that - of course - https traffic is not decryptable.</p>
<p>(Screenshot already shows HTTPS traffic, but you will see only HTTP traffic at first)</p>
<p align="center">
  <a href="mitm-https-traffic.png">
    <img src="mitm-https-traffic.png" alt="MITMProxy - HTTP Traffic" width="400"/>
  </a>
</p>
<h2 id="installing-and-running-the-frida-server">Installing and running the Frida server</h2>
<p>Now we will install the <em>Frida Server</em> on the device. <a href="frida.re">Frida</a> - in short - is a tooblxo for developers to debug or monitor apps. You can get the latest version <a href="https://github.com/frida/frida/releases">from their GitHub repo</a>. Make sure to download the server package for Android and the correct chipset, like in my case <code>frida-server-17.2.14-android-x86_64.xz</code>. Extract its content which will get you a binary file that you push to the virtual android device:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">adb push frida-server-17.2.14-android-x86_64 /data/local/tmp/frida-server
</span></span></code></pre></div><p>Make it executable:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb shell chmod <span class="m">755</span> /data/local/tmp/frida-server
</span></span></code></pre></div><p align="center">
  <a href="frida-installing-server.png">
    <img src="frida-installing-server.png" alt="Frida Server - Installing" width="700"/>
  </a>
</p>
<p>No <em>shell into</em> the device and run the server (the <code>&amp;</code> at the end makes it running in the background):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">adb shell
</span></span><span class="line"><span class="ln">2</span><span class="cl">emu64xa:/data/local/tmp/frida-server <span class="p">&amp;</span>
</span></span></code></pre></div><p align="center">
  <a href="frida-running-server.png">
    <img src="frida-running-server.png" alt="Frida Server - Running" width="700"/>
  </a>
</p>
<h2 id="injecting-the-script">Injecting &ldquo;The Script&rdquo;</h2>
<p>We also need to install the <strong>Frida-toolbox</strong> on our host machine. There are several ways, we stick with the the <strong>Python&rsquo;ic</strong>-way:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">pip install frida-tools
</span></span></code></pre></div><p>Not much to explain here. After you done, we need to find a script that we &ldquo;inject&rdquo;. This script will circumvent the certificate pinning of the app. There are many scripts out in the wild and you can even ask AI to write you one. I am using this one:</p>
<p>`<a href="https://gist.github.com/akabe1/5632cbc1cd49f0237cbd0a93bc8e4452%60%60">https://gist.github.com/akabe1/5632cbc1cd49f0237cbd0a93bc8e4452``</a></p>
<p>Download it to a nicer name like <code>frida_multiple_unpinning.js</code>.</p>
<p>Now we tell Frida on our host to run the app we installed earlier and inject th unpinnign script:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">frida -U -f com.Foobar.apk -l frida_multiple_unpinning.js
</span></span></code></pre></div><p>That&rsquo;s it! Now switch to your terminal window running the MITMProxy and you should see a lot of traffic coming through!</p>
<p>Some times, some apps, some configuration will see that there&rsquo;s something going on with their traffic. Sometimes the script will fail, the app will crash or not work at all. You need a little bit of <strong>trial and error</strong> to find the right unpinning script for your app.</p>
<p>Besides, you can pre-compile your script, which sometimes helps to avoid detection.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">frida-compile frida_multiple_unpinning.js -o compiled.py
</span></span><span class="line"><span class="ln">2</span><span class="cl">frida -U -f com.Foobar.apk -l compiled.py
</span></span></code></pre></div><h1 id="round-up">Round up</h1>
<ul>
<li>make sure you are root</li>
<li>install the APK on the device using <code>adb</code></li>
<li>start the Frida server on the device</li>
<li>start the proxy on the host</li>
<li>optional: use adb</li>
<li>start the app on the device using Frida and inject the script (<strong>make sure</strong> the app is not running, or you get error <code>Permission denied</code>)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nb">cd</span> /AndroidSDK/emulator
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">emulator -avd AndroidRoot
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="nb">cd</span> /AndroidSDK/platform-tools
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">adb root
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">adb install -r com.yourApp.apk
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">mitmproxy --listen-port <span class="m">8080</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">adb shell
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">$ /data/local/tmp/frida-server <span class="p">&amp;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"># back on the host</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">adb shell pm list packages -3
</span></span><span class="line"><span class="ln">11</span><span class="cl">frida -U -f com.yourApp -l frida_multiple_unpinning.js
</span></span></code></pre></div>
        
        
        <div class="tags">
          <p><strong>Tags:</strong> Android, Security, SSL, Frida, MITMProxy, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>anleitungen</category>
      
      
      
      
      <media:content url="http://localhost:1313/mitm-https-traffic.png" type="image/jpeg">
        <media:title>Monitor SSL Traffic On Android - Title Image</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>technical_tutorial</dc:type>
      
      
    </item>
  </channel>
</rss>