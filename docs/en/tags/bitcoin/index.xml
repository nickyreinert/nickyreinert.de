<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Bitcoin auf Nicky Reinert</title>
    <link>https://nickyreinert.de/en/tags/bitcoin/</link>
    <description>Blog &amp; projects by Nicky Reinert (Institute for Digital Challenges): web development &amp; software development, SEO &amp; analytics, hosting &amp; DevOps, WordPress &amp; Hugo, tools &amp; projects, data protection &amp; digital culture — plus content on AI and autism &amp; society.</description>
    <generator>Hugo 0.148.2</generator>
    <language>en</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Fri, 15 Aug 2025 12:34:56 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/en/tags/bitcoin/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>How to simulate proof of work in SQL and BigQuery</title>
      <link>https://nickyreinert.de/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/</link>
      <pubDate>Fri, 15 Aug 2025 12:34:56 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/</guid>
      <description>(or: How does blockchain mining work?)
A miner has to solve a mathematical problem to validate a block for the Blockhain. The so called Proof of Work requires a …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>A technical, two-part tutorial that first explains the Bitcoin &#34;Proof of Work&#34; mining algorithm in detail, and then demonstrates how to simulate this computationally intensive process using only SQL in Google BigQuery. The guide provides a complete BigQuery script that reconstructs the block header and iterates through the nonce and version fields to find a valid hash.</p>
          
          
          <p><strong>Hauptthemen:</strong> Blockchain, Bitcoin, SQL, Google BigQuery, Data Engineering, Cryptography</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p><em>(or: How does blockchain mining work?)</em></p>
<p>A miner has to solve a mathematical problem to validate a block for the Blockhain. The so called <strong>Proof of Work</strong> requires a lot of computing power aka energy and therefore is quite expensive. <strong>Googles BigQuery</strong> has a price model, that charges you for the transferred data and not the computing power. Meaning: You can utilize a lot of computing power for free. If you are able to reproduce the mining algorithm in SQL.</p>
<p>In this article I first will explain how the mining process works. This is the main concept for a couple of <strong>Blockchain</strong> technologies. My explanation is based on Bitcoin’s blockchain. If you are already familiar with that, you may skip to <strong>part 2</strong>, where I present an SQL query that does the job.</p>
<h1 id="part-1-the-mathematical-problem-aka-mining-a-block">Part 1: The mathematical problem aka: Mining a block</h1>
<h2 id="whats-a-hash-again">What’s a hash again?</h2>
<p>A hash is a kind of unique piece of information calculated from any given input (<a href="/wie-funktioniert-der-sha256-algorithmus-im-detail-teil-1-2-7a0023cf562a">I wrote about that earlier</a>). There are a lot of hashing algorithms. The blockchain we are talking about uses <strong>SHA256</strong>. It’s important to understand, that a hash is basically just a really large number with always the same length: <strong>256 bit</strong>.</p>
<p><strong>If you change the input, even just a little, the hash changes</strong>. This makes the hash a pretty good indicator to check if the input data has been tampered: If you know the original hash and you re-calculate the hash for a given information, and both hashes are different, the initial information has been changed.</p>
<h2 id="why-does-the-blockchain-rely-on-hashes">Why does the blockchain rely on hashes?</h2>
<p>Every block in a blockchain contains two kind of information: A couple of <strong>transactions details</strong> and a <strong>block header</strong>. Among other details the header contains <strong>two</strong> important <strong>hashes</strong>: One hash for all the transactions of the current block and one hash for the header of the previous block.</p>
<p>If you would tamper the transaction data of lets say block <strong>#1337</strong>, the hash of this block’s header would change. But as the next block’s header contains a hash for the original block #1337, you could simply compare both hashes and come to the conclusion, that the data in block #1337 has changed.</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image7.png" alt="How hashes ensure data integrity in a blockchain"></p>
<p>This sounds easy, because calculating one hash only takes milliseconds, even on slow computers. That’s why the blockchain protocol defines a very special requirement that every header’s hash has to meet: The hash of a block header has to be lower than a given number, the target.</p>
<blockquote>
<p>S ide note: Besides that there are some other rules that make the calculation even more difficult: For example you need to double-hash the information and you need to calculate the Merkle root of all transactions of the current block.</p></blockquote>
<p>You can meet this requirement by simply adding an incrementing number to the header information, re-calculate the hash, and see if the new hash is below the target.</p>
<p>The whole process is so complicated, that even powerful computers will take around 10 minutes to find a solution. That’s by the way a reason why Bitcoin is not the payment method: If you’d like to buy a <strong>coffee</strong>, you may have to wait around 10 minutes until your transaction is confirmed.</p>
<h2 id="the-block-header">The block header</h2>
<p>Let’s see what kind of information a block header contains. This is the header of <a href="https://learnmeabitcoin.com/explorer/block/00000000000000000006b9bf976b004581c19d800948d2eab77c8f9e07b9f088">block number 727938</a>:</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image4.png" alt=""></p>
<p>You will find six important fields here:</p>
<ul>
<li>a <strong>version</strong> field,</li>
<li>the hash for the <strong>previous block’s header,</strong></li>
<li>the <strong>Merkle root,</strong></li>
<li>a <strong>timestamp,</strong></li>
<li>a <strong>bits</strong> field, that defines the target and</li>
<li>a <strong>nonce</strong></li>
</ul>
<p>Let me describe those fields in detail:</p>
<p><strong>The nonce field</strong></p>
<p>If you take all header fields <strong>except the nonce field</strong>, you get the block message:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">04c04d34702a058fee2c141a685dfc3d18c4f0efc0464d625057060000000000000000005e578fe5fe001059710edbf9f78c1bd15b110faf574723cafde35667633c18084ac23462c0400a17
</span></span></code></pre></div><p>The SHA256 hash for this looks like that:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">5c96f247d3c6a48b244be859d888dd1ee2a80dd6378cc7e10f31b9d14b78660b
</span></span></code></pre></div><p>As mentioned above, the protocol requires you to add a specific kind of information to the block message, that leads to a hash below a given value. For starters lets make that easy: Find a number that leads to a hash starting with a zero. What if we add a 1 to the block message? (Remember: This is a hexadecimal number, so I need to add two digits):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">04c04d34702a058fee2c141a685dfc3d18c4f0efc0464d625057060000000000000000005e578fe5fe001059710edbf9f78c1bd15b110faf574723cafde35667633c18084ac23462c0400a17**01**
</span></span></code></pre></div><p>That’s the resulting hash:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">855ccd41ef49272ab633eff0cf5abed6d543ed5183eaf9f8a32e12a57b7419a9
</span></span></code></pre></div><p>No leading zeros? You may get a picture of how difficult it is. The actual target value for this block was a hash with <strong>19 leading zeros</strong>. The miner need to (find and) add the number 1.396.904.612 (in hexadecimal 0x534312a4) to the block message to find a fitting hash. And that number is called **nonce **— short for <strong>number used once</strong>. That’s the resulting hash:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">00000000000000000006b9bf976b004581c19d800948d2eab77c8f9e07b9f088
</span></span></code></pre></div><p>While calculation one hash seems pretty simple, imagine how long it would take for 1 Billion calculations, or even more? Even more? Yes, you heard right: The nonce is a four byte number meaning you have <strong>2³²</strong> possible numbers (<strong>4,294,967,296</strong>) to check (the so called <strong>search space</strong>). And sometimes that’s not enough.</p>
<h2 id="the-previous-blocks-header-hash">The previous block’s header hash</h2>
<p>This is just the hash of the header of the previous block. Not much to say here: You cannot change it.</p>
<h2 id="the-bit-field">The bit field</h2>
<p>This field defines the above mentioned target. It’s a 4 byte number, too:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0x170a40c0
</span></span></code></pre></div><p>A hash is a number with 32 bytes. And that’s strange: How can you limit a 32 byte number using only 4 bytes? Here it is: The first byte of the bit field defines an <strong>exponent</strong>: 0x17. The remaining 3 bytes define the <strong>mantissa</strong>: 0x0a40c0. The base is 256 and you need to substract 3 (length of the mantissa) from the exponent. So this is the formula to calculate the target:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">target = 0x0a40c0 × 256⁽⁰ˣ¹⁷ ⁻ ³⁾⁾
</span></span></code></pre></div><p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image1.png" alt="The bit field"></p>
<p>The target will be adjusted every <strong>2,016 blocks</strong>, which is roughly two weeks (6 blocks per hour × 24 hours × 7 days x 2 = 2,016). Why? The mathematical problem needs to be difficult enough to keep the chain safe but it must not be to difficult, because you do not want to wait more than 10 minutes for a transaction to be confirmed. As computing power changes or miners joining and leaving the network, the target and therefore the difficulty as to be adjusted.</p>
<h2 id="the-merkle-root">The Merkle root</h2>
<p>The Merkle root is a hash of all transactions of **the current block **(and a little more, I’m not going to much into detail here). Basically it’s pretty easy: You take two transactions and hash them to get Hash #1. Then you take two more transactions, hash them and get Hash #2. Now you take Hash #1 and Hash #2, hash it and get: Hash #3. You’re building an upside tree, where the transactions are on the bottom and the branches are dozens of hashes eventually leading to the root hash.</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image3.png" alt="a simple Merkle root"></p>
<p>If the search space is not enough, the miner can change the order of the transactions to create a different Merkle root. This would change the block message and therefore lead to a different hash.</p>
<h2 id="the-timestamp">The timestamp</h2>
<p>The timestamp, well, shows at what time the block was validated. In fact there is a lot more to tell about the timestamp, but not in a mathematical way.</p>
<p>The protocol uses the timestamp to see, how fast blocks are mined. As already explained, the network uses this value to adjust the difficulty.</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image6.png" alt="The date field"></p>
<p>A miner can use the timestamp field to increase the search space. A valid timestamp has to be <strong>greater</strong> than the median timestamp of the last 11 blocks and lower than the network-time plus <strong>2 hours</strong>. Eventually this gives you a <strong>3 hour</strong> window where you can adjust the timestamp to gain extra search space. 3 hours are 10,800 seconds (which is roughly 2¹³).</p>
<h2 id="the-version-field">The version field</h2>
<p>Last but definitely not least: The version field contains a lot more than you would expect. The version field is 4 bytes long and it</p>
<ul>
<li>contains the current protocol version,</li>
<li>signals readiness for soft fork proposals and</li>
<li>offers additional search space.</li>
</ul>
<p>That’s a lot of information and it’s not that easy to pull it out of those 4 bytes. The current protocol version requires the **first 3 bits **(!) to be at least <strong>0b001</strong> (2 in decimal):</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image8.png" alt=""></p>
<p>Besides that, the last 13 bits are used for soft forks signaling. This simply means, if a miner is ready for a particular soft fork, he flips on of those bits to 1. Imagine there’s a soft fork BIPx that requires the 1 bit to be flipped, that’s how the miner signals readiness for BIPx:</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image10.png" alt=""></p>
<p>This would lead to a version field like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0x20000001
</span></span></code></pre></div><p>As you may have noticed, this leaves 16 bits open (32 bits at all, mins 3 bits for the version and 13 bits for soft forks = 16 bits left). This gives the miner 2¹⁶ more options to find a good hash! That technique is called overt ASIC boost. Lets take the version field from <a href="https://blockstream.info/block/00000000000000000006b9bf976b004581c19d800948d2eab77c8f9e07b9f088?expand=">block #727938</a> for example: 0x344dc004</p>
<p>This is the bit representation of the hexadecimal value:</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image9.png" alt=""></p>
<p>So apparently the miner took 0b1010001001101110 (0d41582) as an additional resource to finally find the fitting nonce 0xa4124353.</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image5.png" alt="The version field"></p>
<h2 id="block-header-summary">Block header summary</h2>
<p>So after all you have <strong>six fields</strong> in your header, where only <strong>two fields</strong> are fixed and <strong>cannot</strong> be changed in order to find a hash below the given target: The <strong>bit</strong> field, that describes the <strong>target</strong> itself and the hash for the **previous header — **the vital element of the Blockchain concept..</p>
<p>Besides that you may change the <strong>nonce</strong>, the one field actually designed to change. The <strong>Merkle</strong> <strong>root</strong>, by re-arranging or considering different transactions. The <strong>version</strong> field and the <strong>timestamp</strong> by exploiting the 3 hour time window.</p>
<p>To give you an idea how complex it is to utilize at least the <strong>nonce</strong> and the <strong>version</strong> field, I created a Python script that does that for you:</p>
<h1 id="part-2-using-sql-and-bigquery-to-validate-a-block">Part 2: Using SQL and BigQuery to validate a block</h1>
<p>Now as you are an expert in mining, let’s try to find a way to mine for free. I will implement a mining algorithm in SQL that iterates through the nonce and the additional version bits to find a hash below a required target. I’m not re-arranging the Merkle root and I will take the timestamp as a given value.</p>
<p>To make the whole process understandable, I will start from within the inner loop and calculate the hash from a given header, that already contains all the correct “answers”. I’m using the header for <a href="https://blockstream.info/block/000000000000000000078c7ad45ab182796bbb419c361aa3eaffaa8ddd00d4f0">block #727155</a> with all the information already in the right format. After we understand the hashing process in BigQuery, we will build the header field by field and finally add the two loops.</p>
<p>And here they are — the variables for my <strong>six header fields.</strong> Remember that the version field contains the actual version as well as the soft fork signals.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># header for block 727155DECLARE hash_prev_block STRING DEFAULT &#34;00000000000000000004136135b2e0cd367b56ea6c0dd5b8f79964a4cd7d2718&#34;;DECLARE merkle_root STRING DEFAULT &#34;0d14fac91555d6337b10b2f20de231858fb5225f2ff685cd9b487c235d6e8307&#34;;DECLARE header_datetime STRING DEFAULT &#34;622defb9&#34;;DECLARE bits STRING DEFAULT &#34;170a3773&#34;;DECLARE nonce STRING DEFAULT &#34;c8f05860&#34;;DECLARE version STRING DEFAULT &#34;20002000&#34;;
</span></span></code></pre></div><p>We simply need to concatenate everything into one string before we hash it. Simply? Wait…there’s one pitfall called Little Endian. Bitcoin wants you to work with values in Little Endian. This is the way how you can write a number. In one sentence: Little Endian starts with the lowest value on the left. Basically you just switch the order of the single digits in your number. Instead of 23 you write 32. The value though remains the same. You achieve that using the REVERSE() function in SQL.</p>
<p>But beware — there’s more: What would you expect if you <em>reverse</em> the following hexadecimal value to Little Endian?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ABCDEF
</span></span></code></pre></div><p>Is it FEDCBA? No. We are working with bytes. One byte is 8 bits which is enough space for 255 values or in hexadecimal: FF. Two digits. That means we have to see all them values in pairs of two and the correct Little Endian representation is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">EFCDAB
</span></span></code></pre></div><p>To get this result you need to read the incoming value in bytes format and afterwards transfer it back to hexadecimal string. So this is how we create the actual header:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DECLARE header STRING;SET header =    TO_HEX(REVERSE(FROM_HEX(version))) ||    TO_HEX(REVERSE(FROM_HEX(hash_prev_block))) ||    TO_HEX(REVERSE(FROM_HEX(merkle_root))) ||    TO_HEX(REVERSE(FROM_HEX(header_datetime))) ||    TO_HEX(REVERSE(FROM_HEX(bits))) ||    TO_HEX(REVERSE(FROM_HEX(nonce)));
</span></span></code></pre></div><p>And that’s the header containing all relevant fields in Little Endian:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0020002018277dcda46499f7b8d50d6cea567b36cde0b23561130400000000000000000007836e5d237c489bcd85f62f5f22b58f8531e20df2b2107b33d65515c9fa140db9ef2d6273370a176058f0c8
</span></span></code></pre></div><h2 id="the-hashing">The Hashing</h2>
<p>BigQuerys build-it SHA256 expects a string or a byte but the header is made of hexadecimal values. So first we need to prepare the header, meaning: convert the hexadecimal string to the bytes format:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DECLARE b_header BYTES;SET b_header = FROM_HEX(header);
</span></span></code></pre></div><p>Now we can apply SHA256. And as mentioned above, we need to do it two times. The result of SHA256 comes in bytes, o we have to convert it back to a hexadecimal string:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">SELECT TO_HEX(SHA256(SHA256(b_header)))
</span></span></code></pre></div><p>That finally leads to this result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">f0d400dd8daaffeaa31a369c41bb6b7982b15ad47a8c07000000000000000000
</span></span></code></pre></div><p>And now you hopefully remember that we were running everything in Little Endian. To finalize the process we need to convert it back to Big Endian and finally get to this hexadecimal number:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">SELECT TO_HEX(REVERSE(SHA256(SHA256(b_header))));
</span></span></code></pre></div><p>And that’s the result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">000000000000000000078c7ad45ab182796bbb419c361aa3eaffaa8ddd00d4f0
</span></span></code></pre></div><p>that you now may compare to <a href="https://blockstream.info/block/000000000000000000078c7ad45ab182796bbb419c361aa3eaffaa8ddd00d4f0">the actual header hash the next block refers to</a>:</p>
<p><img src="/en/blog/2025/08/15/how-to-simulate-proof-of-work-in-sql-and-bigquery/assets/image2.png" alt=""></p>
<h2 id="prepare-the-inner-loop">Prepare the inner loop</h2>
<p>We’re going to wrap everything into a while-loop, add a break-out condition for safety reasons and start with a comparison of the just found hash and a target. Because that’s what it’s all about: Find a “number” (hash) that is lower than another “number” (target).</p>
<p>The target value is hidden in the bits field. And as already mentioned, we need to do the math to get the numeric target. The mantissa comes from the last 3 bytes, the exponent is the first byte. And the target comes from this equation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">target = mantissa * 256 ^ exponent
</span></span></code></pre></div><p>And this, well, leads to a pretty big number. Actually to big to fit into an INT64. We have to store it into a FLOAT64 and to make it comparable against the previously calculated hash, we need to cast the hash to FLOAT64, too.</p>
<p>Here’s the loop containing the condition, that returns the nonce — that we are looking for and a little break-out-statement, because we’re just testing how it’s working:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># skipping previous declarations from above# [...]DECLARE mantissa INT64DECLARE exponent INT64DECLARE target FLOAT64;DECLARE max_iterations INT64 DEFAULT 100;DECLARE iteration INT64 DEFAULT 0;SET exponent = CAST(CONCAT(&#34;0x&#34;, SUBSTRING(bits, 0, 2)) AS INT64)SET mantissa = CAST(CONCAT(&#34;0x&#34;, SUBSTRING(bits, 2, 4)) AS INT64);SET target = mantissa * POWER(256, exponent);WHILE true DO    SET header         TO_HEX(REVERSE(FROM_HEX(version))) ||        TO_HEX(REVERSE(FROM_HEX(hash_prev_block))) ||        TO_HEX(REVERSE(FROM_HEX(merkle_root))) ||        TO_HEX(REVERSE(FROM_HEX(header_datetime))) ||        TO_HEX(REVERSE(FROM_HEX(bits))) ||        TO_HEX(REVERSE(FROM_HEX(nonce)));    SET b_header = FROM_HEX(header);    SET header_hash = TO_HEX(REVERSE(SHA256(SHA256(b_header))));    IF CAST(CONCAT(&#34;0x&#34;, header_hash) AS FLOAT64) &lt; target THEN        SELECT nonce;        BREAK;    END IF;    IF iteration &gt; max_iterations THEN        SELECT &#34;No nonce found&#34;;        BREAK;    END IF;    SET iteration = iteration + 1;END WHILE;
</span></span></code></pre></div><h2 id="complete-the-loop">Complete the loop</h2>
<p>Yeah well — isn’t that something? The only thing we need to do now is to actually iterate through the nonce to let the query find the correct value. To have an iterable variable we need one of the type FLOAT64. I will set the value a little bit under the expected target, to speed up the testing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DECLARE nonce_dec FLOAT64 DEFAULT 3371190464; 
</span></span></code></pre></div><p>Now, after the loop starts and before we collect all header details,we need to get the hexadecimal nonce. And at the end of the loop, we increment the decimal nonce:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">WHILE true DO    SET nonce = FORMAT(&#34;%X&#34;, nonce_dec);    SET header =        [....]    SET nonce_dec = nonce_dec + 1;END WHILE;
</span></span></code></pre></div><h2 id="adding-the-second-loop">Adding the second loop</h2>
<p>Now as we already learned, it may not be enough to test 2⁶⁴ possible numbers to find a fitting nonce. That’s why we’re going to add another loop to use the <strong>version field</strong> for some additional search space. Unfortunately this is a little more complicated. So, what do we need? Binary numbers!</p>
<p>This is the version for our famous block # 727155. Again we’re using this as an example. If you’d like to mine a new block, you need to adjust at least the soft fork part.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0x20002000
</span></span></code></pre></div><p>In binary that is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">00110100010011011100000000000100
</span></span></code></pre></div><p>The last 13 bits are representing the soft work readiness. That’s a given value. The version is pre-defined to be (at least) 001 for the first 3 bits. We’re taking the easy route here and are going to declare this in binary already. The remaining 16 bits are up and ready to be iterated through:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DECLARE soft_forks STRING DEFAULT &#34;0000000000000&#34;;DECLARE version_roller INT64 DEFAULT 1;DECLARE version_roller_bin STRING;DECLARE version_bits STRING DEFAULT &#34;001&#34;;
</span></span></code></pre></div><blockquote>
<p>Please note, that I’m setting the version_roller to 1— that’s the one used in the block we are working on. Again, this is to speed up the demonstration here.</p></blockquote>
<p>We will use an additional outer loop to iterate over the version roller. The iteration comes at the end, at the beginning of the loop we need to process the decimal value to get 16 bits out from it and press it into the hexadecimal format:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">main_loop: WHILE true DO        SET version_roller_bin = SUBSTR(bqutil.fn.to_binary(version_roller), -16);    SET version = FORMAT(&#34;%X&#34;, bqutil.fn.from_binary(CONCAT(version_bits, version_roller_bin, soft_forks)));WHILE true DO        [....]    END WHILE;    SET version_roller = version_roller + 1;END WHILE;
</span></span></code></pre></div><p>Take care of the label I set here to address the loop: <strong>MAIN_LOOP</strong>. I <strong>have to reference</strong> the outer loop when breaking from inside the inner loop:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">    [...]    BREAK main_loop;    [...]
</span></span></code></pre></div><p>Check out the full script in final part.</p>
<h2 id="congratulations-and-conclusion">Congratulations and Conclusion</h2>
<p>Basically that’s it. That’s how the full script should look like this (<a href="https://gist.github.com/nickyreinert/2d0936922bbf242429c21af3c5b6866b">gist.github.com</a>). Feel free to increase the value for <strong>max_iterations</strong> and set the starting value for <strong>nonce_dec</strong> to 0 and see how long it will take Google to find the correct nonce.</p>
<p>This is a lot of weird SQL stuff and far away from SELECT * FROM table. Is it worth it? Well, I set the starting nonce to 3370194460 and executed the script.</p>
<p>Spoiler Alert: After 10 minutes I stopped the query. Another approach (see below) seems way faster, though it’s a cheating with the actual calculations.</p>
<h2 id="disclaimer">Disclaimer</h2>
<p>I will not loose much words about <strong>Proof of Work.</strong> The process itself is sophisticated and somehow thoughtfull… as well as a little weird. But above all it’s also a huge wast of energy and there are better ways to achieve the same outcome. I’d like to end with a quote from another author on Medium who said:</p>
<blockquote>
<p>You’ve got to wonder what we’d achieve if we used even a fraction of this computing power for medical research instead…</p></blockquote>
<h1 id="additional-ressources">Additional ressources</h1>
<p><a href="https://medium.com/fcats-blockchain-incubator/understanding-the-bitcoin-blockchain-header-a2b0db06b515">This is a pretty good and helpful medium article</a> about the Blockchain header by RJ Rybarczyk. <a href="https://learnmeabitcoin.com/explorer/block/bits/170a40c0">This is a website</a> that provides a lot of technical background information as well as tools to calculate hashes or browse the Blockchain.</p>
<p>A couple of years ago Uri Shaked also <a href="https://urish.medium.com/thank-you-google-how-to-mine-bitcoin-on-googles-bigquery-1c8e17b04e62">wrote about this topic</a>. I stumbled over his article while doing research. But he was pursuing a different approach. First of all he was using a <strong>random feature</strong> to find a fitting nonce. I also considered this before, but as you cannot ensure to ge the same random value twice, you will waste a lot of time (he actually calculated the same nonce within 20 seconds, which still is faster than my approach). Besides that he was using sub-queries to create temporary tables filled with the nonce.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Blockchain, SQL, BigQuery, Tutorial, Bitcoin</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>blog</category>
      
      <category>anleitungen</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/assets/image1.png" type="image/jpeg">
        <media:title>How to simulate proof of work in SQL and BigQuery - Title Image</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item><item>
      <title>The Bitcoin Puzzle</title>
      <link>https://nickyreinert.de/en/blog/2024/10/01/the-bitcoin-puzzle/</link>
      <pubDate>Tue, 01 Oct 2024 12:34:56 +0100</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/en/blog/2024/10/01/the-bitcoin-puzzle/</guid>
      <description>In this post, I’ll explain how I fell into a deep rabbit hole. I’ll cover how the puzzle works and how the algorithm can be optimized in Python using techniques …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>A deep-dive into solving a famous Bitcoin puzzle, documenting a journey of performance optimization. The article explains the puzzle&#39;s cryptographic basis and then iteratively improves a Python solver using parallelization, Cython, and ultimately GPU acceleration with Apple&#39;s Metal API, demonstrating a significant increase in computation speed.</p>
          
          
          <p><strong>Hauptthemen:</strong> Bitcoin, Cryptography, Python, Performance-Optimierung, GPU-Computing, Apple Metal, High-Performance Computing</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>In this post, I’ll explain how I fell into a deep rabbit hole. I’ll cover how the puzzle works and how the algorithm can be optimized in Python using techniques like parallelization and pre-compiling with Cython. Finally, I’ll reveal how you can increase computation speed by nearly 100x by implementing Metal to fully harness the power of your Apple Silicon. Let’s go!</p>
<h2 id="the-puzzle">The Puzzle</h2>
<p>It all started with 256 transactions of roughly <a href="https://www.blockchain.com/de/explorer/transactions/btc/08389f34c98c606322740c0be6a7125d9860bb8d5cb182c02f98461e5fa6cd15.">33 BTC in January 2015</a>. The first transaction to wallet #1 contained 0.001 BTC, wallet #2 received 0.002 BTC, then 0.003 BTC to wallet #3 and so on — the final wallet #256 received an amount of 0.256 BTC. Back in those days, the 33 BTC were worth about $5,000.</p>
<p>In the following years, additional transactions were made to adjust each wallet’s balance. In 2017, the balances from wallets 161 to 256 were moved to the lower ranges. And in 2023, someone — allegedly the creator — released another 900 BTC to all wallets from #66 upwards, following a similar principle. Wallet #66 is now worth 66 BTC instead of 0.66 BTC, and so on. At this point, the value of the transferred BTC summed up to over $27 million.</p>
<p>The goal of this exercise is to guess the corresponding private key from the known public address of each wallet. You might think this is impossible because it’s based on a hashing algorithm and you can’t just reverse it or brute-force the whole range of possible combinations.</p>
<p>You are right. Basically…</p>
<p>That’s why the creator limited the complexity of each private key. The first private key has an upper range limit of 1. What does that mean? As the private key is basically just a (huge) number, in the case of the first wallet, you just have to test all numbers from 0 to the upper limit of 1. This means calculating the public key (or signing key) and the compressed wallet address, and comparing it with the known wallet address. If there’s a match, you have access to the wallet and can claim your reward.</p>
<p>These are the first 10 items that were solved quickly after the puzzle was released (<a href="https://privatekeys.pw/puzzles/bitcoin-puzzle-tx">full list</a>)</p>
<pre><code>Index 0:   Hash: 00[..]00   Address: C 1BgGZ9tcN4[..]Z26SAMH  
Index 1:   Hash: 00[..]03   Address: C 1CUNEBjYrC[..]4wpP326Lb  
Index 2:   Hash: 00[..]07   Address: C 19ZewH8Kk1P[..]EiCjTRaZMZQA  
Index 3:   Hash: 00[..]08   Address: C 1EhqbyUMvvs7[..]D6YKfPqb7e  
Index 4:   Hash: 00[..]15   Address: C 1E6NuFjCi2[..]q84zJeBW3k  
Index 5:   Hash: 00[..]31   Address: C 1PitScNLyp2H[..]fveTnfmpPbfp8  
Index 6:   Hash: 00[..]4c   Address: C 1McVt1vMtCC7[..]yCcLXzueeC  
Index 7:   Hash: 00[..]e0   Address: C 1M92tSqNmQLYw[..]d1ysMBxK  
Index 8:   Hash: 00[..]d3   Address: C 1CQFwcjw1dwht[..]L7ivBonGPV  
Index 9:   Hash: 00[..]202   Address: C 1LeBZP5QCwwgXR[..]PUokyLHqe
</code></pre>
<p>So what’s the challenge here? Well, the complexity increases with every wallet by the power of 2. While the first wallet was limited to one private key (2⁰ to 2¹) , the second wallet goes from 2¹ to 2² — 1 (2 possible private keys). Wallet #3’s private key features a range from 4 to 7, and so on. The ranges increase exponentially. The final wallet #160 covers a range from 2¹⁵⁹ to 2¹⁶⁰ — 1, resulting in 7,307,508,186,700,000,000,000,000,000,000,000,000 possible private keys — 73 octillions. Have fun with that. (FYI: The universe is estimated to have about 10⁸⁰ atoms.)</p>
<p>At the lower levels, this is quite a simple task that takes just seconds to solve. And that’s why the first 66 private keys have already been found, as well as some outliers in the upper ranges.</p>
<h2 id="trivia">Trivia</h2>
<p>First of all, it is not known who actually created this task, puzzle, or riddle — whatever you want to call it.</p>
<p>Second, there was a lot of volume going through this wallet: tens of thousands of transactions with millions of BTC. <a href="https://www.blockchain.com/de/explorer/addresses/btc/173ujrhEVGqaZvPHXLqwXiSmPVMo225cqT">The last transaction took</a> place in 2017, ignoring the winner claiming their rewards.</p>
<p>Third, this has created a rabbit hole for some people, like me. In the chase for the big prize, they are not only throwing hardware into the ring but also knowledge and inventive minds. One of the <a href="https://bitcointalk.org/index.php?topic=5218972.0">“official threads”</a> has dozens of pages where people share their findings; they built algorithms to improve the process further and further.</p>
<p>And fourth, this challenge reveals a drawback of the Bitcoin transaction system. A couple of days ago, someone found the private key for wallet #66. He or she tried to withdraw the prize from the wallet. An attacker who was watching the chain for transactions was able to “hijack” this transaction and steal the funds.</p>
<h2 id="bitcoins-double-spending-attack">Bitcoins double spending attack</h2>
<p>To understand how this attack works, you need to understand how the puzzle and Bitcoin transactions work. Each transaction requires three important components to identify the recipient: A private key, a verifying (signing) key and a wallet address.</p>
<p>By performing elliptic curve multiplication (SECP256k1), you can derive the verifying key from the private key Next, you apply several hashing operations to obtain the public wallet address:</p>
<ul>
<li>SHA-256</li>
<li>RIPEMD-160</li>
<li>2 x SHA-256</li>
<li>and finally a (simple) Binary-58 encoding</li>
</ul>
<p><img src="/en/blog/2024/10/01/the-bitcoin-puzzle/required_computation_steps.png" alt="required computation steps"></p>
<center><i>required computation steps from private key to wallet address</i></center>
<p>The ultimate goal is to find the private key for a known wallet address. As you can see, obtaining the verifying key requires only one operation, while calculating the wallet address is the more complex part. Solving this puzzle requires you to follow all the steps.</p>
<p>If you find a valid private key for a given wallet address, you can initiate a transaction signed with the now-known verifying key. You need to submit both the wallet address and the verifying key to get confirmation from the blockchain.</p>
<p>Typically, confirmation takes around 10 minutes — that’s how Bitcoin works. An attacker can monitor the blockchain for transaction requests that contain one of the 160 known wallet addresses from the puzzle. Once a request appears, the attacker obtains the verifying key from it, and the clock starts ticking. You’ve already done the hard work of brute-forcing the wallet address from the verifying key. The attacker only needs to go through all possible private keys — which is a limited range in this puzzle — and perform the relatively straightforward SECP256k1 operation to find the matching key (although it’s not as simple as it sounds).</p>
<p>If the attacker succeeds within the 10 minutes, they can submit their own transaction request with a much higher transaction fee. Due to the nature of Bitcoin, miners will prioritize the higher fee and confirm the attacker’s request.</p>
<p>Keep in mind that this method does not work universally for all transactions on the blockchain, as private keys are typically much more complex. Nonetheless, it highlights a significant drawback in the process.</p>
<p>Enough talk — let’s dive into the race and participate.</p>
<h2 id="the-algorithm">The algorithm</h2>
<p>First, we will create a public (or signing) key from the private key using the elliptic curve algorithm SECP256k1.</p>
<p><img src="/en/blog/2024/10/01/the-bitcoin-puzzle/eliptic_curve.png" alt="eliptic curve"></p>
<center><i>An eliptic curve (Source: https://en.bitcoin.it/wiki/File:Secp256k1.png)</i></center>
<p>Superficial Note on the Algorithm: SEC stands for Standards for Efficient Cryptography, P represents the prime number 2²⁵⁶ - 2³² - 977 on which this curve is based, 256 denotes the length of the private key in Bit and k1 refers to the Koblitz curve, a specific type of elliptic curve. The actual curve is defined by the equation:</p>
<pre><code>y²=x³ + 7
</code></pre>
<p>Of course there’s a Python Library for that:</p>
<pre><code>private_key_hex = f’{1:064x}’
private_key_bytes = binascii.unhexlify(private_key_hex)
public_key = ecdsa.SigningKey.from_string(private_key_bytes, curve=ecdsa.SECP256k1)
</code></pre>
<p>As mentioned earlier, we need to compress the public key. The details are not important right now; just trust me, this step brings us closer to our goal.</p>
<pre><code>verifying_key = public_key.verifying_key
x = vk.to_string()[:32]
y = vk.to_string()[32:]

y_int = int(binascii.hexlify(y), 16)

if y_int % 2 == 0:
    compressed_public_key = b'\x02' + x
else:
    compressed_public_key = b'\x03' + x

compressed_public_key binascii.hexlify(compressed_public_key).decode()
</code></pre>
<p>Finally, we perform SHA-256 followed by RIPEMD-160 to calculate the wallet address. If you’re interested in how SHA-256 works, I’ve written two extensive posts about it!</p>
<pre><code>compressed_public_key_bytes = binascii.unhexlify(compressed_public_key_hex)

sha256_hash = hashlib.sha256(compressed_public_key_bytes).digest()

ripemd160 = hashlib.new('ripemd160')

ripemd160.update(sha256_hash)  

ripemd160_hash = ripemd160.digest()

versioned_payload = b'\x00' + ripemd160_hash

bitcoin_address = base58check_encode(versioned_payload)
</code></pre>
<p>I’ve compiled everything into a Jupyter notebook, which you can find on GitHub. Let’s see how it performs for the 20th wallet. This will test 524,288 possible numbers, ranging from 2¹⁹ to 2²⁰-1:</p>
<pre><code>target_address = '15JhYXn6Mx3oF4Y7PcTAv2wVVAuCFFQNiP'  

measure_performance(19, 20, target_address)
</code></pre>
<p>On my Apple M3 with 36 GB RAM it took about 30 seconds:</p>
<pre><code>Private Key (Decimal): 863317 
Private Key (Hex): 00000000000000000000000000000000000000000000000000000000000d2c55 
Compressed Public Key: 033c4a45cbd643ff97d77f41ea37e843648d50fd894b864b0d52febc62f6454f7c 
Bitcoin Address (Base58Check): 1HsMJxNiV7TLxmoF6uJNkydxPFDog4NQum 
Total time taken: 24.530259 seconds 
Average time per iteration: 0.047 ms
Initial CPU Usage: 29.7% 
Final CPU Usage: 28.5% 
Initial Memory Usage: 162.12 MB 
Final Memory Usage: 162.25 MB
</code></pre>
<p>This looks like a great starting point for some fine-tuning</p>
<h2 id="parallel-threads">Parallel Threads</h2>
<p>(rel. <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v1.py">bitcoinPuzzle-v1.py</a>)</p>
<p>First, let’s move from Jupyter to a Python file and try to implement parallel threads. To effectively use parallel computing, we need to determine how many units we can actually utilize. We can leverage some built-in Python functions to find this out (also see section Measure available system resources in this Notebook):</p>
<pre><code>multiprocessing.cpu_count()
</code></pre>
<p>This returns 12, so that’s the number of units we’ll use. Implementing concurrent processes in Python is quite straightforward. You can use either multiprocessing.Pool or concurrent.futures.ProcessPoolExecutor, which serves as a wrapper class.</p>
<pre><code>  with concurrent.futures.ProcessPoolExecutor(max_workers=12) as executor:

  # Part 1 - starting parallel threads for generate_key()
  
  future_to_index = {
  
  executor.submit(generate_key, start_at, target_address): start_at
  
  for start_at in range(min_val, max_val + 1)}
  
    last_reported_percent = 0
  
  # Part 2 - watch each running thread for result
  
  for future in concurrent.futures.as_completed(future_to_index):
  
    if found: break
  
    result = future.result()
  
    if result: found = result; break
      current_percent = (i + 1) * 100 // n
  
  print('Done')
</code></pre>
<p>The idea is simple: at some point, we start a few threads and monitor the output of each process.</p>
<p>Try running it, and you’ll notice that it takes quite a long time. In our case, this approach isn’t very efficient. The generate_key function is relatively fast, but it gets called twelve times, resulting in significant overhead from thread management. If generate_key were a heavier function, we could maintain this structure. However, in this scenario, we need to divide the search range into batches.</p>
<h2 id="batching">Batching</h2>
<p>(rel. <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v2.py">bitcoinPuzzle-v2.py</a>)</p>
<p>To clarify things a bit, we can create a wrapper function called batch_key_generation.</p>
<pre><code>def batch_key_generation(start, end, target_address):

  found_key = None
  
  for i in range(start, end):

    res = generate_key(i, target_address)
    
    if res:
    
      found_key = res
      
      break
    
    return found_key
</code></pre>
<p>The optimal batch size is determined by the number of threads. We could use a bigger value, but then the last thread would have less data to work with. And if the batch size is to small, we’d had to launch more threads than availbl processing units. Which agains creates to much overhead.</p>
<pre><code>batch_size = n // num_workers # Assuming you want 12 workers  

# [...]

future_to_index = {

  executor.submit(

    batch_key_generation, 

    start, 

    min(start + batch_size, max_val + 1), 

    target_address): start for start in range(min_val, max_val + 1, batch_size)

}
</code></pre>
<p>Now, the execution time has decreased dramatically to just 5 seconds!</p>
<pre><code>Processed 524289 out of 524288 keys (100%)...
Processed 1048569 out of 524288 keys (199%)...
Total time taken: 5.517847 seconds
Average time per iteration: 0.011 ms
Initial CPU Usage: 40.0%
Final CPU Usage: 96.8%
Initial Memory Usage: 15.20 MB
Final Memory Usage: 16.86 MB
</code></pre>
<p>Great! What’s next?</p>
<h2 id="stop-at-succes">Stop-At-Succes</h2>
<p>(rel. <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v3.py">bitcoinPuzzle-v3.py</a>)</p>
<p>Did you notice the slight delay between the success confirmation and the actual termination of the script? This occurs because the pool manager waits for all other threads to finish. We need a global flag to monitor the success state. Here’s how to do it:</p>
<p>First, we wrap our thread loop in a Manager, which acts as a global watchdog for shared state. We also provide a lock and our global state, found_flag, to our calculation function:</p>
<p>with Manager() as manager:</p>
<pre><code>found_flag = manager.Value('i', False)

lock = manager.Lock()

concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:

future_to_batch = {

  executor.submit(

    batch_key_generation,
    start, 
    min(start + batch_size, max_val + 1), 
    target_address, 
    found_flag, 
    lock): start for start in range(min_val, max_val + 1, batch_size) }  
</code></pre>
<p>[&hellip;]</p>
<p>Of course, we should check this global variable in our wrapper function batch_key_generation so that it can stop iterating when needed.</p>
<pre><code>def batch_key_generation(start, end, target_address, found_flag, lock): 
  found_key = None 

  for i in range(start, end):

    if found_flag.value: # check if it's been set from anywhere else

      return None # and then exit early, if required

    res = generate_key(i, target_address) 

    if res: 

      with lock: 

        if not found_flag.value: # double-check

          found found_flag.value = True # and tell all other process, that we found a key

          found_key = res 

          break 

return found_key  
</code></pre>
<p>There’s an important drawback: accessing the lock is a “time-consuming” operation. You will notice a slower processing time when using the lock, which can increase the total execution time from 5 seconds to 11 seconds. You need to decide whether you want a quick result on the command line while the threads are still running or if you’re willing to add this extra time to ensure that all threads finish by the end of the script.</p>
<h2 id="cython--pre-compile-our-code">Cython — pre compile our code</h2>
<p>(rel. <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v4.pyx">bitcoinPuzzle-v4.pyx</a> and <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v4-setup.py">bitcoinPuzzle-v4-setup.py</a>)</p>
<p>There’s another trick to speed up processing: precompiling the Python code. Don’t worry, it sounds more complicated than it actually is. We just need to rename the extension of our Python script to .pyx and create a setup.py file like this:</p>
<pre><code>from setuptools import setup
from Cython.Build import cythonize
setup(ext_modules = cythonize(&quot;bitcoinPuzzle-v4.pyx&quot;))
</code></pre>
<p>Now we compile the file into a binary library (you may ignore the warnings):</p>
<pre><code>python bitcoinPuzzle-v4_setup.py build_ext --inplace
</code></pre>
<p>After that, we can either run our script from the command line or use it in any other script:</p>
<pre><code>python -c &quot;import bitcoinPuzzle_v4; bitcoinPuzzle-v4.measure_performance(19, 20, '1HsMJxNiV7TLxmoF6uJNkydxPFDog4NQum', 12)&quot;
</code></pre>
<p>It may not seem significantly faster, likely due to the overhead. However, if you try larger ranges, you will definitely notice a difference. Also, remember that we implemented the global flag to exit the batch processing prematurely.</p>
<h2 id="random-batches">Random batches</h2>
<p>(rel. bitcoinPuzzle_v5.py)</p>
<p>Well, this approach is more of a hack than a true improvement. The idea is simple: as the range increases, processing all possible variations takes more time. However, since we are searching for a needle in a vast field of haystacks, why should we start iterating from the bottom to the top like everyone else? Instead, we could pick random locations, hoping to achieve a quicker win than our “opponents”!</p>
<p>The implementation is straightforward. First, we create a list containing all starting points based on the chunk size, and then we shuffle it.</p>
<pre><code>start_points = list(range(min_val, max_val + 1, chunk_size)) 

random.shuffle(start_points)
</code></pre>
<p>As this is a hack that cannot be measured in time, I’m right jumping to the final improvement:</p>
<h2 id="what-about-pytorch">What about Pytorch?</h2>
<p>(rel: <a href="https://github.com/nickyreinert/Bitcoin-Puzzle/blob/main/bitcoinPuzzle-v5.ipynb">bitcoinPuzzle-v5.ipynb</a>)</p>
<p>First, we need to identify the most expensive operations in this puzzle and then try to improve it further. Let’s determine how long it takes to run 10,000 private keys through the following processes:</p>
<pre><code>SECP256k1): 2.37 seconds
3 x SHA-256): 0.02 seconds
RIPEMD160): 0.01 seconds
BASE58: 0.09 seconds
</code></pre>
<p>The elliptic curve operation is clearly the bottleneck. Currently, we are only utilizing our CPU without taking advantage of the full power of more sophisticated processing units like a GPU or MPS. PyTorch could assist with that, but it doesn’t natively support SECP256k1. Therefore, we need to find another solution, and this is called:</p>
<h2 id="metal">Metal!</h2>
<p>(rel: <a href="https://github.com/nickyreinert/Metal-To-Python-API/blob/main/computation.metal">computation.metal</a>)</p>
<p>Metal is a high-performance graphics and computing API created by Apple that allows developers to harness the full power of the GPU for tasks beyond just rendering graphics, such as machine learning and data processing. It provides low-level access to the GPU, enabling more efficient parallel processing and better performance for applications on iOS and macOS devices.</p>
<p>Spoiler Alert: I wasn’t able to fully implement the working SECP256k1 algorithm in Metal, primarily because the elliptic curve algorithm requires 256-bit integers, which are not natively supported in Metal. This limitation necessitates significant adjustments. However, the performance gains are impressive, and I’m actively working on it!</p>
<p>For demonstration purposes, I chose a mathematical operation that can be implemented in PyTorch, pure Python, and Metal: the cosine!</p>
<p>In Metal we simply create a so called kernel function:</p>
<pre><code>kernel void benchmark(device const float *inputData [[buffer(0)]],
                      device float *outputData [[buffer(1)]],
                      uint id [[thread_position_in_grid]]) {
    
    // Get the input data for the current thread
    float inputValue = inputData[id];
    
    // Compute the cosine of the input value
    float result = cos(inputValue);
    
    // Store the result of the computation in the output buffer
    outputData[id] = result; // Store the computed cosine
    
}
</code></pre>
<p>We compile it using Xcode’s command line tools:</p>
<pre><code>xcrun -sdk macosx metal -fcikernel -c computation.metal -o computation.air
xcrun -sdk macosx metallib computation.air -o computation.metallib
</code></pre>
<p>This command will compile the source code into a Metal library. The most important flag here is -fcikernel, which is necessary to enable the kernel code to run on the GPU.</p>
<p>Here’s the complicated part: we need a wrapper in Swift to bridge the Metal source to Python later on.</p>
<p>First we initiate our metal device, the GPU:</p>
<pre><code>guard let device = MTLCreateSystemDefaultDevice() else {
    print(&quot;Error: Unable to create Metal device.&quot;)
    return 0
}
</code></pre>
<p>Now we reference the benchmark function from the external library we just compiled:</p>
<pre><code>let metallib =  &quot;\(#file.replacingOccurrences(of: &quot;/wrapper.swift&quot;, with: &quot;&quot;))/../computation.metallib&quot;

guard let library = try? device.makeLibrary(filepath: metallib) else {
    print(&quot;Error: Unable to create Metal library from \(metallib).&quot;)
    return 0
}

guard let kernelFunction = library.makeFunction(name: &quot;benchmark&quot;) else {
    print(&quot;Error: Unable to load benchmark function.&quot;)
    return 0
}
</code></pre>
<p>After that we initiate our command queue as well es input and output buffers:</p>
<pre><code>// Create a command queue
guard let commandQueue = device.makeCommandQueue() else {
    print(&quot;Error: Unable to create command queue.&quot;)
    return 0
}

// Create a command buffer and encoder
guard let commandBuffer = commandQueue.makeCommandBuffer(),
      let encoder = commandBuffer.makeComputeCommandEncoder() else {
    print(&quot;Error: Unable to create command buffer or encoder.&quot;)
    return 0
}

// Create the compute pipeline state
let computePipelineState = try device.makeComputePipelineState(function: kernelFunction)

// Set the compute pipeline state
encoder.setComputePipelineState(computePipelineState)

// Create input buffer for GPU
let inputByteLength = numItems * MemoryLayout&lt;Float&gt;.size
let inputBuffer = device.makeBuffer(bytes: inputData, length: inputByteLength, options: [])
encoder.setBuffer(inputBuffer, offset: 0, index: 0)

// Create output buffer for GPU
let outVectorBuffer = device.makeBuffer(length: inputByteLength, options: .storageModeShared)
encoder.setBuffer(outVectorBuffer, offset: 0, index: 1)&lt;
</code></pre>
<p>And as we also want to utilize parallel computing, we need to define how many parallel threads we want to run:</p>
<pre><code>let threadsPerGroup = MTLSize(width: 64, height: 1, depth: 1)
let numThreadgroups = MTLSize(width: (numItems + threadsPerGroup.width - 1) / threadsPerGroup.width, height: 1, depth: 1)
encoder.dispatchThreadgroups(numThreadgroups, threadsPerThreadgroup: threadsPerGroup)
# tell the encoder, that we are &quot;done&quot; with our setup
encoder.endEncoding()
</code></pre>
<p>And this is how we run the process:</p>
<pre><code>commandBuffer.commit()
commandBuffer.waitUntilCompleted()

// Copy the GPU results to the output buffer passed from Python
if let outputPointer = outVectorBuffer?.contents().assumingMemoryBound(to: Float.self) {
    outputData.update(from: outputPointer, count: numItems)
} else {
    print(&quot;Error: Unable to get contents from output buffer.&quot;)
    return 1
}
</code></pre>
<p>(Note: I also included a Swift wrapper and some additional methods in the corresponding GitHub repository to allow for direct execution from the command line.)</p>
<p>Now we need to build our swift library (I am not going into the details about the Swift package configuration, check out the repo for an example):</p>
<pre><code>swift build
</code></pre>
<p>This will give us a couple of compiled files. The most important one is (usually) hidden in .build/debug: The dynamic library file libWrapper.dylib. Before we can pull it into your Python code, we have to sign it:</p>
<pre><code>// create a new private key
openssl genrsa -out developer.key 2048 
// create a signing certificate
openssl req -new -x509 -key developer.key -out developer.crt -days 365 -subj &quot;/CN=developer/O=NickyReinert/C=DE&quot;
// find the cert's ID
security find-identity -p codesigning
// sign the library
codesign -s &quot;YOUR_CERT_ID&quot; --deep --force .build/debug/libWrapper.dylib
</code></pre>
<p>In Python we load the library simply like that:</p>
<pre><code>swift_function = ctypes.CDLL(&quot;.build/debug/libWrapper.dylib&quot;)
</code></pre>
<p>Now we can already reference our benchmarkin function. As we are working with pointers to the output buffer, it’s a little more efforts to get the results:</p>
<pre><code>swift_function.benchmark.argtypes = [
    ctypes.POINTER(ctypes.c_float),
    ctypes.POINTER(ctypes.c_float),
    ctypes.c_int
]

# create some float values
numItems = 1_000_000_000
input_array = np.linspace(0, numItems - 1, 10, dtype=&quot;float32&quot;)  

# convert array to pointer
input_ptr = input_array.ctypes.data_as(ctypes.POINTER(ctypes.c_float))

# create output pointer
output_length = len(input_array)
output_mutable_ptr = (ctypes.c_float * output_length)()  # Create an output buffer

swift_function.benchmark(input_ptr, output_mutable_ptr, output_length)

output_array = np.ctypeslib.as_array(output_mutable_ptr)

combined_results = np.column_stack((input_array, output_array))

print(combined_results)

Finally we run the script as any other Python script:

python computationGPU.py
</code></pre>
<p>Our Metal implementation completed in just 0.06 seconds (be sure to run it several times to “warm up” your system) for 1,000,000,000 items! The pure Python implementation took about 7 seconds, while PyTorch finished in 4.7 seconds. We’ve improved the timing by a factor of 75!</p>
<p>Congratulations! You’ve just learned how to harness the full power of your GPU. Welcome to the bottom of my rabbit hole. Next stop: implement SECP256k1 and take part in the Bitcoin Puzzle Rally!</p>
<p>~</p>
<p>(Final Note: You can also use PyOpenCL to initialize the device and command queue from within Python, which may simplify and enhance the process. I preferred the Swift wrapper because it is easier to debug.)</p>
        
        
        <div class="tags">
          <p><strong>Tags:</strong> Bitcoin, Python, Performance, GPU, Metal, Cryptography</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>projekte</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/required_computation_steps.png" type="image/jpeg">
        <media:title>The Bitcoin Puzzle - Title Image</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>case_study</dc:type>
      
      
    </item>
  </channel>
</rss>