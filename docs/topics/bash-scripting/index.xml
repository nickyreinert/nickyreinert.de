<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Bash Scripting auf Nicky Reinert</title>
    <link>https://nickyreinert.de/topics/bash-scripting/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Thu, 08 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/topics/bash-scripting/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Automatisierte WordPress Installation</title>
      <link>https://nickyreinert.de/2020/2020-10-08-automatisierte-wordpress-installation/</link>
      <pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2020/2020-10-08-automatisierte-wordpress-installation/</guid>
      <description>Et voilá. Ein BASH Script, um WordPress automatisiert über die Kommandozeile zu installieren, inklusive Theme und beliebigen Plugins sowie - wenn benötigt - …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel stellt ein Bash-Skript zur vollautomatischen Installation und Konfiguration von WordPress vor. Das Skript nutzt &#39;wp-cli&#39; zur Einrichtung von Core, Datenbank, Themes und Plugins und kann die neue WordPress-Instanz mit zufällig generiertem Content (Beiträge, Kategorien, Bilder) über externe APIs befüllen, was es zu einem nützlichen Tool für Entwickler und Administratoren macht.</p>
          
          
          <p><strong>Hauptthemen:</strong> WordPress, Automatisierung, Bash Scripting, DevOps, wp-cli, Server Administration, Web Development, Content Generation</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Et voilá. Ein BASH Script, um WordPress automatisiert über die Kommandozeile zu installieren, inklusive Theme und beliebigen Plugins sowie - wenn benötigt - zufälligen Beiträgen, Kategorien, Tags und Bildern.</p>
<h2 id="warnung">Warnung!</h2>
<p>Du solltest geübt im Umgang mit der Shell, Bash und WordPress sein und unbedingt <strong>Backups</strong> nutzen. Das Script verwendet, wenn der entsprechende Parameter gesetzt ist, den Befehl &ldquo;rm -rf&rdquo;, um einen Ordner komplett zu <strong>löschen</strong>. Dieser Schritt lässt sich nicht widerrufen. Außerdem wird, sofern per Parameter gefordert, eine Datenbank mit &ldquo;DROP DATABASE&rdquo; komplett entfernt. Wenn du das Script auf eine existierende WordPress-Installation oder Datenbank anwendest, können existierende Daten <strong>überschrieben</strong> werden!</p>
<h2 id="funktionsweise">Funktionsweise</h2>
<p>Das Script wird über die Kommandozeile aufgerufen und nutzt die <a href="https://wp-cli.org/de/">WordPress Kommandozeilen-Benutzeroberfläche,</a> um <strong>WordPress</strong> zu installieren sowie samt <strong>Themes</strong> und <strong>Plugins</strong> einzurichten. Du kannst außerdem beliebig viele <strong>Beiträge</strong> anlegen. Die Inhalte für die Beiträge stammen von einem Online-Dienst für zufällige englische Texte: <a href="http://metaphorpsum.com/paragraphs/">metaphorpsum.com/paragraphs</a>. Außerdem werden zufällige <strong>Textauszüge</strong> (Excerpts) sowie <strong>Schlagwörter</strong> (Tags) und sogar <strong>Bilder</strong> jedem Beitrag hinzugefügt. Beiträge werden außerdem Kategorien zugeordnet. Diese werden ebenfalls <strong>zufällig</strong> bis zu einer Tiefe von 2 Ebenen erzeugt.</p>
<h2 id="installation">Installation</h2>
<p>Du findest den Sourcecode auf github: <a href="https://github.com/nickyreinert/AutomatedWordPressInstallation">https://github.com/nickyreinert/AutomatedWordPressInstallation</a>.</p>
<p>Nach der Installation kopierst du die Datei settings-template zu .settings, um in dieser Datei die Einstellungen für deine WordPress-Installation vorzunehmen. Du startest den Prozess mit <strong>bash start.sh</strong> oder setzt den Ausführen-Flag für bash.sh um diese direkt auszuführen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">chmod u+x bash.sh
</span></span><span class="line"><span class="ln">2</span><span class="cl">./bash.sh
</span></span></code></pre></div><h2 id="zufällige-inhalte">Zufällige Inhalte</h2>
<p>Das Script ermöglicht das Anlegen von beliebig vielen zufälligen Beiträgen in beliebig vielen zufälligen Kategorien. Was genau dabei passiert, beschreibe ich hier kurz:</p>
<p>Zunächst wird eine Kategorie erzeugt. Dazu wird von der folgenden API ein zufälliges Wort abgerufen: <a href="https://random-word-api.herokuapp.com/word?swear=0&amp;number=">https://random-word-api.herokuapp.com/word?swear=0&amp;number=</a></p>
<p>Dieser Kategorie wird dann ein Beitrag wird mit einer beliebigen Anzahl von <strong>Absätzen</strong> von dieser API zugeordnet: <a href="http://metaphorpsum.com/paragraphs/">http://metaphorpsum.com/paragraphs/</a>. Der Beitrag erhält einen zufälligen Titel (von dort: <a href="http://metaphorpsum.com/sentences/">http://metaphorpsum.com/sentences</a>), einen Textauszug (gleiche API), sowie eine beliebige Anzahl zufälliger Tags (Schlagwörter), ebenfalls von <a href="https://random-word-api.herokuapp.com/word?swear=0&amp;number=">random-word-api.herokuapp.com</a>. Dann werden für diesen Beitrag Revisionen erzeugt - auch diese in beliebiger Höhe. Abschließend erhält jeder Beitrag ein zufälliges Featured Image sowie ein weiteres zufälliges Bild am Ende des Fließtextes.</p>
<p>Je nachdem, wieviele Beiträge und Kategorien bzw. Sub-Kategorien eingerichtet werden soll, wird dieser Prozess natürlich wiederholt.</p>
<p><em>(Bisher werden die Inhalte leider nur auf Englisch eingefügt)</em></p>
<h2 id="einstellungen">Einstellungen</h2>
<p>Alle Einstellungen befinden sich in der Datei <strong>.settings</strong> und werden im Folgenden beschrieben. Der PROJECT-Parameter kann im weiteren Verlauf als Platzhalter verwendet werden und sollte keine Leerzeichen oder Sonderzeichen enthalten:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">PROJECT=myWordPressBlog
</span></span></code></pre></div><h3 id="datenbank">Datenbank</h3>
<p>Du kannst eine neue Datenbank anlegen (CREATE_DB) oder auf eine existierende Datenbank zurückgreifen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DB_DROP=yes|no
</span></span><span class="line"><span class="ln">2</span><span class="cl">CREATE_DB=yes|no
</span></span><span class="line"><span class="ln">3</span><span class="cl">DB_ROOT=root
</span></span><span class="line"><span class="ln">4</span><span class="cl">DB_ROOT_PASSWORD=secret
</span></span></code></pre></div><p>Willst du eine frische Datenbank anlegen, solltest du die alte Datenbank mit DB_DROP=yes löschen. Soll eine neue Datenbank angelegt werden, müssen die Zugangsdaten für einen privilegierten Nutzer angegeben werden: Mit den folgenden Parameter legst du fest, wie WordPress auf die Datenbank zugreift:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DB_HOST=127.0.0.1
</span></span><span class="line"><span class="ln">2</span><span class="cl">DB_NAME=&#34;${PROJECT}&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">DB_PREFIX=&#34;wp_&#34;
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">ADD_DB_USER=yes|no
</span></span><span class="line"><span class="ln">6</span><span class="cl">DB_USER=&#34;${PROJECT}&#34;
</span></span><span class="line"><span class="ln">7</span><span class="cl">DB_USER_PASSWORD=$(cat /dev/urandom | tr -dc &#39;a-zA-Z0-9&#39; | fold -w 32 | head -n 1)
</span></span></code></pre></div><p>Das Passwort wird im Beispiel zufällig erzeugt, willst du ein eigenes Passwort verwenden, kannst du den Parameter überschreiben, z.B:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">DB_USER_PASSWORT=secret
</span></span></code></pre></div><p>Der DB-Nutzer wird natürlich nur angelegt, wenn ADD_DB_USER=yes gesetzt ist. Andernfalls musst du hier die passenden Zugangsdaten angeben.</p>
<h3 id="wordpress">WordPress</h3>
<p>Du kannst auf eine existierende Installation zurückgreifen, um z.B. dort Beiträge hinzuzufügen, oder WordPress komplett neu installieren. Hier kannst du z.B. auch den oben festgelegten PROJECT-Parameter nutzen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">WP_PATH</span><span class="o">=</span><span class="s2">&#34;/var/nginx/htdocs/${PROJECT}/&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">INSTALL_CORE</span><span class="o">=</span><span class="n">yes</span><span class="o">|</span><span class="n">no</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">WP_DROP</span><span class="o">=</span><span class="n">yes</span><span class="o">|</span><span class="n">no</span>
</span></span></code></pre></div><p>Mit WP_DROP kannst du festlegen, dass der Ordner WP_PATH komplett gelöscht wird. <strong>Vorsicht</strong> ist hier also geboten! Die folgenden Parameter betreffen deine allgemeinen WordPress-Einstellungen. Bei der URL kannst du wieder den PROJECT-Platzhalter nutzen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">WP_TITLE=&#39;WordPress Test&#39;
</span></span><span class="line"><span class="ln">2</span><span class="cl">URL=&#34;https://blog.example.org/${PROJECT}&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">WP_ADMIN_NAME=admin
</span></span><span class="line"><span class="ln">4</span><span class="cl">WP_ADMIN_EMAIL=mail@example.org
</span></span><span class="line"><span class="ln">5</span><span class="cl">WP_ADMIN_PASSWORD=secret
</span></span></code></pre></div><p>Willst du ein eigene Passwort vergeben, kannst du auch hier ein zufälliges Passwort erzeugen lassen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">WP_ADMIN_PASSWORD=$(cat /dev/urandom | tr -dc &#39;a-zA-Z0-9&#39; | fold -w 32 | head -n 1)
</span></span></code></pre></div><h3 id="theme-und-plugins">Theme und Plugins</h3>
<p>Mit den folgenden Parametern legst du fest, welches Theme eingerichtet und welche Plugins installiert werden sollen. Der Theme-Name ist der Slug des Themes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">INSTALL_THEME=yes|no
</span></span><span class="line"><span class="ln">2</span><span class="cl">THEME=&#34;elementor&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">INSTALL_PLUGINS=no
</span></span><span class="line"><span class="ln">5</span><span class="cl">PLUGINS=&#34;elementor wordpress-seo tinymce-advanced ninja-forms shortcodes-ultimate instagram-feed ml-slider the-events-calendar amp contact-widgets coblocks woocommerce&#34;
</span></span></code></pre></div><p>Du kannst mehrere Plugins angeben, wenn diese per Leerzeichen voneinander getrennt sind.</p>
<h3 id="inhalte">Inhalte</h3>
<p>Der nächste Abschnitt regelt das (zufällige) Anlegen von Beiträgen, Kategorien usw. Natürlich musst du keine Inhalte anlegen. Ist <strong>RANDOMIZE_EVERY_ITEM</strong> auf <strong>yes</strong> gesetzt, wird jeder Beitrag wie oben zufällig erzeugt. Da das eine Menge HTTP-Requests erfordert, kannst du den Parameter auch auf no setzen. In dem Fall wird jede Zufalls-API genau einmal abgerufen. Der ganze Prozess wird dadurch maßgeblich beschleunigt.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ADD_CONTENT=yes|no
</span></span><span class="line"><span class="ln">2</span><span class="cl">META_INPUT=&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">RANDOMIZE_EVERY_ITEM=yes|no
</span></span></code></pre></div><p>Manche Themes, wie z.B. <strong>Elementor</strong>, fügen den Inhalten, also Beiträgen, bestimmte Meta-Informationen hinzu. Beim automatisierten Anlegen von Beiträgen passiert das allerdings nicht automatisch. Du kannst das hier also entsprechend einrichten. Der Wert wird als JSON übergeben. Achte auf das einfache Anführungszeichen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">META_INPUT=&#39;{&#34;_elementor_edit_mode&#34;:&#34;&lt;![CDATA[builder]]&gt;&#34;,&#34;_elementor_template_type&#34;:&#34;&lt;![CDATA[kit]]&gt;&#34;,&#34;_elementor_version&#34;:&#34;&lt;![CDATA[2.9.13]]&gt;&#34;}&#39;
</span></span></code></pre></div><p>Die folgenden Paremeter legen fest, wieviele Inhalte du erzeugen möchtest:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">COUNT_CATEGORIES_LEVEL1=10
</span></span><span class="line"><span class="ln">2</span><span class="cl">COUNT_CATEGORIES_LEVEL2=5
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">COUNT_POSTS=100
</span></span><span class="line"><span class="ln">5</span><span class="cl">COUNT_PARAGRAPHS=20
</span></span><span class="line"><span class="ln">6</span><span class="cl">COUNT_POST_REVISIONS=5
</span></span><span class="line"><span class="ln">7</span><span class="cl">COUNT_TAGS=20
</span></span></code></pre></div><p>Im Beispiel werden 10 Haupt-Kategorien mit jeweils 5 Unter-Kategorien angelegt. Jede Kategorie wird mit 100 Posts befüllt und jeder Post erhält 20 Tags und 5 Revisionen. Das ergibt also 10 * 5 * 100 * 5 Beiträge = 25.000 Beiträge! In diesem Fall macht es Sinn RANDOMIZE_EVERY_ITEM auf no zu setzen, da du sonst mehre tausende Anfragen an die Zufalls-APIs generieren würdest. COUNT_PARAGRAPHS legt die Länge jedes Beitrags in Absätzen fest.</p>
<h3 id="standard-parameter">Standard-Parameter</h3>
<p>Die folgenden Parameter musst du in der Regel nicht anpassen. WP_CLI legt den Pfad zur WordPress Kommandozeilen Oberfläche fest. Wird die Datei nicht gefunden, muss WP CLI installiert werden. Dazu dient der Parameter WP_CLI_SOURCE.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">WP_CLI_EXEC=~/wp-cli.phar
</span></span><span class="line"><span class="ln">2</span><span class="cl">WP_CLI_SOURCE=https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
</span></span></code></pre></div><p>Im folgenden werden die Quellen für die APIs festgelegt. Hier solltest du nichts ändern, da das Script für die Zusammenarbeit mit diesen Quellen eingerichtet ist. Einzig beim Parameter RANDOM_IMAGE_API_URI kannst du bei Bedarf in der URL die Auflösung der abgefragten Bilder festlegen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">RANDOM_WORD_API_URL=&#39;https://random-word-api.herokuapp.com/word?swear=0&amp;number=&#39;
</span></span><span class="line"><span class="ln">2</span><span class="cl">RANDOM_SENTENCE_API_URL=&#39;http://metaphorpsum.com/sentences/&#39;
</span></span><span class="line"><span class="ln">3</span><span class="cl">RANDOM_TEXT_API_URL=&#39;http://metaphorpsum.com/paragraphs/&#39;
</span></span><span class="line"><span class="ln">4</span><span class="cl">RANDOM_IMAGE_API_URI=&#39;https://picsum.photos/200/300.jpg&#39;
</span></span></code></pre></div>
        
        
        <div class="tags">
          <p><strong>Tags:</strong> automatisierung, bash, installation, script, setup, wordpress, DevOps</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>blog</category>
      
      <category>development</category>
      
      <category>tools</category>
      
      <category>wordpress</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Automatisierte WordPress Installation - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>project_documentation</dc:type>
      
      
    </item><item>
      <title>Den eigenen Web-Server sichern</title>
      <link>https://nickyreinert.de/2018/2018-08-23-den-eigenen-web-server-sichern/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-08-23-den-eigenen-web-server-sichern/</guid>
      <description>Die Datensicherung des eigenen, öffentlichen Webservers ist nicht nur wichtig, sie kann auch auf vielen Wegen geschehen und wirft vermutlich gerade deshalb sehr …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Diese umfassende Anleitung beschreibt die Implementierung einer automatisierten und sicheren Backup-Strategie für Webserver. Sie behandelt den Einsatz von &#39;duplicity&#39; und GnuPG für verschlüsselte, inkrementelle Backups von Webseiten-Dateien und MySQL-Datenbanken, inklusive Bash-Skripten zur automatischen Erkennung virtueller Hosts und zur Speicherung der Backups in der Cloud via WebDAV.</p>
          
          
          <p><strong>Hauptthemen:</strong> Server Administration, Backup Strategie, Datensicherung, Linux, Bash Scripting, Webserver Sicherheit, duplicity, GnuPG, MySQL</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Die <strong>Datensicherung</strong> des eigenen, öffentlichen Webservers ist nicht nur wichtig, sie kann auch auf vielen Wegen geschehen und wirft vermutlich gerade deshalb sehr viele Fragen auf. Soll ich ein Image des ganzen Servers anlegen oder nur einzelne Ordner sichern? <strong>Wie oft</strong> muss ich ein Backup machen und wie gelange ich im Notfall an die Daten? Reicht es aus, z.B. als Wordpress-Nutzer, ein Plugin zu verwenden oder ist es sinnvoller externe Software zu nutzen?</p>
<p>Ich habe versucht ein paar solcher Fragen, auch für mich selber, zu beantworten und als Konsequenz daraus ein <strong>Backup-Strategie</strong> zu entwickeln und dann auch umzusetzen. Das Ziel ist ein gesunder <strong>Mittelweg zwischen Sicherheit und Bedienbarkeit</strong>. Da ich selber sehr oft mit Wordpress arbeite, soll dieser Beitrag vornehmlich die Wordpress-Nutzer ansprechen. Wenn du Wordpress allerdings nur als Service nutzt (z.B. auf wordpress.org), wird dir dieser Beitrag wenig weiterhelfen. Außerdem ist es sehr hilfreich, wenn du per <strong>SSH Zugriff</strong> auf deinen Server hast. Sicherlich gibt es auch Möglichkeiten, den hier aufgezeigten Weg ohne SSH zu beschreiten - wie das funktioniert, muss man aber im Einzelnen sehen.</p>
<h2 id="die-backup-strategie">Die Backup-Strategie</h2>
<h3 id="wo-soll-das-backup-gespeichert-werden">Wo soll das Backup gespeichert werden?</h3>
<p>Die erste Frage die ich mir gestellt habe war: <strong>Wo soll das Backup landen</strong>? Direkt auf dem Web-Server? Dann sind die Daten verloren, sobald der ganze Server weg ist. Auf einem Cloud-Speicher? Das ist bequem, birgt allerdings auch Probleme mit den <strong>Datenschutzgesetzen</strong>. Oder auf einem privaten NAS? Das ist aus Datenschutzsicht zwar in Ordnung, aber dann muss das NAS über das Internet erreichbar sein. Das wollte ich vermeiden.</p>
<p>Ich habe mich deshalb für einen Zwischenweg entschieden: Für den schnellen Zugriff lege ich das Backup <strong>auf dem Server</strong> ab. Gleichzeitig nutze ich das kostenlose Angebot von <a href="https://www.blaucloud.de/"><strong>blaucloud.de</strong></a>. Das ist ein Cloud-Speicher, dessen Server in Deutschland stehen. Außerdem unterstützt blaucloud, das auf nextcloud basiert, das WebDav-Protokoll. Zusätzlich, aber das ist nur ein Bonus. Außerdem habe ich auf meinem NAS eine Synchronisierung mit der blaucloud eingerichtet. Dadurch bleibt das NAS im Internet verborgen und ich habe trotzdem eine <strong>3. Kopie des Backups</strong> in meinen eigenen, sicheren vier Wänden.</p>
<h3 id="welche-software-soll-ich-nutzen">Welche Software soll ich nutzen?</h3>
<p>Die Auswahl von Plugins für automatische Backups mit Wordpress ist sehr umfangreich, einige davon sind kostenlos und die große Mehrheit ist sehr bequem zu bedienen. Die Backups laufen automatisch und auch die Wiederherstellung ist nur einen Mausklick entfernt. Das klingt paradiesisch, aber der Schein trügt. Zunächst halte ich es für absurd, ein System aus sich selber heraus zu sichern. Das ist wie ein <strong>Feuerlöscher</strong>, der bei <strong>Waldbrandgefahr</strong> zwischen den trockenen Bäumen steht.</p>
<p>Sicher kann ich mit den zahlreichen Wordpress-Plugins die Datenbank und das Dateisystem sichern. Aber der Prozess wird eben innerhalb eines System ausgeführt, das auch von außen erreichbar ist. Wenn nur ein anderes Plugin kompromittiert wird, gefährdet das die ganze Backup-Strategie. Außerdem muss ich, bei der Verwendung mehrerer Wordpress-Instanzen jedes Backup-Plugin einzeln pflegen.</p>
<p>Auch die regelmäßige Datensicherung, die viele Hoster von sich aus anbieten, reicht mir nicht aus, da diese nur minimal gesteuert werden kann und dort immer das ganze System gesichert wird, man also bei der Wiederherstellung nicht selektieren kann, welche Backup, welcher Ordner oder welche Datenbank zurück gespielt werden soll. Ich habe mich also für <strong>duplicity</strong> entschieden. <a href="http://duplicity.nongnu.org/"><strong>Duplicity</strong></a> wird über die Kommandozeile bedient (deshalb der notwendige SSH-Zugang), unterstützt viele Protokolle (FTP, <strong>WebDav</strong>, Amazon S3, rsync, &hellip;) und es gibt sogar eine grafische Benutzeroberfläche - wenn man doch nicht ohne kann. Außerdem bietet duplicity die Verschlüsselung mit <strong>GnuPG</strong> an und ist damit auch bestens geeignet, um die Datensicherung in der Cloud abzulegen.</p>
<h3 id="wie-oft-soll-ich-ein-backup-anlegen">Wie oft soll ich ein Backup anlegen?</h3>
<p>Die Frage sollte mich nicht länger beschäftigen, vor allem weil ich dazu <a href="https://blog.yadutaf.fr/2012/09/08/lazy-man-backup-strategy-with-duplicity-part-1/">einen sehr schönen Blog-Eintrag gefunden</a> habe. Dazu muss erklärt werden, dass <strong>duplicity</strong> mit <strong>inkrementellen Backups</strong> arbeitet. Dabei wird initial ein komplettes Backup angelegt. Danach werden nur noch die Änderungen an den zu sichernden Dateien erfasst. Für die Wiederherstellung muss also erst das letzte volle Backup zurückgespielt werden, um darauf dann die inkrementellen Backups &ldquo;anzuwenden. Der Backup-Plan lautet also wie folgt:</p>
<ul>
<li>es erfolgt initial eine volle Datensicherung</li>
<li>danach gibt es jeden Tag eine inkrementelle Datensicherung</li>
<li>jeden Monat erfolgt eine volle Datensicherung</li>
<li>inkrementelle, tägliche Backups, die älter sind als ein Monat, werden gelöscht</li>
<li>volle Backups, die älter als 12 Monate sind, werden gelöscht</li>
</ul>
<p>Im Notfall muss also zuerst das letzte volle Backup eingespielt werden, das nicht älter als ein Monat ist. Muss man Daten wiederherstellen, die älter sind als ein Monat, stehen diese immer nur für die monatlichen vollen Backups zur Verfügung. Für die Zeit vor 12 Monaten gibt es keine Datensicherung.</p>
<h3 id="welche-daten-sollen-gesichert-werden">Welche Daten sollen gesichert werden?</h3>
<p>Wie bereits erwähnt, stört mich bei den meisten Hostern, dass immer ein Backup des ganzen Servers angelegt wird. Da auf einem Server gerne aber mehr als eine Domain untergebracht ist, möchte ich die Datensicherung gerne je Domain und Datenbank durchführen. Mein Ziel ist es also, jeden Ordner im Dateisystem der einer (Sub-)Domain zugeordnet ist sowie jede Datenbank getrennt zu sichern. So kann ich eine Wiederherstellung auch punktuell anstoßen.</p>
<h2 id="vorbereitung">Vorbereitung</h2>
<p><em>Bevor es jetzt ans Eingemachte geht, der übliche Hinweis zur gebotenen <strong>Vorsicht</strong>: Wenn du nicht weißt, was hier passiert, lass dich von jemanden unterstützen, der weiß, was hier passiert. Wer auf der Konsole arbeitet, kann sehr schnell sehr viel falsch machen.</em></p>
<h3 id="duplicity-und-verschlüsselung-einrichten">Duplicity und Verschlüsselung einrichten</h3>
<p>Die erste Hürde, die du nehmen musst, ist die Installation von <strong>duplicity</strong>. Entweder du bekommst das über die Konsole selber hin - oder du fragst bei deinem Hoster nach. In vielen Fällen kann auch ein Shared Hostern das für dich installieren:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">sudo apt-get install duplicity
</span></span></code></pre></div><p>Als nächstes benötigst du <a href="https://www.gnupg.org/">GnuPG</a>. Das ist bei den meisten Hostern vorinstalliert. Sollte dem nicht so sein, fragst du entweder den Support oder erledigst das mit folgendem Befehl selber:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">sudo apt-get install gnupg2
</span></span></code></pre></div><p><a href="https://wiki.ubuntuusers.de/GnuPG/">GnuPG</a> ist ein Software zur <strong>Verschlüsselung</strong> von Informationen bzw. Dateien, das z.B. auch bei der Verschlüsselung von E-Mails zum Einsatz kommt. Für diesen Prozess werden zwei sogenannte <strong>Schlüssel</strong> benötigt - der private und der öffentliche Schlüssel. Der öffentliche Schlüssel dient dazu, die Daten zu verschlüsseln, mit dem privaten Schlüssel kannst du den Prozess &ldquo;umkehren&rdquo; - die Daten also entschlüsseln. Diese beiden Schlüssel müssen zunächst einmal erzeugt werden:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">gpg --gen-key
</span></span></code></pre></div><p>Du musst dazu ein paar Fragen beantworten. Die Frage nach der Schlüssel-Art beantwortest du mit 1, bzw. <em>RSA and RSA</em>. Als Schlüssellänge (<em>keysize</em>) empfiehlt sich 2.048 bits. Die Gültigkeitsdauer beträgt &ldquo;unendlich&rdquo;. Danach kannst, musst aber nicht, du deinen Namen und Kontaktdaten angeben. Abschließend wirst du nach einem Passwort für den privaten Schlüssel gefragt und aufgefordert durch ein paar zufällige Tasteneingaben eine Entropie zu erzeugen. Danach befindet sich im Ordner <strong><em>~/.gnupg</em></strong> dein Schlüsselpaar.</p>
<p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/gnupg.png" alt="Ein GnuPG Schlüsselpaar erzeugen"></p>
<p>Außerdem quittiert dir <strong>gnupg</strong> die Erstellung des Schlüsselpaars mit einer Statistik, aus der du dir die <strong>Id für den öffentlichen Schlüssel</strong> merken musst:</p>
<p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/gnupg-ausgabe.png" alt=""></p>
<h3 id="cloud-speicher-einrichten">Cloud-Speicher einrichten</h3>
<p>Der kostenlose <a href="https://www.blaucloud.de/">blaucloud</a>-Account für 5 GByte-Speicher ist ziemlich schnell eingerichtet. Dazu benötigst du nur einen beliebigen Benutzernamen, eine E-Mail-Adresse und ein Passwort. Über den Benutzerbnamen wird später auch deine Cloud erreichbar sein. Ich habe eine zufällige Zeichenkette verwendet, damit die Verbindung zur Funktion als Backup-Speicher nicht auf den ersten Blick ersichtlich ist (z.B. <em>qwertz123.blaucloud.de</em>). Danach musst du nur noch deine E-Mail-Adresse bestätigen und schon ist der Cloud-Speicher über folgende URL verfügbar:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">webdav://benutzername:passwor@benutzername.blaucloud.de/remote.php/webdav/
</span></span></code></pre></div><h3 id="mysql-benutzer-einrichten">MySQL-Benutzer einrichten</h3>
<p>Natürlich kannst du für das Backup einfach den Benutzer nutzen, den du auch für administrative Zwecke nutzt. Ich verrate dir aber kein Geheimnis wenn ich dir sage, dass es sehr sinnvoll ist, dafür einen eigenen Benutzer anzulegen, insofern deine Hosting-Umgebung das zulässt. Dazu führst du auf einer beliebigen Oberfläche (phpMyAdmin, MySQL Workbench oder direkt über das MySQL-CLI) folgende Query aus. Hier setzt du nur einen Benutzernamen und ein Passwort ein.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">GRANT LOCK TABLES, SELECT ON *.* TO &#39;USERNAME&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD&#39;;
</span></span><span class="line"><span class="ln">2</span><span class="cl">GRANT SHOW VIEW ON *.* TO &#39;USERNAME&#39;@&#39;localhost&#39;
</span></span></code></pre></div><p>Das ging schnell und hat auch gar nicht weh getan. ;)</p>
<h2 id="die-backup-strategie-umsetzen">Die Backup-Strategie umsetzen</h2>
<h3 id="die-zugangsdaten-ablegen">Die Zugangsdaten ablegen</h3>
<p>Die Informationen, die wir oben gesammelt haben, werden erstmal in der Datei <strong>backup.conf</strong> abgelegt. Bitte beachte, dass die Id für den öffentlichen Schlüssel nur ein Verweis ist. Die tatsächlichen Schlüssel liegen im Benutzerordner unter <em>~/.gnugpg/</em> .</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1"># mit diesem Wert steuerst du die Ausgabe von duplicity</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"># je höher, desto mehr Debug-Nachrichten werden ausgegeben</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"># das hilft bei der Fehlersuche</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">export</span> <span class="n">DUPLICITY_VERBOSITY</span><span class="o">=</span><span class="mi">2</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"># die Passphrase ist das Passwort für den privaten Schlüssel</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># die Id für den öffentlichen Schlüssel wird utner GPG_PUP_KEY abgelegt</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">export</span> <span class="n">PASSPHRASE</span><span class="o">=</span><span class="n">secret_gpgp_key_password</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">export</span> <span class="n">GPG_PUB_KEY</span><span class="o">=</span><span class="n">public_gpgp_key_id</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"># dieser Ordner wird für die lokalen Backups verwendet</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">export</span> <span class="n">BASE_PATH_BACKUP</span><span class="o">=/</span><span class="n">private</span><span class="o">-</span><span class="n">backup</span><span class="o">/</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"># dieser Ordner enthält die temporären MySQL-Dumps sowie den Cache von duplicity</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">export</span> <span class="n">BASE_PATH_TEMP</span><span class="o">=/</span><span class="n">private</span><span class="o">-</span><span class="n">backup</span><span class="o">/</span><span class="n">temp</span><span class="o">/</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">export</span> <span class="n">LOG_FILE</span><span class="o">=</span><span class="n">backup</span><span class="o">.</span><span class="n">log</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"># das sind die Zugangsdaten zu deinem WebDav-Anbieter</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_USER</span><span class="o">=</span><span class="n">webdav_user</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_PASSWORD</span><span class="o">=</span><span class="n">webdav_password</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_URL</span><span class="o">=</span><span class="n">somewhere</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">de</span><span class="o">/</span><span class="n">webdav</span><span class="o">.</span><span class="n">php</span><span class="o">/</span><span class="n">folder</span><span class="o">/</span><span class="n">backup</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"># schließlich hinterlegst du noch eine E-Mail-Adresse </span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"># an die Fehlernachrichten geschickt werden </span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="k">export</span> <span class="n">SUPERVISOR_EMAIL</span><span class="o">=</span><span class="n">error_messages</span><span class="err">@</span><span class="n">foobar</span><span class="o">.</span><span class="n">com</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"># und die E-Mail-Adresse des Absenders</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="k">export</span> <span class="n">LOCAL_EMAIL</span><span class="o">=</span><span class="n">sender</span><span class="err">@</span><span class="n">foobar</span><span class="o">.</span><span class="n">com</span>
</span></span></code></pre></div><p>Die Zugangsdaten für den MySQL-Server gehören in eine andere Datei, nämlich <strong>database.conf</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">[client]
</span></span><span class="line"><span class="ln">2</span><span class="cl">user=mysql_user
</span></span><span class="line"><span class="ln">3</span><span class="cl">password=mysql_password
</span></span><span class="line"><span class="ln">4</span><span class="cl">host=localhost
</span></span></code></pre></div><h3 id="die-ordner-der-virtuellen-hosts-sichern">Die Ordner der virtuellen Hosts sichern</h3>
<p>Im Folgenden werde ich die Shell-Scripte und den Prozess ganz kurz erklären.</p>
<p>Zunächst will ich zwei Server-System unterstützen: nginx und apache2. Dazu frage ich den ersten Parameter ab:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">if [[ $1 == &#39;apache&#39;  ]]
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        SERVER_SOFTWARE=&#39;apache&#39;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">elif [[ $1 == &#39;nginx&#39;  ]]
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        SERVER_SOFTWARE=&#39;nginx&#39;
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">else
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        echo &#39;Keine Server-Architektur angegeben, probiere mal nginx oder apache&#39;
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">fi
</span></span></code></pre></div><p>Wie oben schon angedeutet, will ich nicht einmal das ganze Dateisystem sichern, sondern nur <strong>relevante Ordner</strong>. Dazu muss ich erwähnen, dass ich für jede Domain eine Konfigurations-Datei angelegt habe - so ist es im übrigen auch üblich (siehe z.B. <em>/etc/apache2/sites-enabled/</em>). Jede dieser Dateien enthält den Verweis auf den Ordner der jeweiligen Domain (oft z.B. <em>/var/www/&hellip;</em>) Diese Informationen gilt es nun automatisch herauszufinden. Ich nutze dafür zunächst den folgenden Aufruf, der mir erstmal eine <strong>ungefilterte  Liste der gesamten Webserver-Konfiguration</strong> ausgibt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">/usr/sbin/apache2ctl -S
</span></span></code></pre></div><p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/apachectl-ausgabe.png" alt="apachectl-ausgabe.png"></p>
<p>Die Ausgabe ist stark gekürzt und enthält natürlich mehr als nur eine Domain und diese auch immer doppelt - einmal für https und einmal für http. Ich benötige aus dieser Liste nun einmal den Pfad zur Konfigurations-Datei jeder Domain. Dazu reduziere ich die Ausgabe also auf die gewünschten Zeilen und extrahiere dann mit <em>awk</em> und <em>sed</em> den Verweis zu der jeweiligen Konfigurations-Datei. Das ist der komplette Aufruf:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">/usr/sbin/apache2ctl -S | grep &#34;port 80 namevhost&#34; | awk -F &#39; &#39; &#39;{ print $5 }&#39; | sed -E &#39;s/[:()]//g&#39; | sed -E &#39;s/[ 0-9]$//g&#39;
</span></span></code></pre></div><p>Das Ergebnis ist eine Liste von Konfigurationsdateien, die ich mit <em>grep</em> nach der Angabe des Ordners durchsuchen kann:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">grep -oE &#39;DocumentRoot &#34;(.*)&#34;&#39; $configFile | awk -F &#39; &#39; &#39;{ print $2 }&#39; | sed -E &#39;s/[&#34;]//g&#39;
</span></span></code></pre></div><p>Diesen Ordner kann ich dann an das Backup-Script übergeben, auf das ich später zurück kommen werden. Das ganze Script ist auf github verfügbar.</p>
<p>Ich muss hier allerdings erwähnen, dass das ganze eine <strong>kleinen Nachteil</strong> hat: Es werden nur aktivierte virtuelle Hosts erkannt. Wer zusätzliche andere Ordner sichern will, die z.B. nicht über die virtual host-Konfiguration genutzt werden, muss dies per Hand tun - doch dazu später mehr.</p>
<p>Für nginx nutze ich eine etwas einfachere Variante: Ich nehme einfach alle Dateien mit der Endung conf aus dem Konfigurations-Ordner von nginx. Das funktioniert eben nur, solange du die Konfiguration zentral an einem Ort verwaltest. Der ganze Abschnitt sieht dann so aus:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">if [[ $SERVER_SOFTWARE == &#39;apache&#39; ]]
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        configFilesString=$(/usr/sbin/apache2ctl -S | grep &#34;port 80 namevhost&#34; | awk -F &#39; &#39; &#39;{ print $5 }&#39; | sed -E &#39;s/[:()]//g&#39; | sed -E &#39;s/[ 0-9]$//g&#39;)
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        configFiles=($(echo &#34;$configFilesString&#34; | tr &#39; ,&#39; &#39; &#39; ))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">elif [[ $SERVER_SOFTWARE == &#39;nginx&#39; ]]
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        configFiles=(/etc/nginx/conf.d/*.conf)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">fi
</span></span></code></pre></div><p><strong>Update November 2018:</strong></p>
<p><em>Da ich mittlerweile auf nginx und php-fpm umgestiegen bin, habe ich auch das Script entsprechend angepasst. Es kann nun für beide Server-Typen angewendet werden.</em></p>
<p>Nun kann ich jede Config-Datei einmal einlesen um herauszubekommen, an welcher Stelle im Dateisystem sich der Ordner mit dem Document Root befindet - den wollen wir ja schließlich sichern:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">if [[ $SERVER_SOFTWARE == &#39;apache&#39; ]]
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	srcFolder=$(grep -oE &#39;DocumentRoot \&#34;(.*)\&#34;&#39; $configFile | awk -F &#39; &#39; &#39;{ print $2 }&#39; | sed -E &#39;s/[\&#34;]//g&#39;)
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	dstFolder=$(basename $srcFolder)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">elif [[ $SERVER_SOFTWARE == &#39;nginx&#39; ]]
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">	srcFolder=$(grep -oE &#39;root (.*);&#39; $configFile | awk -F &#39; &#39; &#39;{ print $2 }&#39; | sed -E &#39;s/[;]//g&#39;)
</span></span><span class="line"><span class="ln">11</span><span class="cl">	dstFolder=$(basename ${srcFolder%htdocs})
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">fi
</span></span></code></pre></div><h3 id="die-datenbanken-des-mysql-servers-sichern">Die Datenbanken des MySQL-Servers sichern</h3>
<p>Nun geht es an die Datenbanken. Dazu nutze ich den CLI-MySQL-Client und frage erstmal einfach alle Datenbanken ab:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mysql --defaults-extra-file=database.conf -Bse &#39;show databases&#39;
</span></span></code></pre></div><p>Die Zugangsdaten zum Server übergebe ich in der Datei <strong>database.conf</strong>. Ich könnte das auch über die Kommandozeile tun, würde dann aber eine Warnung von MySQL erhalten, dass das nicht sicher sei:</p>
<blockquote>
<p><em>Warning: Using a password on the command line interface can be insecure.</em></p></blockquote>
<p>Da die Ausgabe von mysql nur einen String zurückgibt, muss ich den erst in ein Array umwandeln, dass ich dann durch-loopen kann. Dazu gibt es zwei Wege - den unteren finde ich etwas eleganter. Entscheide dich einfach für einen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">databasesArray=($(echo &#34;$databasesString&#34; | tr &#39; ,&#39; &#39; &#39; ))
</span></span><span class="line"><span class="ln">2</span><span class="cl">IFS=&#39;_&#39; read -r -a databasesArray&lt;&lt;&lt; &#34;$databasesString&#34;
</span></span></code></pre></div><p>Nun hast du also ein Array, dass deine Datenbanken enthält. Als nächstes brauchst du eine Schleife um für jede Datenbank ein Dump anzulegen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">ignoreDatabases=[&#39;information_schema,sys,performance_schema&#39;]
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">for database in &#34;${databasesArray[@]}&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        if [[ ! &#34; ${ignoreDatabases[*]} &#34; == *&#34;${database}&#34;* ]]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        then
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            ...
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        fi
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">done
</span></span></code></pre></div><p>Wie du siehst, habe ich noch eine Abfrage eingebaut, damit nicht benötigte System-Datenbanken ausgelassen werden. Jetzt kümmern wir uns um den eigentlichen Dump. Die folgenden Zeilen kommen an die Stelle mit den drei Punkten&hellip;</p>
<p>Jetzt werden die Daten aus der jeweiligen Datenbank gezogen. Wenn <strong>mysqldump</strong> einen Fehler zurück gibt, schicke ich mir diesen per E-Mail. Danach wird das Script aufgerufen, dass den Dump mit duplicity an einen &ldquo;sicheren&rdquo; Ort kopiert. Zum Abschluss wird der Dump wieder entfernt.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">result=&#34;$( ( mysqldump --defaults-extra-file=database.conf ${database} &gt; ${BASE_PATH_TEMP}${database}.sql ) 2&gt;&amp;1 )&#34;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">len=${#result}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">if [ &#34;$len&#34; -gt &#34;0&#34; ]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	echo $result | mail -s &#34;Error when dumping mysql database ${database}&#34; $SUPERVISOR_EMAIL -r $LOCAL_EMAIL
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">fi
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">./backupFilesystem.sh -f ${BASE_PATH_TEMP}${database}.sql -d &#34;${BASE_PATH_BACKUP}databases/${database}&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">rm ${BASE_PATH_TEMP}${database}.sql
</span></span></code></pre></div><p>Eine Sache gibt es zu beachten, die ich hier nicht weiter beschreiben: Ich nutze &ldquo;<strong>mail</strong>&rdquo; um die Fehlernachrichten zu versenden. Ihr könnte hier einen eigenen E-Mail-Client oder eine andere Variante der Fehlerbenachrichtigung nutzen, das bleibt euch überlassen.</p>
<h3 id="die-daten-mit-duplicity-verschlüsselt-sichern">Die Daten mit duplicity verschlüsselt sichern</h3>
<p>Nun geht es ans Eingemachte bzw. die tatsächliche Datensicherung. Das Script <strong>backupFilesystem.sh</strong> erwartet zwei Parameter: Die Dateien bzw. der Ordner, der gesichert werden soll und der Name des Zielordners.</p>
<p>Danach wird duplicity mehr als ein mal aufgerufen. Zunächst wird, wenn das letzte Vollbackup älter ist als 1 Monat, ein komplettes Backup angelegt. Danach wird duplicity angewiesen, Backups, die älter sind als 12 Monate, zu entfernen. Dann werden außerdem die inkrementellen Backups entfernt, die älter sind als 1 Monat. Das ganze wird einmal aufgerufen um die Backups lokal abzulegen und dann ein 2. Mal für den WebDav-Speicher.</p>
<p>Wer Ordner und Dateien <strong>manuell sichern</strong> will, kann also dieses Script mit den entsprechenden Parametern aufrufen.</p>
<h3 id="automatisieren-mit-cron">Automatisieren mit cron</h3>
<p>Jetzt muss der ganze Spaß natürlich noch automatisch laufen. Dazu werden die folgende Zeilen in die Datei <em>/etc/cron.d/dailyBackup</em> gepackt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># m h dom mon dow user  command
</span></span><span class="line"><span class="ln">2</span><span class="cl">0 1 * * * root /bin/bash /backup/backupVirtualhosts.sh
</span></span><span class="line"><span class="ln">3</span><span class="cl">0 2 * * * root /bin/bash /backup/backupDatabase.sh
</span></span></code></pre></div><p>Willst du zusätzliche Ordner sichern, kannst du das über das Script <em>backupFilesystem.sh</em> tun, z.B:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0 1 * * * root /bin/bash /backup/backupFilesystem.sh -f /home/ -d /private-backup/home/
</span></span></code></pre></div><h3 id="github">Github</h3>
<p>Die gesammelten Scripte und Vorlagen für die Konfigurationsdateien findest du auf <a href="https://github.com/nickyreinert/completeWebServerBackup">github.com</a>. Du kopierst einfach den Inhalt des Ordners <em>scripts</em> an einen Ort auf deinen Server, wie z.B. <em>/backup.</em></p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> backup, bash, hosting, shell, web-server, Server Sicherheit</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Den eigenen Web-Server sichern - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item>
  </channel>
</rss>