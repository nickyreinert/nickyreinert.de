<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>PHP-FPM auf Nicky Reinert</title>
    <link>https://nickyreinert.de/topics/php-fpm/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Wed, 02 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/topics/php-fpm/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Mehrere virtuelle Server mit nginx und PHP-FPM für Wordpress (Teil 3 / 3)</title>
      <link>https://nickyreinert.de/2019/2019-10-02-mehrere-virtuelle-server-mit-nginx-und-php-fpm-fuer-wordpress-teil-3-3/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2019/2019-10-02-mehrere-virtuelle-server-mit-nginx-und-php-fpm-fuer-wordpress-teil-3-3/</guid>
      <description>Im letzten Teil geht es um die Einrichtung von PHP-FPM und ich gebe eine kleine Zusammenfassung bzw. Überblick über die Struktur des gesamten Setups. Wenn alles …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser dritte Teil der Serie zur Einrichtung einer sicheren und performanten Webserver-Umgebung für WordPress konzentriert sich auf die Konfiguration von PHP-FPM-Pools. Er behandelt detailliert Sicherheitsaspekte wie Benutzerisolation und Chroot-Umgebungen, Performance-Optimierungen für PHP-Prozesse sowie die Verwaltung von Sessions und das Deaktivieren gefährlicher PHP-Funktionen, um ein robustes Multi-Site-Setup zu gewährleisten.</p>
          
          
          <p><strong>Hauptthemen:</strong> Nginx, PHP-FPM, WordPress, Server Konfiguration, Webserver Sicherheit, Chroot, Performance Optimierung, PHP, Linux</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Im letzten Teil geht es um die Einrichtung von PHP-FPM und ich gebe eine kleine Zusammenfassung bzw. Überblick über die Struktur des gesamten Setups. Wenn alles korrekt eingerichtet ist, solltet ihr nun einen gut funktionierenden Webserver auf Basis von nginx haben, der PHP-FPM nutzt und gut mit Wordpress laufen sollte. Der Server arbeitet für mehrere unterschiedliche Domains, die so gut wie möglich im System getrennt sind.</p>
<h2 id="die-einrichtung-der-php-pools">Die Einrichtung der PHP-Pools</h2>
<p>Um den ganzen Bums zum Laufen zu bringen fehlt jetzt nur noch PHP. Den Großteil haben wir schon geschafft, weshalb ich die Einrichtung von PHP nicht in einen neuen Beitrag gepackt habe.</p>
<p>Wie im ersten Teil schon angedeutet, nutze ich PHP-FPM. Die Einstellungen jedes einzelen virtuellen Servers befinden sich demnach in <strong>/etc/php/7.3/fpm/pool.d/</strong> und hat die Endung .conf.</p>
<p>Mit dem Parameter <strong>listen</strong> stellst du die Verbindung zu nginx her. Es wird ein Socket erstellt, über den nginx und PHP-FPM Informationen austauschen. Die Variable <strong>$pool</strong> enthält den Namen des Pools. Mit <strong>prefix</strong> legst du Standard-Ordner dieses Pools fest.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1"># der Namen des Pools (kann mit $pool referenziert werden</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">[</span><span class="n">example_com</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">listen</span> <span class="o">=</span> <span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">php</span><span class="o">/</span><span class="n">php</span><span class="o">-</span><span class="n">fpm</span><span class="o">-$</span><span class="n">pool</span><span class="o">.</span><span class="n">sock</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="n">prefix</span> <span class="o">=</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">nginx</span><span class="o">/$</span><span class="n">pool</span>
</span></span></code></pre></div><p>Jetzt gibt ein paar wichtige Sicherheitsfeatures: Jeder <strong>Pool</strong> hat seinen eigenen Benutzer. Hierzu muss man nicht viel erklären: Der Vorteil hier ist, dass sich die PHP-Prozesse verschiedener Server, da sie ja unterschiedlichen Nutzer &ldquo;gehören&rdquo; grundsätzlich erstmal nicht in die Quere kommen können:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">user = $pool-php
</span></span><span class="line"><span class="ln">2</span><span class="cl">group = www-data
</span></span><span class="line"><span class="ln">3</span><span class="cl">listen.owner = $pool-php
</span></span><span class="line"><span class="ln">4</span><span class="cl">listen.group = www-data
</span></span></code></pre></div><p>Mit chdir und chroot schließt du diesen Pool in einen bestimmten Ordner ein. Ich hatte oben ja bereits <strong>$prefix</strong> definiert. Diese Parameter arbeiten eng mit den FastCGI-Einstellungen von <strong>nginx</strong> zusammen und sind eine beliebte Fehlerquelle. Mit chroot denkt PHP, dass dieser Ordner der Root-Ordner ist. Warum ist das wichtig? Unsere Root-Ordner liegen (siehe Teil 1) alle in einem eigenen Unterordner. So kann PHP nicht ausbrechen und z.B. auf <strong>sensible Systembereiche</strong> oder die Unterordner anderer Pools / Server zugreifen. Der Parameter <strong>chdir</strong> legt lediglich fest, dass root auch wirklich root ist. Hier könnte man htdocs als Root festlegen. Da wir in der nginx-Einstellung aber <strong>htdocs</strong> als Pfad voranstellen, kann das hier so bleiben. Bedenke, dass sich alle folgenden Pfadangaben immer relativ zu den hier festgelegten Einstellungen stattfinden.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">chdir</span> <span class="o">=</span> <span class="o">/</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">chroot</span> <span class="o">=</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">nginx</span><span class="o">/</span><span class="n">example1</span>
</span></span></code></pre></div><p>Weiter geht es mit der Konfiguration der PHP-Prozesse. Mit <strong>pm=dynamic</strong> legen wir fest, dass der Prozess-Manager prozesse dynamisch starten kann. Mit <strong>pm=static</strong> startest du immer eine feste Anzahl von Prozessen. (Bei Servern mit hoher Last kann das durchaus Sinn machen, <a href="https://haydenjames.io/php-fpm-tuning-using-pm-static-max-performance/">wie hier beschrieben wird</a>). Bei einer kleineren Seite reicht <strong>pm=ondemand</strong> völlig aus. Wir erinnern uns: Die Prozesse dienen als Interpretor für unsere PHP-Scripte. Ein Prozess bearbeitet eine Anfrage. Wenn du mehr Traffic erwartest, solltest du diese Werte also erhöhen.</p>
<p><strong>max_children</strong> gibt die Obergrenze dafür fest. <strong>start_servers=1</strong> besagt, dass mindestens 1 Prozess sofort gestartet wird. Mit <strong>min_spare_servers</strong> legst du fest, wieviele Prozesse mindestens &ldquo;vorrätig&rdquo; sind, <strong>max_spare_servers</strong> legt dafür die Obergrenze fest. Wie viele Prozesse du maximale starten solltest, errechnest du ganz einfach folgender maßen:</p>
<p>Rufe den folgenden Code auf um den Speicherverbrauch deines PHP-Services zu erhalten:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ps --no-headers -o &#34;rss,cmd&#34; -C php-fpm7.3 | awk &#39;{ sum+=$1 } END { printf (&#34;%d%s\n&#34;, sum/NR/1024,&#34;Mb&#34;) }&#39;
</span></span></code></pre></div><p>Den freien Speicher lässt du folgendermaßen anzeigen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">free -h
</span></span></code></pre></div><p>Angenommen, du hast 4.096 MByte freien Speicher zur Verfügung und ein PHP-Prozess verbraucht 4 MByte, dann kannst du insgesamt 1.024 Prozesse starten. Wenn du mehrere virtuelle Server betreibst, teilen diese sich natürlich dieses Kontingent. Im folgenden ein Beispiel: Es werden maximal 1.024 Prozesse gestartet. 100 Prozesse sind immer aktiv, auch wenn sie ungenutzt sind. Sind alle 100 Prozesse beschäftigt, werden mindestens 50 Prozesse gestartet, aber niemals mehr als 200 - das Spiel funktioniert so lange, bis das Kontingent von 1.024 ausgeschöpft ist.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">pm = dynamic
</span></span><span class="line"><span class="ln">2</span><span class="cl">pm.max_children = 1024
</span></span><span class="line"><span class="ln">3</span><span class="cl">pm.start_servers = 100
</span></span><span class="line"><span class="ln">4</span><span class="cl">pm.min_spare_servers = 50
</span></span><span class="line"><span class="ln">5</span><span class="cl">pm.max_spare_servers = 200
</span></span></code></pre></div><p>Wenn dein Server relativ klein ist, solltest du den <strong>On-Demand-Modus</strong> nutzen. Hier wird ein Prozess nur dann gestartet, wenn der Bedarf da ist. Das spart Speicher und ist in der Regel auch nicht merkbar langsamer.</p>
<p>Der Parameter <strong>catch_workers_output</strong> steuert die Ausgabe des PHP-Prozesses. Wie alle Log-Einstellungen, kann <a href="https://twitter.com/leofeyer/status/486862436948250624">dieser erhebliche Auswirkungen auf die Performance haben</a>. Falls du also noch ein paar Millisekunden mehr herausholen willst, setze diesen Wert auf <strong>no</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">catch_workers_output = yes
</span></span></code></pre></div><p>Die folgenden Einstellungen werden eigentlich in der php.ini vorgenommen. Ich will sie hier aber auf Server-Ebene definieren, da die virtuellen Server ja durchaus unterschiedliche Ansprüche haben.</p>
<h3 id="sessions-cookies-und-referrer">Sessions, Cookies und Referrer</h3>
<p>Wenn du eine zusätzliche Sicherheitshürde einbauen willst, kannst du den Pfad der <strong>PHP-Sessions</strong> hier ändern. Wenn du in deiner Web-Anwendung nicht mit <strong>JavaScript</strong> auf <strong>Cookies</strong> zugreifen willst, kannst du den Cookie-Zugriff außerdem nur auf HTTP einschränken. Und schließlich macht es Sinn, dass eine Session nur vom eigenen Server genutzt werden kann, wenn also dein Server im Referrer übermittelt wird.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">php_value[session.save_path] = /sessions
</span></span><span class="line"><span class="ln">2</span><span class="cl">php_value[session.cookie_httponly] = 1
</span></span><span class="line"><span class="ln">3</span><span class="cl">php_value[session.referer_check] = example.com
</span></span></code></pre></div><p>Sehr nützlich und ein wichtiges Sicherheitsfeature ist <strong>disable_functions</strong>. Es gibt eine nicht geringe Anzahl von PHP-Funktionen, mit denen sich Systemfunktionen steuern lassen. Diese solltest du grundsätzlich nicht zulassen. Ein weiteres Sicherheitsfeature sind <strong>allow_url_fopen</strong> und <strong>allow_url_include</strong>. Damit unterbindest du das Einbinden von schadhaften Code.<br>
Die Einstellungen zum Log werde ich nicht weiter erläuter, da sie wie so oft selbsterklärend sind. Beachte, dass das Logging immer auch gewisse Auswirkungen auf die Performance haben. Andererseits kann die regelmäßige Log-Analyse aber auch rechzeitig wichtige Hinweise auf (Sicherheits-)Probleme deines Systems liefern!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">php_admin_value</span><span class="p">[</span><span class="n">disable_functions</span><span class="p">]</span> <span class="o">=</span> <span class="n">php_uname</span><span class="p">,</span> <span class="n">getmyuid</span><span class="p">,</span> <span class="n">getmypid</span><span class="p">,</span> <span class="n">passthru</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="n">listen</span><span class="p">,</span> <span class="n">diskfreespace</span><span class="p">,</span> <span class="n">tmpfile</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ignore_user_abord</span><span class="p">,</span> <span class="n">shell_exec</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">set_time_limit</span><span class="p">,</span> <span class="n">exec</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">high</span><span class="o">$</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="n">php_admin_flag</span><span class="p">[</span><span class="n">allow_url_fopen</span><span class="p">]</span> <span class="o">=</span> <span class="n">on</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">php_admin_flag</span><span class="p">[</span><span class="n">allow_url_include</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"># das Speicherlimit pro Script-Aufrufeinstellen</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">php_admin_value</span><span class="p">[</span><span class="n">memory_limit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">256</span><span class="n">M</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"># Logging-Einstellung</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">php_flag</span><span class="p">[</span><span class="n">display_errors</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">php_admin_value</span><span class="p">[</span><span class="n">error_log</span><span class="p">]</span> <span class="o">=</span> <span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="nb">log</span><span class="o">/</span><span class="n">php</span><span class="o">-</span><span class="n">fpm</span><span class="o">/$</span><span class="n">pool</span><span class="o">.</span><span class="n">log</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">php_admin_flag</span><span class="p">[</span><span class="n">log_errors</span><span class="p">]</span> <span class="o">=</span> <span class="n">on</span>
</span></span></code></pre></div><p>Die Einstellung von PHP ist damit abgeschlossen. Zum Abschluss gönne <strong>PHP</strong> und <strong>nginx</strong> noch einen Neustart. Danach sollte dein System rund laufen.</p>
<h2 id="zusammenfassung">Zusammenfassung</h2>
<p>Wenn du es bis hierhin geschafft hast, unterstützt dein Setup nun einen relativ performanten Server für mehrere Domains (aka virtuelle Server, virtual Hosts), der PHP-FPM nutzt und eine ziemlich solide Sicherheits-Grundeinstellung mitbringt.</p>
<p>Jeder einzelne virtuelle Server hat seine eigene Umgebung im Dateisystem, aus der er kaum ausbrechen kann. Die PHP-Prozesse sind voneinander getrennt, genauso wie die Speicherbereiche für den Cache. Außerdem ist das ganze darauf ausgerichtet, möglichst gut mit Wordpress zu laufen. Um das ganze System für Wordpress perfekt abzurunden, gibt es noch eine Handvoll Möglichkeiten, die ich gesondert vorstellen werden.</p>
<p><img src="/2019/2019-10-02-mehrere-virtuelle-server-mit-nginx-und-php-fpm-fuer-wordpress-teil-3-3/images/zusammenfassung-700x394.png" alt=""></p>
<p>Grobe schematische Übersicht des Setups für mehrere virtuelle Server mit nginx und PHP-FPM</p>
<h2 id="nachtrag">Nachtrag</h2>
<p>Wenn du noch ein paar zusätzliche Informatioen benötigst, sei dir der der ähnlich ausgerichtete Artikel auf <a href="https://binary-butterfly.de/artikel/das-perfekte-php-wordpress-setup/">binary-butterfly.de</a> empfohlen. Die Einstellungen für nginx und PHP unterscheiden sich kaum, dafür erfährst du dort auch, wie du zusätzlich mehrere SSH-Nutzer mit ins Boot holen kannst.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Nginx, PHP-FPM, WordPress, Server Konfiguration, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>hosting</category>
      
      <category>wordpress</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Mehrere virtuelle Server mit nginx und PHP-FPM für Wordpress (Teil 3 / 3) - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item><item>
      <title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten</title>
      <link>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</link>
      <pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</guid>
      <description>Ich habe mich eine ganze weile erfolgreich vor Docker als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine umfassende Anleitung zur Einrichtung einer lokalen Web-Entwicklungsumgebung auf macOS mit Docker. Das Tutorial beschreibt detailliert, wie man Container für Nginx, PHP-FPM und MySQL aufsetzt und miteinander verknüpft. Ein besonderer Fokus liegt auf der Erstellung eines benutzerdefinierten Docker-Images mittels Dockerfile, um Xdebug für das PHP-Debugging zu installieren und in Visual Studio Code zu integrieren.</p>
          
          
          <p><strong>Hauptthemen:</strong> Docker, macOS, Nginx, PHP-FPM, MySQL, Xdebug, Web-Development, DevOps</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Ich habe mich eine ganze weile erfolgreich vor <strong>Docker</strong> als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über die ich Ubuntu virtualisiert laufen lasse und bin damit bisher ganz gut gefahren. Bisher. Paralles hat nämlich immer wieder Problem gemacht. So konnte ich nach manchen Updates von Parallels oder Ubuntu die <em>Parallels Tools</em> nicht mehr nutzen und musste diese umständlich neu installieren. Da die Doku dazu auch nur unvollständig vorliegt, war das regelmäßig eine ziemliche Zeitverschwendung. Die <em>Parallels Tools</em> sind aber notwendig, um von Ubuntu aus auf die Dateien des Gastsystems, Mac OS X, zuzugreifen.</p>
<p>Beim letzten Update auf Ubuntu 18.04 ließen sich die <em>Parallels Tools</em> gar nicht mehr installieren. Die Ursache dafür ist wohl irgendeine Inkompatibilität eines abhängigen Paketes mit dem neuen Linux-Kernel. Wie auch immer: Ich war die Sorgen leid und auf der Suche nach einer Alternative. Weshalb ich <strong>Docker</strong> stieß. Der Vorteil: Docker ist weitaus performanter und portabler. Der Nachteil: Um damit eine funktionierende Entwicklungsumgebung zu schaffen, kommt man um die Shell nicht herum. Das mitgelieferte UI Kitematic liegt noch als Beta vor und lässt einige Funktionen einfach vermissen. Es gibt also einige kleinere Fallstricke, die es zu überwinde galt. Was mir gelungen ist. Wie, das werde ich nun genauer erläutern. <em>Viel Spass</em>.</p>
<p>[caption id=&ldquo;attachment_2166&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-scho%CC%88n-aber-noch-nutzlos.png"><img src="images/kitematic-scho%CC%88n-aber-noch-nutzlos-300x181.png" alt="Kitematic - schön aber (noch) weitestgehend nutzlos"></a> Kitematic - schön aber (noch) weitestgehend nutzlos[/caption]</p>
<h2 id="erste-schritte">Erste Schritte</h2>
<p>Grundsätzlich kann man bei der  Installation der Docker-Anwendung nicht viel falsch machen: Account anlegen, Docker herunterladen, installieren, anmelden - fertig. Auf die zugrunde liegende Technologie will ich hier nicht weiter eingehen, das machen andere weitaus besser (z.B. <a href="https://www.ab-heute-programmieren.de/docker-teil-1-was-ist-docker/">ist diese Anleitung sehr zu empfehlen</a>).</p>
<p>Nur soviel soll gesagt sein: Du lädst ein <strong>Image</strong> herunter, dass du dann <em>starten</em> kannst. Dadurch erhältst du einen <strong>Container</strong>, der bestimmte Dienste bereitstellt. Dieser Container ist kein vollständiges Betriebssystem mit all seinem Ballast. So kannst du z.B. nicht ohne weiteres per SSH darauf zugreifen. Das funktioniert nur, wenn der entsprechende SSH-Dienst auch im Image vorgesehen ist. Das schöne an Docker ist aber, dass du das Image mit beliebigen Funktionalitäten über ein sogenanntes <strong>Dockerfile</strong> relativ unkompliziert nachrüsten kannst. Das erfordert zwar eine gewisse Umgewöhnung im Arbeitsablauf ab, bringt aber auch viele Vorteile mit sich.</p>
<p>Wer will kann sich mit der <strong>Kitematic UI</strong> durch die vorhandenen Docker-Images wühlen und auch direkt herunterladen. Diese stehen dann natürlich auch auf der Kommandozeile zur Verfügung. Mit <strong>docker image ls</strong> zeigst du alle verfügbaren Images an. Analog dazu listet <strong>docker container ls</strong> alle erstellten Container auf. Außerdem gibt es noch ein paar andere, für den Anfang ganz brauchbare Befehle:</p>
<p># alle lokal verfügbaren Images auflisten
docker image ls</p>
<h1 id="alle-gestarteten-bzw-erzeugten-container-auflisten">alle gestarteten bzw. erzeugten Container auflisten</h1>
<p>docker container ls</p>
<h1 id="die-kommandozeile-für-den-container-mit-dem-namen-mysql-die-kommandozeile-starten">die Kommandozeile für den Container mit dem Namen &ldquo;mysql&rdquo; die Kommandozeile starten</h1>
<p>docker exec -it mysql /bin/bash</p>
<h1 id="für-den-container-mit-dem-namen-mysql-das-setup-anzeigen">für den Container mit dem Namen &ldquo;mysql&rdquo; das Setup anzeigen</h1>
<p>docker inspect mysql</p>
<p>Für eine lokale Entwicklungsumgebung benötigt man zunächst einen <strong>HTTP- und einen MySQL-Server.</strong> Natürlich gehört zu jeder guten Entwicklungsumgebung auch ein Debugger - für PHP wäre das wohl <strong>xdebug</strong>. Ich nutze hier die beiden Images: <a href="https://hub.docker.com/r/richarvey/nginx-php-fpm/">nginx-php-fpm von Ric Harvey</a> und <a href="https://hub.docker.com/_/mysql/">das sehr aktuelle und offizielle MySQL-Image</a>, die ich erstmal ganz unkompliziert über Kitematic herunterlade. Das nginx-Image werde ich schließlich mit einem <strong>Dockerfile</strong> anpassen um auch <strong>xdebug</strong> nutzen zu können.</p>
<p>[caption id=&ldquo;attachment_2167&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-auswahl-von-images.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/kitematic-auswahl-von-images-300x152.png" alt="Die Auswahl neuer Images über Kitematic ist sehr bequem"></a> Die Auswahl neuer Images über Kitematic ist sehr bequem[/caption]</p>
<p>Ab hier verlasse ich Kitematic allerdings wieder und werde Docker nur noch über die Kommandozeile und ein paar selbst geschriebene Scripte nutzen. Los gehts&hellip;</p>
<h2 id="den-mysql-container-starten">Den MySQL-Container starten</h2>
<p>&hellip; es mit dem MySQL-Container. Da der nginx-Container auf MySQL zugreift, muss der MySQL-Container auch zuerst dasein. Der Aufruf dafür sieht folgendermaßen aus:</p>
<p>docker run \
&ndash;name mysql \
&ndash;publish 3306:3306 \
&ndash;volume /Users/nicky/Development/MySQL:/var/lib/mysql \
&ndash;env MYSQL_ALLOW_EMPTY_PASSWORD=yes \
&ndash;env MYSQL_ROOT_HOST=% \
&ndash;detach \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Mit &ndash;name vergebe ich einen festen und vor allem lesbaren Namen. Ohne diesen Parameter würde Docker eine Id anlegen, die den Zugriff später aber unnötig kompliziert macht. Der Parameter <em>--publish</em> legt fest, welcher Port &ldquo;von draußen&rdquo; auf einen Port im Docker-Container gemappt wird. Da sich die Dateien für die Datenbank physikalisch natürlich nicht im Docker-Container, sondern im Dateisystem vom Host befinden, muss ich dem Container mitteilen, wie er darauf zugreifen kann. Das passiert mit dem Parameter <em>--volume</em>. Damit kann ich nich nur Ordner im Container verfügbar machen, sondern auch Dateien. Das ist ganz praktisch, um z.B. Configurations-Dateien von außerhalb beim Start des Containers mitzuliefern.</p>
<p>Der Parameter <em>--env</em> dient dazu, Umgebungsvariablen zu setzen. Diese sind natürlich abhängig vom verwendeten Container. Für den MySQL-Container möchte ich hier zwei Parameter übergeben: Ich will eine Root-Benutzer ohne Passwort anlegen (<em>MYSQL_ALLOW_EMPTY_PASSWORD</em>) (das mag unsicher erscheinen, da ich hier aber lokal nur mit Testdaten arbeite, ist das erstmal einfach nur pragmatisch). Außerdem soll sich jeder Client verbinden können, also setzte ich <em>MYSQL_ROOT_HOST</em> auf %.</p>
<p>Eine Besonderheit ist der Parameter <em>default-authentication-plugin</em>. Wenn du ein Root-Passwort vergibst, solltest du zusätzlich diesen Parameter setzen. Zur Erklärung: Es handelt sich hier um ein MySQL 8-Image. Dort wird als Authentifizierungs-Methode <em>caching_sha2_password</em> verwendet, was sich mit Docker leider nicht verträgt und mit dieser Fehlermeldung quittiert wird:</p>
<blockquote>
<p>Unable to load authentication plugin &lsquo;caching_sha2_password</p></blockquote>
<p>Und schließlich gibt es noch den Parameter &ndash;detach, der einfach dafür sorgt, dass der Container im Hintergrund gestartet wird.</p>
<p>Das war es fast. Was jetzt noch fehlt, ist der Name des Images, dass die Grundlage für deinen neuen Container bilden soll: <em>mysql</em>. Wenn das Image lokal nicht vorhanden ist, lädt Docker es hilfsbereiterweise einfach herunter.</p>
<p>Es empfiehlt sich, den Aufruf in ein Shell-Script zu packen und diese Zeilen voranzustellen. Beim Aufruf wird also ein vorhandener Container erst gestoppt und gelöscht und dann neu gestartet:</p>
<p>#!/bin/bash
docker stop mysql
docker rm mysql
docker run \
&ndash;name mysql \
-p 3306:3306 \
-v /Users/nicky/Development/MySQL:/var/lib/mysql \
-e MYSQL_ALLOW_EMPTY_PASSWORD=yes \
-e MYSQL_ROOT_HOST=% \
-d \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Et voilà: Ein MySQL-Server im Docker-Container auf Knopfdruck!</p>
<h2 id="den-http-container-starten">Den HTTP-Container starten</h2>
<p>Am Vorgehen ändert sich nicht viel. Auch für den <strong>nginx-Server</strong> erstelle ich mir ein kleines Script. Dieses befindet sich aber in einem Unterordner meiner Wordpress-Installation. Mit dem Platzhalter <strong>${PWD}</strong> im Parameter <em>--volume</em> kann ich Docker das aktuelle Verzeichnis mitgeben. Dadurch kann  ich das Script auch innerhalb andere Wordpress-Installationen verwenden (und muss lediglich den Namen des Containers anpassen). Hier sorge ich also dafür, dass Docker das aktuelle Verzeichnis als Root-Verzeichnis für den HTTP-Server nutzt. Außerdem liefere ich eine eigene ini-Datei für PHP mit. Wichtig ist außerdem die Verknüpfung zu meinem zuvor erstellen MySQL-Container über den Parameter <em>--link</em>. Der Rest wird analog des ersten Containers vorgegeben: Port, Name, Image, usw.</p>
<p>#!/bin/bash
docker stop nickyreinert-de
docker rm nickyreinert-de
docker run \
&ndash;link mysql \
&ndash;name nickyreinert-de \
&ndash;volume ${PWD}/dev/wordpress.ini:/usr/local/etc/php/conf.d/uploads.ini \
&ndash;volume ${PWD}:/var/www/html \
&ndash;publish 80:80 \
&ndash;detach \
richarvey/nginx-php-fpm</p>
<h2 id="xdebug-installieren">xdebug installieren</h2>
<p>Leider liefert das nginx-Image kein <strong>xdebug</strong> mit. Bzw: Zurecht - der Sinn des ganzen Konzeptes ist es ja, schlanke Container nutzen zu können. Eine All-In-One-Lösung entspräche letztlich ja wieder einer kompletten virtuellen Maschine. Für mich jedenfalls heißt das, dass ich das nginx-Image nun irgendwie mit <strong>xdebug</strong> füttern muss. Das passiert mit <strong>docker build</strong>. Dazu benötige ich zunächst ein Dockerfile, dass auch genau so heißt und folgendermaßen aufgebaut ist - Erklärung folgt darunter:</p>
<p>FROM richarvey/nginx-php-fpm</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS
RUN apk add &ndash;no-cache nano</p>
<p>RUN pecl install xdebug
RUN echo &lsquo;zend_extension = /usr/local/lib/php/extensions/no-debug-non-zts-20170718/xdebug.so&rsquo; &raquo; /usr/local/etc/php/php.ini
RUN touch /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_enable=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_autostart=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_connect_back=0 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_host=192.168.0.11  &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_port=9000 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_log=/tmp/php-xdebug.log &raquo; /usr/local/etc/php/conf.d/xdebug.ini;</p>
<p>Zunächst einmal lege ich mit <em>FROM</em> fest, welches Images als Grundlage genutzt werden soll - in meinem Fall also nginx-php-fpm von richarvey. Mit <em>RUN</em> übergebe ich dann, zum Image passende, Befehle. So könnte ich xdebug zum Beispiel einfach mit pecl install xdebug installieren lassen. Du wirst dann aber recht schnell feststellen, dass das nicht ohne weiteres funktioniert. PHP ist in diesem Docker-Image natürlich nur mit den wichtigsten Paketen eingerichtet, <em>phpize</em> gehört so z.B. nicht dazu und der Aufruf würde mit folgender Fehlermeldung quittiert werden:</p>
<p>Cannot find autoconf. Please check your autoconf installation and the # $PHP_AUTOCONF environment variable. Then, rerun this script.</p>
<p>Die Lösung ist, <em>phpize</em> im Voraus mit allen notwendigen Abhängigkeiten zu installieren. Dazu dient der Aufruf</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS</p>
<p>Das das nicht immer so umfangreich vonstatten gehen muss, soll die Installation des Texteditors <em>nano</em> zeigen: Man kann gewünschte Pakete auch einfach mit <em>apk add <paketname></em> zum Docker-Image hinzufügen. Der apk-Parameter <em>--virtual</em> besagt, dass die genannten Pakete zu einem &ldquo;virtuellen Paket&rdquo; hinzugefügt werden, dass sich dann mit <em>apk del <paketname></em> leicht wieder entfernen lässt. Danach schließlich kann <strong>xdebug</strong> mit <em>pecl install</em> installiert werden. Die letzten beiden RUN-Aufrufe sorgen dafür, dass eine Standard-Konfiguration für xdebug eingerichtet wird. Hier wird es tatsächlich noch etwas tricky, wenn es um den <em>remote_host</em> geht. Docker lässt den Container später in einem eigenen Netzwerk laufen. Der Docker-Host, also in meinem Fall OS X,erhält dafür eine eigene IP-Adresse, wie z.B. 172.17.0.1. Das Problem: Das ist nicht die IP-Adresse, unter der OS X bzw. der Debug-Client (z.B. Visual Studio Code) erreichbar ist. Jeder Debug-Versuch wurde (in meinem Fall) in <em>/tmp/php-xdebug.log</em> mit folgender Fehlermeldung quittiert:</p>
<p>W: Creating socket for &lsquo;127.0.0.1:9000&rsquo;, poll success, but error: Operation in progress (29).</p>
<p>Der Remote-Host ist also die tatsächliche IP-Adresse deines Hosts, unabhängig von Docker. Hier demnach die IP-Adresse <em>192.168.0.11</em>.</p>
<p>Zum Abschluss muss das Dockerfile nur noch verarbeitet werden. Das passiert mit folgendem Aufruf:</p>
<p>docker build &ndash;tag nginx-php-fpm-xdebug .</p>
<p>Mit dem Parameter <em>--tag</em> gibst du dem modifizierten Image einen eigenen Namen. Der letzte Parameter - ein Punkt - zeigt docker, in welcher Datei sich die Build-Anweisung befindet. Docker sucht standardmäßig nach einer Datei mit dem Namen Dockerfile. Deshalb verweise ich mit dem Punkt einfach nur auf den aktuellen Ordner, in dem sich diese Datei auch befindet.</p>
<p>Docker wird nun die Anweisungen aus dem Dockerfile verarbeiten und ein neues Image erzeugen. Der erste Aufruf wird etwas länger dauern. Wenn du an dem Dockerfile nur geringfügige Änderungen vornimmst und den build-Prozesse erneut startest, ist Docker so clever und nimmt nur die notwendigen Änderungen vor - alles andere befindet sich bereits in einer Art &ldquo;Zwischenspeicher&rdquo;.</p>
<p>Denke nun daran, den oben bereits zusammengebauten Container-Aufruf des HTTP-Servers den Image-Name anzupassen: <em>nginx-php-fpm-xdebug</em>!</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<p>Der Vollständigkeit halber möchte ich nun noch die Schritte dokumentieren, die bei Microsofts Visual Studio Code (VSC) notwendig sind. Hier installiert man zunächst das Paket <strong>PHP Debug</strong>. Im Debug-Bereich fügt man dann eine neue Konfiguration hinzu, die VSC mitteilt, unter welcher IP-Adresse xdebug erreichbar ist - nämlich 127.0.0.1 und dem üblichen Port: 9000:</p>
<p>{
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: <a href="https://go.microsoft.com/fwlink/?linkid=830387">https://go.microsoft.com/fwlink/?linkid=830387</a>
&ldquo;version&rdquo;: &ldquo;0.2.0&rdquo;,
&ldquo;configurations&rdquo;: [
{
&ldquo;name&rdquo;: &ldquo;Listen for XDebug&rdquo;,
&ldquo;type&rdquo;: &ldquo;php&rdquo;,
&ldquo;request&rdquo;: &ldquo;launch&rdquo;,
&ldquo;port&rdquo;: 9000,
&ldquo;host&rdquo;: &ldquo;127.0.0.1&rdquo;
}
]
}</p>
<p>Fertig. Mit einem Klick auf den grünen Playbutton wird VSC sich nun mit xdebug verbinden.</p>
<p>[caption id=&ldquo;attachment_2199&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/visual-studio-code-den-debugger-starten.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/visual-studio-code-den-debugger-starten-300x162.png" alt="Visual Studio Code - den Debugger starten"></a> Visual Studio Code - den Debugger starten[/caption]</p>
<h2 id="fazit">Fazit</h2>
<p>Docker hat mich voll überzeugt. Ich bereue es, dass ich nicht schon früher umgestiegen bin. Es läuft sauber und wenn man das Konzept erstmal verstanden hat, ist es auch sehr intuitiv zu bedienen und lässt vor allem keine Wünsche auf. Im Nachhinein betrachtet hat mich die komplette Einrichtung der virtuellen Maschine mit Ubuntu unter Parallels auch weitaus mehr Zeit - und Nerven! - gekostet. Was jetzt noch fehlt, ist das etwas dynamischere Verwalten mehrerer lokaler Websiten mit Docker. Dazu komme ich später - <em>stay tuned</em>.</p>
<h2 id="referenzen">Referenzen</h2>
<p>Mein Dank gilt <a href="http://paislee.io/a-minimal-development-server-with-nginx-and-docker/">Caleb Sotelo</a>, von wo ich einen Großteil der Scripte habe. Ein Teil des Dockerfiles stammt von <a href="https://blog.philipphauer.de/debug-php-docker-container-idea-phpstorm/">philipphauer.de</a>. Danke!</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Docker, macOS, Nginx, PHP, Xdebug, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item>
  </channel>
</rss>