<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>MacOS auf Nicky Reinert</title>
    <link>https://nickyreinert.de/topics/macos/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Fri, 26 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/topics/macos/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Drölf erstaunlich einfache Wege wirklich beeindruckende Screenshots zu erstellen</title>
      <link>https://nickyreinert.de/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/</guid>
      <description>[caption id=&ldquo;attachment_2364&rdquo; align=&ldquo;alignright&rdquo; width=&ldquo;183&rdquo;] Screenshot mit dem Handy aufnehmen ist so 90er[/caption]
Eine …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine umfassende und humorvolle Anleitung, die verschiedene einfache Methoden zur Erstellung hochwertiger Screenshots vorstellt. Der Artikel behandelt die integrierten Werkzeuge und Tastenkombinationen in macOS und Windows 10 sowie die Screenshot-Funktionen der Webbrowser Firefox, Chrome und Microsoft Edge.</p>
          
          
          <p><strong>Hauptthemen:</strong> Screenshots, Anleitungen, macOS, Windows 10, Browser-Tools, Produktivität</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> beginner</p>
          
        </div>
        
        
        <p>[caption id=&ldquo;attachment_2364&rdquo; align=&ldquo;alignright&rdquo; width=&ldquo;183&rdquo;]<a href="https://www.nickyreinert.de/files/droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/screenshot-mit-dem-handy.jpg"><img src="/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/images/screenshot-mit-dem-handy-183x300.jpg" alt="Screenshot mit dem Handy aufnehmen ist so 90er"></a> Screenshot mit dem Handy aufnehmen ist so 90er[/caption]</p>
<p>Eine Studie hat ergeben, dass 99 von 100 Bildschirmaufnahmen (neudeutsch <strong>Screenshots</strong>) mit dem Handy aufgenommen werden. Warum ist das falsch? Nun:</p>
<ul>
<li>Weil die Qualität der Aufnahmen mit dem Smartphone oft ziemlich schlecht ist,</li>
<li>der staubige Bildschirm zusätzlich vom Wesentlichen ablenkt sowie</li>
<li>Licht-Reflexionen oder Moiré-Effekte wichtige Inhalte verdecken.</li>
<li>Außerdem muss man den Screenshot, wenn man ihn in einem Forum oder einer Social Media Gruppe präsentieren will, unter Umständen erst noch umständlich mit dem Smartphone speichern, ausschneiden, bearbeiten und irgendwo hochladen.</li>
<li>Auf einem Smartphone-Foto ist nicht sofort ersichtlich, um welche Teile des Bildschirms es denn nun geht.</li>
</ul>
<p><strong>Konfuzius</strong>, ein berühmter buddhistischer Priester und begeisterter Internetnutzer, hat es mal so zusammengefasst:</p>
<blockquote>
<p>Wer Screenshots im 21. Jahrhundert mit dem Handy im Hochformat aufnimmt, hat die Kontrolle über sein Leben verloren.</p></blockquote>
<p>Dabei sind die technischen Möglichkeiten zur Aufnahme von Screenshots mittlerweile so viel mehr bequemer als noch zu Zeiten von Netscape und Microsoft DOS. Hier stelle ich die besten und vor allem einfachsten vor!</p>
<h2 id="screenshots-in-mac-os-x-aufnehmen">Screenshots in Mac OS X aufnehmen</h2>
<p>Das Betriebssystem von Apple bietet schon eine ganze Weile eine Reihe von Shortcuts an, mit denen sich Bildschirminhalte als Bilddatei aufnehmen lassen:</p>
<ol>
<li>Will man den <strong>gesamten Bildschirm</strong> aufnehmen und direkt als Datei speichern, drückt man die folgenden Tasten gleichzeitig: <strong>Umschalttaste-Befehlstaste(⌘)-3</strong>.</li>
<li>Soll nur ein <strong>bestimmter Bereich</strong> aufgenommen werden, lautet der Shortcut <strong>Umschalttaste-Befehlstaste(⌘)-4</strong> - der Mauscursor wird zu einem Fadenkreuz um damit den gewünschten Bereich zu markieren</li>
<li>Zur <strong>Aufnahme eines Fensters</strong> drückt man ebenso <strong>Umschalttaste-Befehlstaste(⌘)-4 und danach die Leertaste</strong>. Nun lässt sich das Fenster per Mausklick auswählen.</li>
<li>Möchte man die Aufnahme nicht als Datei speichern, sondern in direkt in die <strong>Zwischenablage</strong> kopieren, drückt man zu den oben genannten Tastenkombinationen <strong>zusätzlich die CTRL-Taste</strong></li>
</ol>
<p>Die komplette Dokumentation dazu befindet sich hier: <a href="https://support.apple.com/de-de/ht201361">https://support.apple.com/de-de/ht201361</a></p>
<p>Mit der <a href="https://help.apple.com/macOS/mojave/whats-new/?lang=de">neuen Version MacOS</a> führt Apple ein verbessertes Tool für Screenshots ein (<strong>Umschalttaste-Befehlstaste(⌘)-4</strong>). Nun gibt es einen Timer (5 oder 10 Sekunden) und eine kleine Oberfläche um den Bildschirmaufnahme bequemer zu konfigurieren.</p>
<h2 id="screenshots-in-windows-10-aufnehmen">Screenshots in Windows 10 aufnehmen</h2>
<p>Windows von Hause aus eine noch größere Vielzahl von Möglichkeiten an, bequem Screenshots zu erstellen:</p>
<ol>
<li>
<p>Das <strong>Snipping Tool</strong> zur Aufnahme und Bearbeitung von Screenshots ist schon seit Windows 7 Bestandteil des Betriebssystems. Es unterstützt die Aufnahme von beliebigen Bereich, dem ganzen Bildschirm oder sogar komplexer Formen. Außerdem lässt sich eine Verzögerung einstellen, um z.B. Hover-Effekte zu dokumentieren. Außerdem lassen sich bereich mit Farben einfach markieren. Wenn man das Snipping-Tool in der Taskleiste abgelegt hat, kann man über das Kontextmenü zu den Eigenschaften. Dort kann man eine Tastenkombination festlegen, um das Tool jederzeit schnell aufrufen zu können.</p>
<p>[caption id=&ldquo;attachment_1790&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/12-erstaunliche-und-einfache-wege-beeindruckende-screenshots-zu-erstellen/snipping-tool.png"><img src="/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/images/snipping-tool-300x206.png" alt="Eigenschaften für das Snipping-Tool öffnen"></a> Eigenschaften für das Snipping-Tool öffnen[/caption]</p>
</li>
<li>
<p>Den <strong>gesamten Bildschirm</strong> kann man auf einer Windows-Tastatur mit der <strong>Druck- bzw. PrtScr-Taste</strong> direkt in die Zwischenablage kopieren. Drückt man die <strong>Druck-Taste und Windows-Taste gleichzeitig,</strong> wird der Screenshot im Ordner Bilder - Screenshot <strong>als Datei abgelegt</strong>.</p>
</li>
<li>
<p>Nutzt man mehrere Monitore und will nur den gerade aktiven Bildschirm in die Zwischenablage packen, funktioniert das mit <strong>Alt+Druck-Taste</strong>.</p>
</li>
<li>
<p>Seit Windows 10 gibt es außerdem das <strong>Ink-Tool</strong>, das sich mit <strong>Windows-Taste+W</strong> aufrufen lässt und eine ganze Palette von zusätzlichen Funktionen mitbringt.</p>
<p>[caption id=&ldquo;attachment_1784&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;189&rdquo;]<a href="https://www.nickyreinert.de/files/12-erstaunliche-und-einfache-wege-beeindruckende-screenshots-zu-erstellen/windows-ink.png"><img src="/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/images/windows-ink.png" alt="Screenshot in Windows mit Ink erstellen"></a> Screenshot in Windows mit Ink erstellen[/caption]</p>
</li>
<li>
<p>Noch etwas komfortabler als das Snipping-Tool, aber kein Standard-Bestandteil von Windows, ist <a href="https://www.microsoft.com/en-us/garage/profiles/snip/">Snip</a>.</p>
</li>
</ol>
<h2 id="screenshot-im-browser-direkt-aufnehmen">Screenshot im Browser direkt aufnehmen</h2>
<p>Auch die Browser-Hersteller haben erkannt, dass Screenshots wohl ein essentieller Bestandteil des Internets sind. So bieten die gängigsten Browser mittlerweile Funktionen zur Aufnahme des Bildschirms an.</p>
<ol>
<li>
<p>In <strong>Firefox</strong> befindet sich die Funktion direkt im Kontext-Menü jeder Website. Damit lassen sich bestimmte Elemente der Seite, freie Bereich oder die ganze Seite als Screenshot in die Zwischenablage kopieren, als Datei speichern oder sogar in einer Firefox-Cloud ablegen um sie online unter <a href="https://screenshots.firefox.com/shots">https://screenshots.firefox.com/shots</a> verfügbar zu machen!</p>
<p>[caption id=&ldquo;attachment_1789&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/12-erstaunliche-und-einfache-wege-beeindruckende-screenshots-zu-erstellen/firefox.png"><img src="/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/images/firefox-300x165.png" alt="Screenshot in Firefox anfertigen"></a> Screenshot in Firefox anfertigen[/caption]</p>
</li>
<li>
<p>In <strong>Chrome</strong> ist die Screenshot-Funktion leider etwas versteckt und nicht sehr komfortabel. Am schnellsten erreicht man diese über die Kommandofunktion. Zunächst muss man die Entwicklerkonsole öffnen indem man z.B. die <strong>Taste F12</strong> oder <strong>Control+Shift+I</strong> drückt (Mac: <strong>Command+Option+I</strong>). Dann gelangt man mit Strg+Shift+P zur Auswahl der Chrome-Kommandos wo man nach der Screenshot-Funktion suchen kann. Der lange Weg führt übrigens über die Geräte-Toolbar, mit der Chrome verschiedene Geräteklassen simulieren kann (Ctrl+Shift+M). Dort muss erst oben die gewünschte Auflösung bzw. das Gerät auswählen. Über das kleine Menü in der rechten oberen Ecke gelangt man dann schließlich zur Screenshot-Funktion.[gallery ids=&ldquo;1788,1787,1786&rdquo;]</p>
</li>
<li>
<p>Der neue Microsoft Browser <strong>Edge</strong> ist hier wieder etwas komfortabler. Die Funktion befindet sich hinter dem Button &ldquo;<strong>Notizen einfügen</strong>&rdquo; (Pen &amp; Stencil) rechts neben der Adressleiste. Das Tool bietet sehr viele Funktionen, um den Screenshot aufzunehmen und mit Notizen zu versehen.</p>
<p>[caption id=&ldquo;attachment_1785&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;294&rdquo;]<a href="https://www.nickyreinert.de/files/12-erstaunliche-und-einfache-wege-beeindruckende-screenshots-zu-erstellen/edge-notizen.png"><img src="/2018/2018-10-26-droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/images/edge-notizen.png" alt="Screenshot anfertigen in Microsoft Edge"></a> Screenshot anfertigen in Microsoft Edge[/caption]</p>
</li>
</ol>
<h2 id="screenshot-mit-dem-smartphone-aufnehmen">Screenshot mit dem Smartphone aufnehmen</h2>
<p>Du kannst natürlich nicht immer einen ausgewachsenen Computer zur Hand haben und manchmal will man tatsächlich etwas dokumentieren, was einem auf dem kleinen Smartphone-Bildschirm widerfahren ist. Bevor du dir dazu ein weiteres Smartphone nimmst um ein Foto von deinem Smartphone-Display zu machen: Zumindest Android hat seit geraumer Zeit eine Screenshot-Funktion eingebaut: Wenn du den An-/Aus-Button etwas länger drückst, erscheint ein Menü, in dem du die Wahl zwischen Screenshot und sogar einer Bewegtbild-Aufnahme des Bildschirms hast.</p>
<h2 id="zusammenfassung">Zusammenfassung</h2>
<p>Mit den hier beschriebenen Methoden landet der hochwertige Screenshot mit geringem Aufwand direkt in der Zwischenablage des Computers (oder als Datei in einem Ordner). Die meisten modernen Plattformen wie Facebook oder Twitter erlauben außerdem mittlerweile das direkte Einfügen von Bildern - also auch Screenshots - aus der Zwischenablage in den Beitrag oder Tweet (z.B. unter Windows mit <strong>CTRL+V</strong>). Man kann also innerhalb weniger Sekunden und mit wenigen Handgriffen einen ansehnlichen Screenshot erstellen, gegebenenfalls fragliche Bereich farblich hervorheben und dann in einen Beitrag auf Facebook kopieren.</p>
<p>Also, pack dein Smartphone weg oder nutze es für die wirklich wichtigen Dinge und überlasse die richtig guten Screenshots deinem Computer.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> screenshots, anleitung, macOS, Windows</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>office</category>
      
      <category>tools</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Drölf erstaunlich einfache Wege wirklich beeindruckende Screenshots zu erstellen - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item><item>
      <title>MacOS Mojave - 3 tolle neue Funktionen</title>
      <link>https://nickyreinert.de/2018/2018-10-15-macos-mojave-3-tolle-neue-funktionen/</link>
      <pubDate>Mon, 15 Oct 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-10-15-macos-mojave-3-tolle-neue-funktionen/</guid>
      <description>Seit Ende September gibt es ja eine neue Version das Betriebssystems für Macs: Mojave. Die Versionsnummer lautet 10.14. Nachdem mich die letzten Updates vom …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Der Artikel stellt drei nützliche neue Funktionen des Betriebssystems macOS Mojave (10.14) vor: die verbesserte Screenshot- und Bildschirmaufnahme-Funktion, die neue App zur schnellen Bearbeitung und Markierung von Bildern und PDFs direkt im Finder sowie den systemweiten Dark Mode.</p>
          
          
          <p><strong>Hauptthemen:</strong> macOS, Mojave, Betriebssysteme, Software-Features, Apple</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> beginner</p>
          
        </div>
        
        
        <p>Seit Ende September gibt es ja eine neue Version das Betriebssystems für Macs: Mojave. Die Versionsnummer lautet 10.14. Nachdem mich die letzten Updates vom Funktionsumfang nicht so sehr überrascht haben, gibt es diesmal ein paar Features, die mir wirklich gut gefallen. Und drei dieser Funktionen, bei denen ich mich auch frage: Warum erst jetzt?, möchte ich hier mal</p>
<h2 id="1-eine-bessere-screenshot-funktion">1. Eine bessere Screenshot-Funktion</h2>
<p>Apple hat wohl erkannt, dass die Nutzer ab und zu <a href="https://www.nickyreinert.de/droelf-erstaunlich-einfache-wege-wirklich-beeindruckende-screenshots-zu-erstellen/">doch mal Screenshots anlegen müssen</a>. Zwar gab es dafür schon eine ganze Weile Shortcuts (wie z.B. Umschalttaste - Apfel - 4). Aber insgesamt gingt die Funktion etwas unter: sie war ohne richtiges Interface nur umständlich zu bedienen und - naja - die Tastenkombination musste man sich ja auch irgendwie merken. Das ändert sich mit Mojave. Zwar gibt es nun einen weiteren Shortcut (Umschalttaste - Apfel - 5) den man sich merken muss. Aber Apple hat das ganze auch in eine App gegossen, die man mit der Suche nun viel einfacher öffnen kann. Mit der App kann man außerdem nicht nur Bilder aufnehmen, sondern auch Videos und diese an beliebigen Orten speichern.</p>
<h2 id="2-bilder-markieren">2. Bilder markieren</h2>
<p>Im Finder wurde die Vorschau-Darstellung optimiert. Der Fächer wurde abgelöst, stattdessen sieht man nur das jeweils ausgewählte Objekt in einer größeren Vorschau. Das ist aber noch nicht die spannende Neuerung. Es gibt nun eine App für die schnelle Bearbeitung von Bildern und PDF-Dokumenten, die viele Aufgaben sehr erleichtern wird. Dateien lassen sich mit Texten, den typischen geometrischen Formen oder Freihandzeichnungen versehen. Die Freihandzeichnungen werden vom Programm sogar analysiert und man kann diese dann ihn geometrische Objekte umwandeln, die der Zeichnung am ähnlichsten sind.</p>
<p>[caption id=&ldquo;attachment_2233&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/macos-mojave/macos-mojave-bildmarkierung.png"><img src="/2018/2018-10-15-macos-mojave-3-tolle-neue-funktionen/images/macos-mojave-bildmarkierung-300x185.png" alt="MacOs Mojave Bildmarkierung - Funktionen"></a> MacOs Mojave Bildmarkierung - Funktionen[/caption]</p>
<p>Außerdem kann man z.B. die Unterschrift sehr einfach über das Trackpad aufzeichnen, ohne es dauerhaft zu &ldquo;klicken&rdquo;. Die App aktiviert dazu einen Unterschriften-Modus und erfasst dann jede Berührung des Trackpads.</p>
<p>Weiterhin gibt es zwei Funktionen zum Hervorheben von Bereichen. Eines davon ist ein Kreis, der den Bereich vergrößert, den er überdeckt. Das andere ist ein Rechteck, dass den außenliegenden Bereich etwas abblendet.</p>
<h2 id="3-der-dunkle-modus">3. Der dunkle Modus</h2>
<p>Endlich gibt es einen dunklen Darstellungsmodus. Soviel muss man dazu gar nicht sagen, außer, dass es sehr angenehm ist. Sicherlich ist das Geschmackssache, für mich ist ein dunkles Template bei allen genutzten Apps aber immer die erste Wahl.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> macOS, Mojave, Apple, Review</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>blog</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>MacOS Mojave - 3 tolle neue Funktionen - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>feature_highlight</dc:type>
      
      
    </item><item>
      <title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten</title>
      <link>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</link>
      <pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</guid>
      <description>Ich habe mich eine ganze weile erfolgreich vor Docker als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine umfassende Anleitung zur Einrichtung einer lokalen Web-Entwicklungsumgebung auf macOS mit Docker. Das Tutorial beschreibt detailliert, wie man Container für Nginx, PHP-FPM und MySQL aufsetzt und miteinander verknüpft. Ein besonderer Fokus liegt auf der Erstellung eines benutzerdefinierten Docker-Images mittels Dockerfile, um Xdebug für das PHP-Debugging zu installieren und in Visual Studio Code zu integrieren.</p>
          
          
          <p><strong>Hauptthemen:</strong> Docker, macOS, Nginx, PHP-FPM, MySQL, Xdebug, Web-Development, DevOps</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Ich habe mich eine ganze weile erfolgreich vor <strong>Docker</strong> als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über die ich Ubuntu virtualisiert laufen lasse und bin damit bisher ganz gut gefahren. Bisher. Paralles hat nämlich immer wieder Problem gemacht. So konnte ich nach manchen Updates von Parallels oder Ubuntu die <em>Parallels Tools</em> nicht mehr nutzen und musste diese umständlich neu installieren. Da die Doku dazu auch nur unvollständig vorliegt, war das regelmäßig eine ziemliche Zeitverschwendung. Die <em>Parallels Tools</em> sind aber notwendig, um von Ubuntu aus auf die Dateien des Gastsystems, Mac OS X, zuzugreifen.</p>
<p>Beim letzten Update auf Ubuntu 18.04 ließen sich die <em>Parallels Tools</em> gar nicht mehr installieren. Die Ursache dafür ist wohl irgendeine Inkompatibilität eines abhängigen Paketes mit dem neuen Linux-Kernel. Wie auch immer: Ich war die Sorgen leid und auf der Suche nach einer Alternative. Weshalb ich <strong>Docker</strong> stieß. Der Vorteil: Docker ist weitaus performanter und portabler. Der Nachteil: Um damit eine funktionierende Entwicklungsumgebung zu schaffen, kommt man um die Shell nicht herum. Das mitgelieferte UI Kitematic liegt noch als Beta vor und lässt einige Funktionen einfach vermissen. Es gibt also einige kleinere Fallstricke, die es zu überwinde galt. Was mir gelungen ist. Wie, das werde ich nun genauer erläutern. <em>Viel Spass</em>.</p>
<p>[caption id=&ldquo;attachment_2166&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-scho%CC%88n-aber-noch-nutzlos.png"><img src="images/kitematic-scho%CC%88n-aber-noch-nutzlos-300x181.png" alt="Kitematic - schön aber (noch) weitestgehend nutzlos"></a> Kitematic - schön aber (noch) weitestgehend nutzlos[/caption]</p>
<h2 id="erste-schritte">Erste Schritte</h2>
<p>Grundsätzlich kann man bei der  Installation der Docker-Anwendung nicht viel falsch machen: Account anlegen, Docker herunterladen, installieren, anmelden - fertig. Auf die zugrunde liegende Technologie will ich hier nicht weiter eingehen, das machen andere weitaus besser (z.B. <a href="https://www.ab-heute-programmieren.de/docker-teil-1-was-ist-docker/">ist diese Anleitung sehr zu empfehlen</a>).</p>
<p>Nur soviel soll gesagt sein: Du lädst ein <strong>Image</strong> herunter, dass du dann <em>starten</em> kannst. Dadurch erhältst du einen <strong>Container</strong>, der bestimmte Dienste bereitstellt. Dieser Container ist kein vollständiges Betriebssystem mit all seinem Ballast. So kannst du z.B. nicht ohne weiteres per SSH darauf zugreifen. Das funktioniert nur, wenn der entsprechende SSH-Dienst auch im Image vorgesehen ist. Das schöne an Docker ist aber, dass du das Image mit beliebigen Funktionalitäten über ein sogenanntes <strong>Dockerfile</strong> relativ unkompliziert nachrüsten kannst. Das erfordert zwar eine gewisse Umgewöhnung im Arbeitsablauf ab, bringt aber auch viele Vorteile mit sich.</p>
<p>Wer will kann sich mit der <strong>Kitematic UI</strong> durch die vorhandenen Docker-Images wühlen und auch direkt herunterladen. Diese stehen dann natürlich auch auf der Kommandozeile zur Verfügung. Mit <strong>docker image ls</strong> zeigst du alle verfügbaren Images an. Analog dazu listet <strong>docker container ls</strong> alle erstellten Container auf. Außerdem gibt es noch ein paar andere, für den Anfang ganz brauchbare Befehle:</p>
<p># alle lokal verfügbaren Images auflisten
docker image ls</p>
<h1 id="alle-gestarteten-bzw-erzeugten-container-auflisten">alle gestarteten bzw. erzeugten Container auflisten</h1>
<p>docker container ls</p>
<h1 id="die-kommandozeile-für-den-container-mit-dem-namen-mysql-die-kommandozeile-starten">die Kommandozeile für den Container mit dem Namen &ldquo;mysql&rdquo; die Kommandozeile starten</h1>
<p>docker exec -it mysql /bin/bash</p>
<h1 id="für-den-container-mit-dem-namen-mysql-das-setup-anzeigen">für den Container mit dem Namen &ldquo;mysql&rdquo; das Setup anzeigen</h1>
<p>docker inspect mysql</p>
<p>Für eine lokale Entwicklungsumgebung benötigt man zunächst einen <strong>HTTP- und einen MySQL-Server.</strong> Natürlich gehört zu jeder guten Entwicklungsumgebung auch ein Debugger - für PHP wäre das wohl <strong>xdebug</strong>. Ich nutze hier die beiden Images: <a href="https://hub.docker.com/r/richarvey/nginx-php-fpm/">nginx-php-fpm von Ric Harvey</a> und <a href="https://hub.docker.com/_/mysql/">das sehr aktuelle und offizielle MySQL-Image</a>, die ich erstmal ganz unkompliziert über Kitematic herunterlade. Das nginx-Image werde ich schließlich mit einem <strong>Dockerfile</strong> anpassen um auch <strong>xdebug</strong> nutzen zu können.</p>
<p>[caption id=&ldquo;attachment_2167&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-auswahl-von-images.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/kitematic-auswahl-von-images-300x152.png" alt="Die Auswahl neuer Images über Kitematic ist sehr bequem"></a> Die Auswahl neuer Images über Kitematic ist sehr bequem[/caption]</p>
<p>Ab hier verlasse ich Kitematic allerdings wieder und werde Docker nur noch über die Kommandozeile und ein paar selbst geschriebene Scripte nutzen. Los gehts&hellip;</p>
<h2 id="den-mysql-container-starten">Den MySQL-Container starten</h2>
<p>&hellip; es mit dem MySQL-Container. Da der nginx-Container auf MySQL zugreift, muss der MySQL-Container auch zuerst dasein. Der Aufruf dafür sieht folgendermaßen aus:</p>
<p>docker run \
&ndash;name mysql \
&ndash;publish 3306:3306 \
&ndash;volume /Users/nicky/Development/MySQL:/var/lib/mysql \
&ndash;env MYSQL_ALLOW_EMPTY_PASSWORD=yes \
&ndash;env MYSQL_ROOT_HOST=% \
&ndash;detach \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Mit &ndash;name vergebe ich einen festen und vor allem lesbaren Namen. Ohne diesen Parameter würde Docker eine Id anlegen, die den Zugriff später aber unnötig kompliziert macht. Der Parameter <em>--publish</em> legt fest, welcher Port &ldquo;von draußen&rdquo; auf einen Port im Docker-Container gemappt wird. Da sich die Dateien für die Datenbank physikalisch natürlich nicht im Docker-Container, sondern im Dateisystem vom Host befinden, muss ich dem Container mitteilen, wie er darauf zugreifen kann. Das passiert mit dem Parameter <em>--volume</em>. Damit kann ich nich nur Ordner im Container verfügbar machen, sondern auch Dateien. Das ist ganz praktisch, um z.B. Configurations-Dateien von außerhalb beim Start des Containers mitzuliefern.</p>
<p>Der Parameter <em>--env</em> dient dazu, Umgebungsvariablen zu setzen. Diese sind natürlich abhängig vom verwendeten Container. Für den MySQL-Container möchte ich hier zwei Parameter übergeben: Ich will eine Root-Benutzer ohne Passwort anlegen (<em>MYSQL_ALLOW_EMPTY_PASSWORD</em>) (das mag unsicher erscheinen, da ich hier aber lokal nur mit Testdaten arbeite, ist das erstmal einfach nur pragmatisch). Außerdem soll sich jeder Client verbinden können, also setzte ich <em>MYSQL_ROOT_HOST</em> auf %.</p>
<p>Eine Besonderheit ist der Parameter <em>default-authentication-plugin</em>. Wenn du ein Root-Passwort vergibst, solltest du zusätzlich diesen Parameter setzen. Zur Erklärung: Es handelt sich hier um ein MySQL 8-Image. Dort wird als Authentifizierungs-Methode <em>caching_sha2_password</em> verwendet, was sich mit Docker leider nicht verträgt und mit dieser Fehlermeldung quittiert wird:</p>
<blockquote>
<p>Unable to load authentication plugin &lsquo;caching_sha2_password</p></blockquote>
<p>Und schließlich gibt es noch den Parameter &ndash;detach, der einfach dafür sorgt, dass der Container im Hintergrund gestartet wird.</p>
<p>Das war es fast. Was jetzt noch fehlt, ist der Name des Images, dass die Grundlage für deinen neuen Container bilden soll: <em>mysql</em>. Wenn das Image lokal nicht vorhanden ist, lädt Docker es hilfsbereiterweise einfach herunter.</p>
<p>Es empfiehlt sich, den Aufruf in ein Shell-Script zu packen und diese Zeilen voranzustellen. Beim Aufruf wird also ein vorhandener Container erst gestoppt und gelöscht und dann neu gestartet:</p>
<p>#!/bin/bash
docker stop mysql
docker rm mysql
docker run \
&ndash;name mysql \
-p 3306:3306 \
-v /Users/nicky/Development/MySQL:/var/lib/mysql \
-e MYSQL_ALLOW_EMPTY_PASSWORD=yes \
-e MYSQL_ROOT_HOST=% \
-d \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Et voilà: Ein MySQL-Server im Docker-Container auf Knopfdruck!</p>
<h2 id="den-http-container-starten">Den HTTP-Container starten</h2>
<p>Am Vorgehen ändert sich nicht viel. Auch für den <strong>nginx-Server</strong> erstelle ich mir ein kleines Script. Dieses befindet sich aber in einem Unterordner meiner Wordpress-Installation. Mit dem Platzhalter <strong>${PWD}</strong> im Parameter <em>--volume</em> kann ich Docker das aktuelle Verzeichnis mitgeben. Dadurch kann  ich das Script auch innerhalb andere Wordpress-Installationen verwenden (und muss lediglich den Namen des Containers anpassen). Hier sorge ich also dafür, dass Docker das aktuelle Verzeichnis als Root-Verzeichnis für den HTTP-Server nutzt. Außerdem liefere ich eine eigene ini-Datei für PHP mit. Wichtig ist außerdem die Verknüpfung zu meinem zuvor erstellen MySQL-Container über den Parameter <em>--link</em>. Der Rest wird analog des ersten Containers vorgegeben: Port, Name, Image, usw.</p>
<p>#!/bin/bash
docker stop nickyreinert-de
docker rm nickyreinert-de
docker run \
&ndash;link mysql \
&ndash;name nickyreinert-de \
&ndash;volume ${PWD}/dev/wordpress.ini:/usr/local/etc/php/conf.d/uploads.ini \
&ndash;volume ${PWD}:/var/www/html \
&ndash;publish 80:80 \
&ndash;detach \
richarvey/nginx-php-fpm</p>
<h2 id="xdebug-installieren">xdebug installieren</h2>
<p>Leider liefert das nginx-Image kein <strong>xdebug</strong> mit. Bzw: Zurecht - der Sinn des ganzen Konzeptes ist es ja, schlanke Container nutzen zu können. Eine All-In-One-Lösung entspräche letztlich ja wieder einer kompletten virtuellen Maschine. Für mich jedenfalls heißt das, dass ich das nginx-Image nun irgendwie mit <strong>xdebug</strong> füttern muss. Das passiert mit <strong>docker build</strong>. Dazu benötige ich zunächst ein Dockerfile, dass auch genau so heißt und folgendermaßen aufgebaut ist - Erklärung folgt darunter:</p>
<p>FROM richarvey/nginx-php-fpm</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS
RUN apk add &ndash;no-cache nano</p>
<p>RUN pecl install xdebug
RUN echo &lsquo;zend_extension = /usr/local/lib/php/extensions/no-debug-non-zts-20170718/xdebug.so&rsquo; &raquo; /usr/local/etc/php/php.ini
RUN touch /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_enable=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_autostart=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_connect_back=0 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_host=192.168.0.11  &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_port=9000 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_log=/tmp/php-xdebug.log &raquo; /usr/local/etc/php/conf.d/xdebug.ini;</p>
<p>Zunächst einmal lege ich mit <em>FROM</em> fest, welches Images als Grundlage genutzt werden soll - in meinem Fall also nginx-php-fpm von richarvey. Mit <em>RUN</em> übergebe ich dann, zum Image passende, Befehle. So könnte ich xdebug zum Beispiel einfach mit pecl install xdebug installieren lassen. Du wirst dann aber recht schnell feststellen, dass das nicht ohne weiteres funktioniert. PHP ist in diesem Docker-Image natürlich nur mit den wichtigsten Paketen eingerichtet, <em>phpize</em> gehört so z.B. nicht dazu und der Aufruf würde mit folgender Fehlermeldung quittiert werden:</p>
<p>Cannot find autoconf. Please check your autoconf installation and the # $PHP_AUTOCONF environment variable. Then, rerun this script.</p>
<p>Die Lösung ist, <em>phpize</em> im Voraus mit allen notwendigen Abhängigkeiten zu installieren. Dazu dient der Aufruf</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS</p>
<p>Das das nicht immer so umfangreich vonstatten gehen muss, soll die Installation des Texteditors <em>nano</em> zeigen: Man kann gewünschte Pakete auch einfach mit <em>apk add <paketname></em> zum Docker-Image hinzufügen. Der apk-Parameter <em>--virtual</em> besagt, dass die genannten Pakete zu einem &ldquo;virtuellen Paket&rdquo; hinzugefügt werden, dass sich dann mit <em>apk del <paketname></em> leicht wieder entfernen lässt. Danach schließlich kann <strong>xdebug</strong> mit <em>pecl install</em> installiert werden. Die letzten beiden RUN-Aufrufe sorgen dafür, dass eine Standard-Konfiguration für xdebug eingerichtet wird. Hier wird es tatsächlich noch etwas tricky, wenn es um den <em>remote_host</em> geht. Docker lässt den Container später in einem eigenen Netzwerk laufen. Der Docker-Host, also in meinem Fall OS X,erhält dafür eine eigene IP-Adresse, wie z.B. 172.17.0.1. Das Problem: Das ist nicht die IP-Adresse, unter der OS X bzw. der Debug-Client (z.B. Visual Studio Code) erreichbar ist. Jeder Debug-Versuch wurde (in meinem Fall) in <em>/tmp/php-xdebug.log</em> mit folgender Fehlermeldung quittiert:</p>
<p>W: Creating socket for &lsquo;127.0.0.1:9000&rsquo;, poll success, but error: Operation in progress (29).</p>
<p>Der Remote-Host ist also die tatsächliche IP-Adresse deines Hosts, unabhängig von Docker. Hier demnach die IP-Adresse <em>192.168.0.11</em>.</p>
<p>Zum Abschluss muss das Dockerfile nur noch verarbeitet werden. Das passiert mit folgendem Aufruf:</p>
<p>docker build &ndash;tag nginx-php-fpm-xdebug .</p>
<p>Mit dem Parameter <em>--tag</em> gibst du dem modifizierten Image einen eigenen Namen. Der letzte Parameter - ein Punkt - zeigt docker, in welcher Datei sich die Build-Anweisung befindet. Docker sucht standardmäßig nach einer Datei mit dem Namen Dockerfile. Deshalb verweise ich mit dem Punkt einfach nur auf den aktuellen Ordner, in dem sich diese Datei auch befindet.</p>
<p>Docker wird nun die Anweisungen aus dem Dockerfile verarbeiten und ein neues Image erzeugen. Der erste Aufruf wird etwas länger dauern. Wenn du an dem Dockerfile nur geringfügige Änderungen vornimmst und den build-Prozesse erneut startest, ist Docker so clever und nimmt nur die notwendigen Änderungen vor - alles andere befindet sich bereits in einer Art &ldquo;Zwischenspeicher&rdquo;.</p>
<p>Denke nun daran, den oben bereits zusammengebauten Container-Aufruf des HTTP-Servers den Image-Name anzupassen: <em>nginx-php-fpm-xdebug</em>!</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<p>Der Vollständigkeit halber möchte ich nun noch die Schritte dokumentieren, die bei Microsofts Visual Studio Code (VSC) notwendig sind. Hier installiert man zunächst das Paket <strong>PHP Debug</strong>. Im Debug-Bereich fügt man dann eine neue Konfiguration hinzu, die VSC mitteilt, unter welcher IP-Adresse xdebug erreichbar ist - nämlich 127.0.0.1 und dem üblichen Port: 9000:</p>
<p>{
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: <a href="https://go.microsoft.com/fwlink/?linkid=830387">https://go.microsoft.com/fwlink/?linkid=830387</a>
&ldquo;version&rdquo;: &ldquo;0.2.0&rdquo;,
&ldquo;configurations&rdquo;: [
{
&ldquo;name&rdquo;: &ldquo;Listen for XDebug&rdquo;,
&ldquo;type&rdquo;: &ldquo;php&rdquo;,
&ldquo;request&rdquo;: &ldquo;launch&rdquo;,
&ldquo;port&rdquo;: 9000,
&ldquo;host&rdquo;: &ldquo;127.0.0.1&rdquo;
}
]
}</p>
<p>Fertig. Mit einem Klick auf den grünen Playbutton wird VSC sich nun mit xdebug verbinden.</p>
<p>[caption id=&ldquo;attachment_2199&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/visual-studio-code-den-debugger-starten.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/visual-studio-code-den-debugger-starten-300x162.png" alt="Visual Studio Code - den Debugger starten"></a> Visual Studio Code - den Debugger starten[/caption]</p>
<h2 id="fazit">Fazit</h2>
<p>Docker hat mich voll überzeugt. Ich bereue es, dass ich nicht schon früher umgestiegen bin. Es läuft sauber und wenn man das Konzept erstmal verstanden hat, ist es auch sehr intuitiv zu bedienen und lässt vor allem keine Wünsche auf. Im Nachhinein betrachtet hat mich die komplette Einrichtung der virtuellen Maschine mit Ubuntu unter Parallels auch weitaus mehr Zeit - und Nerven! - gekostet. Was jetzt noch fehlt, ist das etwas dynamischere Verwalten mehrerer lokaler Websiten mit Docker. Dazu komme ich später - <em>stay tuned</em>.</p>
<h2 id="referenzen">Referenzen</h2>
<p>Mein Dank gilt <a href="http://paislee.io/a-minimal-development-server-with-nginx-and-docker/">Caleb Sotelo</a>, von wo ich einen Großteil der Scripte habe. Ein Teil des Dockerfiles stammt von <a href="https://blog.philipphauer.de/debug-php-docker-container-idea-phpstorm/">philipphauer.de</a>. Danke!</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Docker, macOS, Nginx, PHP, Xdebug, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item><item>
      <title>Die OS X - Bash</title>
      <link>https://nickyreinert.de/2018/2018-08-24-die-os-x-bash/</link>
      <pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-08-24-die-os-x-bash/</guid>
      <description>Da ich mit meinem Mac sehr oft auf der Kommandozeile unterwegs bin (dazu empfehle ich übrigens iTerm2 - ein Terminal-Ersatz der alle anderen Anwendungen dieser …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine Anleitung zur Anpassung der Bash-Shell auf macOS. Der Artikel erklärt die Hierarchie der Konfigurationsdateien und bietet eine Sammlung von praktischen Code-Snippets zur Optimierung des Workflows, inklusive Aliases für häufige Befehle, farblicher Gestaltung des Prompts und nützlicher Netzwerk-Tools.</p>
          
          
          <p><strong>Hauptthemen:</strong> macOS, Bash, Shell-Scripting, Kommandozeile, System-Konfiguration</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>Da ich mit meinem Mac sehr oft auf der Kommandozeile unterwegs bin (dazu empfehle ich übrigens <a href="https://www.iterm2.com/">iTerm2</a> - ein Terminal-Ersatz der alle anderen Anwendungen dieser Art auch auf Linux und Windows aussticht) habe ich mir dafür ein paar kleine Einstellungen zusammengesammelt, die das Leben und Arbeiten auf der Kommandozeile etwas erleichtern.</p>
<h2 id="was-ist-bash">Was ist Bash?</h2>
<p>Bash steht für &ldquo;Bourn again shell&rdquo; und ist eine Erweiterung der älteren Bourne-Shell, eine Shell die auf Unix-(ähnlichen) Systemen als Benutzerschnittstelle dient. Und diese ist vor allem daran erkennbar, dass die Steuerung des Systems nur über die Tastatur, ohne Maus und Fenster funktioniert.</p>
<p>Seit der Version 10.3 ist Bash auch Bestandteil von Mac OS X und bringt damit eine Menge Vorteile für die Arbeit auf der Kommandozeile mit sich.</p>
<h2 id="die-bash-konfigurationsdateien">Die Bash Konfigurationsdateien</h2>
<p>Die globalen Einstellungen für die Bash befinden sich in der Datei <strong>/etc/bashrc</strong> und der <strong>/etc/profile</strong>. Wer Einstellungen auf bestimmte Benutzer beschränken will, kann im Benutzerverzeichnis (du gelangst mit <em>cd ~</em> dorthin) eine Datei mit dem Name <strong>.profile</strong>, <strong>.bash_login</strong> oder <strong>.bash_profile</strong> anlegen. Beachte, dass <strong>.profile</strong> nur geladen wird, wenn <strong>.bash_login</strong> nicht existiert, welche wiederum durch <strong>.bash_profile</strong> überschrieben wird. Das gilt allerdings nicht, wenn du dich als <strong>root-Benutzer</strong> anmeldest - dann wird nur die Datei <strong>.profile</strong> gelesen. Der Grund ist, dass der Root-Benutzer nicht <strong>bash</strong> sondern <strong>sh</strong> ausführt, wodurch nur die <strong>~/.profile</strong>-Datei berücksichtigt wird.</p>
<p><img src="/2018/2018-08-24-die-os-x-bash/images/image-8.png" alt=""></p>
<p>Hierarchie der Bash-Konfigurations-Dateien</p>
<p>Daneben gibt es theoretisch auch die Möglichkeit, im Benutzerverzeichnis eine Datei mit dem Namen <strong>.bashrc</strong> anzulegen. Diese wird jedoch nur dann geladen, wenn Bash ausgeführt wird, ohne dass sich ein Benutzer dazu anmeldet (die sogenannte <em>non-login-shell</em>). Im OS X-Umfeld wird das aber nicht benötigt. Du kannst das erzwingen, indem du auf der Kommandozeile <strong>/bin/bash</strong> ausführst - wir wollen die jetzt schon komplizierte Geschichte aber nicht unnötigen verkomplizieren. ;)</p>
<h2 id="die-bash-aufhübschen">Die Bash aufhübschen</h2>
<p>Nach der langweiligen aber notwendige Theorie, gibts jetzt ein paar Zeilen Code, mit denen die Kommandozeile gleich viel besser aussieht. Ich hab aus oben genannten Gründen das Ganze in die Datei <strong>~/.profile</strong> gepackt. Zunächst einmal ein paar Aliase um die Verzeichnislisten etwas übersichtlicher zu gestalten oder auch das oft benutzte <strong>cd</strong> (<em>change dir</em>) zu vereinfachen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">alias l=&#39;ls -alCFGA&#39;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">alias ll=&#34;ls -CFGla&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">alias h=&#34;history&#34;
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">alias .=&#34;cd ~&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">alias ..=&#34;cd ..&#34;
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">alias ...=&#34;cd ../..&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"># -p: erzeuge Unterverzeichnis, falls sie nicht existieren
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"># -v: gebe erzeugtes Verzeichnis zurück
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">alias mkdir=&#34;mkdir -pv&#34;
</span></span><span class="line"><span class="ln">10</span><span class="cl"># grep Ausgabe farbig gestalten
</span></span><span class="line"><span class="ln">11</span><span class="cl">alias grep=&#39;grep --color=auto&#39;
</span></span><span class="line"><span class="ln">12</span><span class="cl">alias fgrep=&#39;fgrep --color=auto&#39;
</span></span><span class="line"><span class="ln">13</span><span class="cl">alias egrep=&#39;egrep --color=auto&#39;
</span></span><span class="line"><span class="ln">14</span><span class="cl"># das aktuelle Verzeichnis im Finder öffnen
</span></span><span class="line"><span class="ln">15</span><span class="cl">alias f=&#39;open -a Finder ./&#39;
</span></span></code></pre></div><p>Die folgende Zeile ist kein Alias sondern eine Funktion. Damit wird ein Verzeichnis (mit allen benötigten Unterverzeichnissen erstellt) und dann mit cd direkt in das Verzeichnis gewechselt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mcd () { mkdir -p &#34;$1&#34; &amp;&amp; cd &#34;$1&#34;; }
</span></span></code></pre></div><p>Als nächstes will ich die Darstellung der zuletzt benutzten Befehle (<strong>history</strong> bzw. jetzt <strong>h</strong>) etwas anpassen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># Duplikate ignorieren
</span></span><span class="line"><span class="ln">2</span><span class="cl">HISTCONTROL=ignoreboth
</span></span><span class="line"><span class="ln">3</span><span class="cl"># Befehle anhängen und die Historie nicht jedes mal neu überschreiben
</span></span><span class="line"><span class="ln">4</span><span class="cl">shopt -s histappend
</span></span><span class="line"><span class="ln">5</span><span class="cl"># die maximale Größe bzw. Länge der Historie erhöhen
</span></span><span class="line"><span class="ln">6</span><span class="cl">HISTSIZE=1000
</span></span><span class="line"><span class="ln">7</span><span class="cl">HISTFILESIZE=2000
</span></span></code></pre></div><p>Der folgende Befehl sorgt dafür, dass sich die Anzahl der dargestellten <strong>Spalten und Zeilen</strong> an die Fenstergröße anpasst. Die Funktion sollte per default aktiviert sein, zur Sicherheit legen wir das hier trotzdem fest! Mit dem Parameter -u kann die Option übrigens wieder deaktiviert werden.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">shopt -s checkwinsize
</span></span></code></pre></div><p>Hiermit wird das Aussehen und die Farbe der Kommandozeile geändert. Ich hab mich für eine relativ bunte Variante entschieden. Die Einstellung für den sog. Prompt wird in der globalen Variable <strong>PS1</strong> (<em>prompt statement 1</em>) gespeichert. Die folgenden Parameter sind hier geläufig:</p>
<ul>
<li>\u - Benutzername</li>
<li>\h - Name des Hosts / Computers</li>
<li>\w - der komplette aktuelle Pfad</li>
<li>\n  - Ein Zeilenumbruch</li>
</ul>
<p>Mit <strong>PS2</strong>, <strong>PS3</strong>, <strong>PS4</strong> lassen sich noch andere Prompts konfigurieren, wie z.B. der für interaktive Eingaben in Bash-Scripten. Die Variable <strong>PROMPT_COMMAND</strong> wird sogar noch vor <strong>PS1</strong> dargestellt. Wer mehr dazu erfahren möchte, <a href="https://wiki.ubuntuusers.de/Bash/Prompt/#source-2">schaut einfach mal dort vorbei</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">export</span> <span class="n">PS1</span><span class="o">=</span><span class="s2">&#34;$(date +%k:%m:%S) \[</span><span class="se">\033</span><span class="s2">[36m\]\u\[</span><span class="se">\033</span><span class="s2">[m\]@\[</span><span class="se">\033</span><span class="s2">[32m\]\h:\[</span><span class="se">\033</span><span class="s2">[33;1m\]\w\[</span><span class="se">\033</span><span class="s2">[m\]\$ &#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"># Diese Konstanten steuern die Farben für die Ausgabe von cd.</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">export</span> <span class="n">CLICOLOR</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">export</span> <span class="n">LSCOLORS</span><span class="o">=</span><span class="n">ExFxBxDxCxegedabagacad</span>
</span></span></code></pre></div><p>Das ganze sieht dann so aus:</p>
<p><img src="/2018/2018-08-24-die-os-x-bash/images/image-9.png" alt=""></p>
<p>Eine bunte aber informative Kommandozeile</p>
<p>Diese Funktion zeigt alle Prozesse, die unter dem aktuellen Benutzer aktiv sind:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">me() { ps $@ -u $USER -o pid,%cpu,%mem,start,time,bsdtime,command ; }
</span></span></code></pre></div><p>Als nächstes ein paar Aliase um das Netzwerk ein bisschen einfacher im Griff zu behalten:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl"># alle Verbindungen, die gerade &#34;Lauschen&#34;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">alias cons=&#39;sudo lsof -i | grep LISTEN&#39;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"># alle offenen Sockets
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">alias socks=&#39;sudo /usr/sbin/lsof -i -P&#39;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"># alle offenen TCP/IP-Sockets
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">alias tsocks=&#39;lsof -i&#39;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"># alle offenen UDP-Sockets
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">alias usocks=&#39;sudo /usr/sbin/lsof -nP | grep UDP&#39;
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"># alle offenen TCP-Sockets
</span></span><span class="line"><span class="ln">10</span><span class="cl">alias lsocks=&#39;sudo /usr/sbin/lsof -nP | grep TCP&#39; 
</span></span><span class="line"><span class="ln">11</span><span class="cl"># grundlegende Netzwerkeinstellungen
</span></span><span class="line"><span class="ln">12</span><span class="cl">alias net=&#39;ipconfig getpacket en0&#39;
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"># den DNS-Cache leeren
</span></span><span class="line"><span class="ln">15</span><span class="cl">alias cleardns=&#39;dscacheutil -flushcache&#39;
</span></span></code></pre></div><p>Die ganzen Inhalte gibt es hier noch einmal in kompakter Version:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">case</span> <span class="o">$-</span> <span class="ow">in</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="p">)</span> <span class="p">;;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      <span class="o">*</span><span class="p">)</span> <span class="k">return</span><span class="p">;;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">esac</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">alias</span> <span class="n">l</span><span class="o">=</span><span class="s1">&#39;ls -alCFGA&#39;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">alias</span> <span class="n">ll</span><span class="o">=</span><span class="s2">&#34;ls -CFGla&#34;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">alias</span> <span class="n">h</span><span class="o">=</span><span class="s2">&#34;history&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">alias</span> <span class="o">.=</span><span class="s2">&#34;cd ~&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">alias</span> <span class="o">..=</span><span class="s2">&#34;cd ..; pwd&#34;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">alias</span> <span class="o">...=</span><span class="s2">&#34;cd ../..; pwd&#34;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">alias</span> <span class="n">mkdir</span><span class="o">=</span><span class="s2">&#34;mkdir -pv&#34;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">alias</span> <span class="n">grep</span><span class="o">=</span><span class="s1">&#39;grep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">alias</span> <span class="n">fgrep</span><span class="o">=</span><span class="s1">&#39;fgrep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">alias</span> <span class="n">egrep</span><span class="o">=</span><span class="s1">&#39;egrep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">alias</span> <span class="n">f</span><span class="o">=</span><span class="s1">&#39;open -a Finder ./&#39;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">HISTCONTROL</span><span class="o">=</span><span class="n">ignoreboth</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">shopt</span> <span class="o">-</span><span class="n">s</span> <span class="n">histappend</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">HISTSIZE</span><span class="o">=</span><span class="mi">1000</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">HISTFILESIZE</span><span class="o">=</span><span class="mi">2000</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="n">shopt</span> <span class="o">-</span><span class="n">s</span> <span class="n">checkwinsize</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="k">case</span> <span class="s2">&#34;$TERM&#34;</span> <span class="ow">in</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">xterm</span><span class="o">-</span><span class="n">color</span><span class="o">|*-</span><span class="mi">256</span><span class="n">color</span><span class="p">)</span> <span class="n">color_prompt</span><span class="o">=</span><span class="n">yes</span><span class="p">;;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="n">esac</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="k">export</span> <span class="n">PS1</span><span class="o">=</span><span class="s2">&#34;$(date +%k:%m:%S) \[</span><span class="se">\033</span><span class="s2">[36m\]\u\[</span><span class="se">\033</span><span class="s2">[m\]@\[</span><span class="se">\033</span><span class="s2">[32m\]\h:\[</span><span class="se">\033</span><span class="s2">[33;1m\]\w\[</span><span class="se">\033</span><span class="s2">[m\]\$ &#34;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="k">export</span> <span class="n">CLICOLOR</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="k">export</span> <span class="n">LSCOLORS</span><span class="o">=</span><span class="n">ExFxBxDxCxegedabagacad</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="n">mcd</span> <span class="p">()</span> <span class="p">{</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&#34;$1&#34;</span> <span class="o">&amp;&amp;</span> <span class="n">cd</span> <span class="s2">&#34;$1&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="n">me</span><span class="p">()</span> <span class="p">{</span> <span class="n">ps</span> <span class="o">$</span><span class="err">@</span> <span class="o">-</span><span class="n">u</span> <span class="o">$</span><span class="n">USER</span> <span class="o">-</span><span class="n">o</span> <span class="n">pid</span><span class="p">,</span><span class="o">%</span><span class="n">cpu</span><span class="p">,</span><span class="o">%</span><span class="n">mem</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">bsdtime</span><span class="p">,</span><span class="n">command</span> <span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="n">alias</span> <span class="n">cons</span><span class="o">=</span><span class="s1">&#39;sudo lsof -i | grep LISTEN&#39;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="n">alias</span> <span class="n">socks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -i -P&#39;</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="n">alias</span> <span class="n">tsocks</span><span class="o">=</span><span class="s1">&#39;lsof -i&#39;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="n">alias</span> <span class="n">usocks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -nP | grep UDP&#39;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="n">alias</span> <span class="n">lsocks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -nP | grep TCP&#39;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="n">alias</span> <span class="n">net</span><span class="o">=</span><span class="s1">&#39;ipconfig getpacket en0&#39;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="n">alias</span> <span class="n">cleardns</span><span class="o">=</span><span class="s1">&#39;dscacheutil -flushcache&#39;</span>
</span></span></code></pre></div>
        
        
        <div class="tags">
          <p><strong>Tags:</strong> profile, alias, bash, mac, os-x, shell</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>os-x</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Die OS X - Bash - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item><item>
      <title>Speicherplatz-Verbraucher grafisch darstellen</title>
      <link>https://nickyreinert.de/2011/2011-07-03-speicherplatz-verbraucher-grafisch-darstellen/</link>
      <pubDate>Sun, 03 Jul 2011 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2011/2011-07-03-speicherplatz-verbraucher-grafisch-darstellen/</guid>
      <description>Unter Windows diente mir noch der wunderbare TotalCommander samt des Plugins DirSizeCalc, um die größten Verbraucher von Speicherplatz auf meiner Festplatte …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Der Artikel stellt das kostenlose Tool `DiscInventory X` für macOS vor, mit dem sich der Speicherplatzverbrauch auf der Festplatte grafisch analysieren lässt. Es wird als Alternative zum TotalCommander-Plugin `DirSizeCalc` für Windows positioniert und seine Hauptfunktionen werden aufgelistet.</p>
          
          
          <p><strong>Hauptthemen:</strong> macOS, Software, Festplattenverwaltung, System-Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> beginner</p>
          
        </div>
        
        
        <p>Unter Windows diente mir noch der wunderbare <a href="http://www.ghisler.com/deutsch.htm">TotalCommander</a> samt des Plugins <a href="http://www.totalcmd.net/plugring/dirsizecalc.html">DirSizeCalc</a>, um die größten Verbraucher von Speicherplatz auf meiner Festplatte grafisch darzustellen. Bei MacOS muss ich mich (vorerst) mit dem Finder als Dateimanager zufrieden geben. Doch auch für den Mac gibt es eine nette kostenlose Lösung namens <a href="http://www.derlien.com/">DiscInventory X</a>.</p>
<p><img src="/2011/2011-07-03-speicherplatz-verbraucher-grafisch-darstellen/images/DiscInventoryX-150x150.png" alt="DiscInventoryX"></p>
<p>Was kann DiscInventoryX?</p>
<ul>
<li>farblich sortiert und entsprechend der Größenverhältnisse skalierte Anzeige der Dateien</li>
<li>bei Klick auf ein &ldquo;Kästchen&rdquo; wird die Datei im Baum angezeigt</li>
<li>direktes Löschen der Dateien oder Anzeige im Finder</li>
<li>Anzeige aller Dateien einer bestimmten Kategorie</li>
<li>Anzeige der Ordnergröße samt Inhalt</li>
<li>Anzeige, wie viel Platz Dateien bestimmten Typs verbrauchen bzw. wie viele Dateien davon existieren</li>
</ul>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> macOS, Tool, Software, Festplatte</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>tools</category>
      
      <category>anleitungen</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/DiscInventoryX-150x150.png" type="image/jpeg">
        <media:title>Speicherplatz-Verbraucher grafisch darstellen - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item>
  </channel>
</rss>