<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>2021s auf Nicky Reinert</title>
    <link>https://nickyreinert.de/2021/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Sun, 31 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/2021/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;1/2)</title>
      <link>https://nickyreinert.de/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/</link>
      <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/</guid>
      <description>SHA-256 (Secure Hash Algorithm) ist der Name einer “kryptologischen Hashfunktion”. SHA-256 ist Teil einer ganzen Gruppe von Algorithmen, mit dem gleichen Ziel: …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel behandelt Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;1/2) und bietet praktische Einblicke in das Thema.</p>
          
          
          <p><strong>Hauptthemen:</strong> Web, IT, Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>SHA-256 (Secure Hash Algorithm) ist der Name einer “kryptologischen Hashfunktion”. <a href="https://de.wikipedia.org/wiki/SHA-2">SHA-256 ist Teil einer ganzen Gruppe von Algorithmen</a>, mit dem gleichen Ziel: Die Erzeugung eines Hashes, der resistent gegen Kollisionen ist, dessen Berechnung nur in eine Richtung funktioniert und eine feste Länge hat. Im folgenden Artikel beschreibe ich die einzelnen Schritte die der Algorithmus vornimmt, um einen Hash zu erzeugen.</p>
<p><em>Im ersten Teil kümmern wir uns um die Vorbereitungen, im <a href="https://nickyreinert.de/blog/2021/10/31/wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/">zweiten Teil</a> geht es an den eigentlichen Algorithmus. Der Sourcecode</em> <a href="https://gist.github.com/nickyreinert/00d631fe9a90108924b1df6e911c8cd5"><em>liegt auf Github</em></a><em>.</em></p>
<h3 id="was-wirst-dulernen">Was wirst du lernen?</h3>
<p>Neben dem Erzeugen eines SHA-256 wirst du hier vor allem den Umgang mit binären Zahlen und binäre Rechenoperationen wie <strong>XOR</strong>, <strong>AND</strong> usw kennenleren. Ich gehe allerdings davon aus, dass ein Grundverständnis für binäre Zahlen vorhanden ist, der Fokus liegt auf dem Algorithmus. <strong>10</strong> sollte in deinem Kopf also entweder für die <strong>zehn</strong> oder eine <strong>zwei</strong> stehen. (Oder auch <strong>zwölf</strong>, wenn du das <strong>Duodezimalsystem</strong> magst.)</p>
<h3 id="vorwort">Vorwort</h3>
<p>Bricht man das auf eine maximal laienhafte Beschreibung herunter, passiert bei einer krytpologischen Hash-Funktion das folgende: Ein Ausgangs-Text <strong>beliebiger</strong> Länge wird so verarbeitet, dass daraus einen Ergebnis-Text (<em>der</em> <em>Hash</em>) mit der <strong>immer gleichen</strong> Länge entsteht. Es ist nahezu unmöglich, aus dem Hash den Ausgangs-Text zu berechnen. Außerdem kann man fast sicher davon ausgehen, dass jeder Ausgangs-Text <strong>einen anderen Hash</strong> erzeugt. Ändere ich nur ein Zeichen, wirkt sich das drastisch auf den Ausgangs-Text aus. Ein derartiger Algorithmus ist daher zB prädestiniert, Texte, sprich Nachrichten, zu verfizieren. Man spricht deswegen auch von einer Prüfsumme.</p>
<p>Und das ist die Grundlage einer Technologie, die in jüngster Vergangenheit immer mehr von sich Reden macht: Die <strong>Blockchain</strong>, Basis für Kryptowährungen wie zB den <strong>Bitcoin</strong>. Bei der Blockchain sind, und auch das nur laienhaft heruntergebrochen, die Einträge des “Kassenbuches” sicher vor Manipulation, weil eben die Änderung eines historischen Wertes (zB Buchungsvorganges) unweigerlich eine drastische Änderung der daraus erzeugten Prüfsummen nach sich ziehen würde. Um den Blockchain-Apologeten gleich den Wind aus den Segeln zu nehmen zitiere ich mal Fefe, sinngemäß: <a href="https://ptrace.fefe.de/Blockchain/#46">Es geht auch einfacher</a>. Ich gebrauche Bitcoin hier auch nur als Buzzword, aus Marketing-Gründen. :]</p>
<p>Um dich nun aber auch zum Weiterlesen zu motivieren, ein wichtiger Hinweis:</p>
<p>Der Algorithmus wird dazu verwendet, die nächsten Einträge der Blockchain zu berechnen. Genau genommen wird hier ein bestimmter Hash vorgegeben, der errechnet werden soll (das berüchtigte <em>Mining</em>). Die Belohnung für die korrekte Berechnung sind Bitcoins. Das Problem: Diese Berechnung ist <strong>sehr,</strong> <strong>sehr aufwendig</strong>, denn wie schon oben geschrieben: Sie funktioniert nur in eine Richtung. Die <em>Miner</em> müssen also unsagbar viele Berechnungen durchführen, um einen Ziel-Wert zu errechnen. Und der Miner, der die Berechnung am schnellsten ausführt, wird dafür auch belohnt. Gelingt es dir also, wider erwarten, den Algorithmus zu optimieren, kannst du im Mining-Business ganz groß rauskommen. Das klingt doch nach einer Herausforderung, oder? ;)</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/images/image2.png" alt=""></p>
<p>Quelle: <a href="https://peakd.com/deutsch/@marcus0alameda/dagobert-gold-bitcoin-perfektion">https://peakd.com/deutsch/@marcus0alameda/dagobert-gold-bitcoin-perfektion</a></p>
<blockquote>
<p>Disclaimer: Ich habe den ganzen Algorithmus in Python nachgebaut. Python ist aus Performance-Sicht sicher nicht die beste Option, um SHA-256 zu berechnen und der Umgang mit binären oder hexadezimalen Werten ist etwas unbequem. Python eignet sich dank Jupyter aber am ehesten dazu, einen komplexen Algorithmus Schritt-für-Schritt zu beschreiben.</p></blockquote>
<h3 id="einführung">Einführung</h3>
<p>Bevor wir uns an die Schleifen machen, müssen wir uns um ein paar Funktionen kümmern, die wir später dazu nutzen, um <strong>binäre Zahlen</strong> ein wenig durchzumischen.</p>
<blockquote>
<p>Hinweis 1: Ich verzichte im folgenden auf die Präfixe der Zahlensystem, wie zB 0b für binär, um den Text übersichtlich zu halten. Ich gehe davon aus, dass folgendes bekannt ist: 0 =&gt; Falsch und 1 =&gt; Wahr</p></blockquote>
<blockquote>
<p>Hinweis 2: Im Kontext von SHA-256 entspricht ein Wort (bzw word) genau 32 Bit. In der Regel entspricht 1 Word = 2 Byte = 16 Bit.</p></blockquote>
<h4 id="das-explizite-oderxor">Das explizite Oder (XOR)</h4>
<p>Das explizite Oder (<strong>Entweder-Oder</strong>) ist ein elementarer logischer, bitweise Operator. Der Ausgang der Operation ist nur dann wahr, wenn exakt ein Zustand wahr ist (im Vergleich dazu ist das Ergebnis bei dem “einfachen“ <strong>OR</strong> übrigens dann wahr, wenn mindestens ein Operand wahr ist oder beide).</p>
<p>Es werden also zwei Werte folgendermaßen verarbeitet:</p>
<p><img src="images/image.png" alt=""></p>
<p>XOR: nur wenn genau ein Wert wahr (1) ist, ist die entsprechende Stelle im Ergebnis wahr (1)</p>
<p>Die Implementierung in Python erfolgt mit dem <strong>Zirkumflex</strong>:</p>
<p># 110 ^ 100<br>
# 010</p>
<h4 id="das-logische-undand"><strong>Das logische Und (AND)</strong></h4>
<p>Der AND-Operator ist ebenfalls recht geläufig und vergleichsweise simpel. Analog zu XOR ist das Ergebnis wahr, wenn exakt beide (bzw. alle) Operanden wahr sind.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/images/image-4.png" alt=""></p>
<p>AND: Nur wenn beide Werte einer Stelle wahr sind, ist die Stelle im Ergebnis wahr</p>
<p>Die Implementierung in Python erfolgt mit dem <strong>kaufmännischen Und</strong>:</p>
<p># 110 &amp; 100<br>
# 100</p>
<h4 id="die-negierung-nope">Die Negierung (Nope?)</h4>
<p>Jetzt wirds seltsam: Auch dafür gibt es einen Operator: Der bitweise Operator <strong>Negierung</strong> dreht Werte um. Aus 0 wird 1, aus 1 wird 0.</p>
<p><img src="images/image-3.png" alt=""></p>
<p>Die Negierung kehrt Werte bitweise um. Nicht mehr aber auch nich weniger.</p>
<p>Die Implementierung in Python erfolgt mit der <strong>Tilde —</strong> meinem Lieblingszeichen!</p>
<p># ~110<br>
# 001</p>
<h4 id="die-shift-operation"><strong>Die Shift-Operation</strong></h4>
<p>Die Shift-Funktion ist eine elementare binäre Rechenoperation, bei der die einzelnen Stellen eines binären Werts <strong>nach links oder rechts geschoben</strong> werden. Die freien Stellen auf der jeweils anderen Seite werden mit 0 aufgefüllt.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/images/image-6.png" alt=""></p>
<p>Shift nach links um eine Stelle, aus 6 wird 12</p>
<p>Und jetzt gibt es hoffentlich einen positiven Knick in der Lernkurve: Wenn du genau hinschaust, fällt dir etwas auf und lass mich dir versichern, es handelt sich nicht um einen Zufall: 12 ist das Produkt aus 6 und 2. Das deutet auf ein interessanten Nebeneffekt: Ein Shift kommt einer Multiplikation bzw. Division mit 2 gleich. Ein Shift um mehrere Stellen entspricht demnach einer Multiplikation mit einer Potenz zur Basis 2 besteht. Klingt kompliziert, deswegen ein Beispiel:</p>
<p>Anstatt 139 * 2 ^17 kannst du die binäre Darstellung von 139, also 10001011, um 17 Stellen nach links shiften. Das Ergebnis: 1000101100000000000000000. Zähl gerne nach, rechts der 1 eins gibt es jetzt 17 Nullen.</p>
<p>In Python ist der binäre Shift mit dem <strong>Doppelpfeil</strong> implementiert:</p>
<p># 110 &raquo; 1<br>
# 011</p>
<p># 110 &laquo; 2<br>
# 000</p>
<h4 id="die-rotate-funktion">Die Rotate-Funktion</h4>
<p><strong>Rotate</strong> bedeutet, dass ein die Werte einer (binären) Zahl in eine Richtung verschoben werden. Und das erklärt man am besten an einem Beispiel. Die folgende Zahlenreihe soll um einen Zähler nach links rotiert werden. Die Zahl auf der linken Seite fällt also heraus und wir rechts wieder angehangen. Die anderen Zahlen rücken eine Position nach links.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/images/image-5.png" alt=""></p>
<p>Rotate eines binären Wertes um eine Stelle nach links, aus 6wird 5</p>
<p>Das funktioniert in beide Richtungen und mit beliebig vielen Stellen. Die entsprechende Funktion (<a href="https://stackoverflow.com/a/59005609/2360229">Kudos an so</a>) sieht so aus:</p>
<p>def rotate(value, rotations, width = 32):<br>
if int(rotations) != abs(int(rotations)):<br>
rotations = width + int(rotations)<br>
return (int(value) &laquo; (width - (rotations%width)) | (int(value) &raquo; (rotations % width))) &amp; ((1 &laquo; width) - 1)</p>
<h4 id="die-sigma-funktionen">Die Sigma-Funktionen</h4>
<p>Insgesamt werden vier sogenannte <strong>Sigma-Funktionen</strong> verwendet. <strong>σ0</strong> und <strong>σ1</strong> (das kleine Sigma) bzw. <strong>Σ0</strong> und <strong>Σ1</strong> (das große Sigma, vielen bekannt als das Summen-Zeichen). Alle funktionen werden mit einem binären Wert aufgerufen und geben diesen binären Wert in veränderter Form zurück.</p>
<p>σ0 (<strong>sigma0</strong>) läuft folgendermaßen ab:</p>
<ul>
<li>der Ausgangs-Wert wird um 7 <strong>Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>18 Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>3 Stellen</strong> nach <strong>rechts geshifted</strong></li>
</ul>
<p>Daraus entstehen drei unterschiedliche Werte, die miteinander <strong>XOR-Verknüpft</strong> werden. Die Funktion dazu in Python:</p>
<p>def sigma0(word):<br>
part1 = bin(rotate(int(word, 2), 7, 32))<br>
part2 = bin(rotate(int(word, 2), 18, 32))<br>
part3 = bin(int(word, 2) &raquo; 3)<br>
return bin(int(part1, 2) ^ int(part2, 2) ^ int(part3, 2))[2:].zfill(32)</p>
<blockquote>
<p><strong>Wichtiger Hinweis</strong>: Ich arbeite mit bin() und in(s, 2), um die Ausgaben und Eingaben leserlich und vor allem nachvollziehbar zu machen. Außerdem sorge ich mit [2:] dafür, dass die binäre Darstellung ohne <strong>0b</strong> auskommt. Das kommt dem Lernzweck zugute, da die binären Operationen an dezimalen Werten schwerer nachvollziehbar sind. Mit zfill(32) (<strong>zero fill</strong>) wird der binäre Wert nach links um so viele Nullen erweitert, um immer <strong>32 Stellen</strong> zu umfassen. Teilweise erleichtert das die Übersicht, andererseits erfüllt das später auch eine Längen-Vorgabe. Die obere Funktion kann also auch folgendermaßen vereinfacht werden:</p></blockquote>
<p>def sigma0(word):<br>
part1 = rotate(word, 7, 32)<br>
part2 = rotate(word, 18, 32)<br>
part3 = word &raquo; 3<br>
return part1 ^ part2  ^ part3</p>
<p>Bei σ1 (<strong>sigma1</strong>) sieht es ganz ähnlich aus:</p>
<ul>
<li>der Ausgangs-Wert wird um <strong>17 Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>19 Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>10</strong> <strong>Stellen</strong> nach <strong>rechts geshifted</strong></li>
</ul>
<p>Daraus entstehen drei unterschiedliche Werte, die miteinander <strong>XOR-Verknüpft</strong> werden. Die Funktion dazu in Python:</p>
<p>def sigma0(word):<br>
part1 = bin(rotate(int(word, 2), 7, 32))<br>
part2 = bin(rotate(int(word, 2), 18, 32))<br>
part3 = bin(int(word, 2) &raquo; 3)<br>
return bin(int(part1, 2) ^ int(part2, 2) ^ int(part3, 2))[2:].zfill(32)</p>
<p>Nun zu Σ0 (<strong>Sigma0</strong>). Auch hier keine großen Überaschungen, hier nun ohne <strong>Shift:</strong></p>
<ul>
<li>der Ausgangs-Wert wird um <strong>2 Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>13 Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>22</strong> <strong>Stellen</strong> nach <strong>rechts rotiert</strong></li>
</ul>
<p>Auch hier werden die jeweiligen Ergebnisse final <strong>XOR-Verknüpftg</strong>. In Python also:</p>
<p>def upper_sigma0(word):<br>
part1 = bin(rotate(int(word, 2), 2, 32))<br>
part2 = bin(rotate(int(word, 2), 13, 32))<br>
part3 = bin(rotate(int(word, 2), 22, 32))<br>
return bin(int(part1, 2) ^ int(part2, 2) ^ int(part3, 2))[2:].zfill(32)</p>
<p>Kommen wir zum letzten Teilnehmer unserer illustren griechischen Runde: Σ1 (<strong>Sigma1</strong>):</p>
<ul>
<li>der Ausgangs-Wert wird um <strong>6</strong> <strong>Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>11Stellen</strong> nach <strong>rechts rotiert</strong></li>
<li>der Ausgangs-Wert wird um <strong>25</strong> <strong>Stellen</strong> nach <strong>rechts rotiert</strong></li>
</ul>
<p>Und am Ende wieder die XOR-Verknüpfung. Python:</p>
<p>def upper_sigma1(word):<br>
part1 = bin(rotate(int(word, 2), 6, 32))<br>
part2 = bin(rotate(int(word, 2), 11, 32))<br>
part3 = bin(rotate(int(word, 2), 25, 32))<br>
return bin(int(part1, 2) ^ int(part2, 2) ^ int(part3, 2))[2:].zfill(32)</p>
<h4 id="wahl-undmehrheit">Wahl und <strong>Mehrheit</strong></h4>
<p>Bleiben wir noch etwas bei den Griechen und wechseln in die Politik: Die Wahl und die Mehrheit, englisch: <strong>choose</strong> und <strong>majority</strong>.</p>
<p>Choose ist eine etwas komplexere Funktion, die drei binäre Werte verarbeitet und zwar wieder bitweise. Die Funktion geht durch die jeweiligen Stellen (x) des ersten Eingangswerts und prüft:</p>
<ul>
<li>Wenn <strong>x = 1</strong> dann nimm <strong>y</strong></li>
<li>Wenn <strong>x = 0</strong> dann nimm <strong>z</strong></li>
</ul>
<p>Y und z stehen für die jeweiligen Stellen des zweiten und dritten Eingangswertes. Wie kann man das programmatisch lösen? So:</p>
<p>def choose(word1, word2, word3):<br>
bin_word1 = (int(word1, 2))<br>
bin_word2 = (int(word2, 2))<br>
bin_word3 = (int(word3, 2))<br>
return bin((bin_word1 &amp; bin_word2) ^ (~bin_word1 &amp; bin_word3))[2:].zfill(32)</p>
<p>Zunächst werden also Wert 1 und Wert 2 logisch UND-verknüpft. Dann wird die Negierung von Wert 1 mit Wert 3 UND-verknüpft. Die beiden Zwischensummen werden abschließend durch XOR gejagt.</p>
<p>Majority prüft ganz einfach für jede Stelle der drei Eingangs-Werte, welcher Wert, 1 oder 0, häufiger vorkommt. Das sieht in Python so aus — hier erklär ich die logischen Operationen jetzt nicht noch mal, es werden einfach XOR und AND verknüpft:</p>
<p>def majority(word1, word2, word3):<br>
bin_word1 = (int(word1, 2))<br>
bin_word2 = (int(word2, 2))<br>
bin_word3 = (int(word3, 2))<br>
return bin((bin_word1 &amp; bin_word2) ^ (bin_word1 &amp; bin_word3) ^ (bin_word2 &amp; bin_word3))[2:].zfill(32)</p>
<p><strong>Primzahlen?</strong></p>
<p>Um noch ein anderes beliebtes Feld der Arithmetik abzudecken, lasst uns noch kurz über Primzahlen reden. Primzahlen sind mystisch. Und damit genau richtig für unser irdisches Vorhaben, das Mining zu optimieren.</p>
<p>SHA-256 nutzt Primzahlen als Grundlage für den Algorithmus. Was nicht bedeutet, dass das Ergebnis durchschaubar wäre.</p>
<p>Wir fangen mal mit den ersten 64 Primzahlen an und bauen daraus einen Satz Konstanten. Selbstverständlich in Bitform.</p>
<p>first_64_prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311]</p>
<p>Diese werden nun aber auch noch ordentlich durch die Mangel genommen. Warum das erforderlich ist, kann ich nicht nachvollziehen. Aus meiner Sicht ist es ziemlich egal, welche Konstanten man verwendet werden, da sie immer gleich sind (deswegen ja <strong>konstant</strong>, diesmal übrigens aus dem lateinischen). Dahinter steckt also kein großes Geheimins.</p>
<p>Aus den 64 Primzahlen wird zuerst jeweils die dritte Wurzel gezogen. Dann wird der natürliche Teil entfernt (sprich alles vor dem Komma) und das Ergebnis mit 2³² (aka 4.294.967.296, was übrigens auch der Anzahl verfügbarer IPv4-Adressen entspricht — der 2. positive Knick in der heutigen Lernkurve?) multipliziert. Wie du oben ja gelernt und hoffentlich noch nicht vergessen hast, ist die Mulitplikation mit 2^32 ja eigentlich gar nicht so aufwendig im Bituniversum.</p>
<p>Das Ergebnis wird jedenfalls auf eine natürlich Zahl abgerundet — sprich alle Nachkommastellen entfernt. Wiederholt man das für die restlichen 63 Primzahlen, erhält man eine wohlgeformte Liste mit 64 Einträgen, die in etwa so aussehen, am Beispiel der notorischen Primzahl 2:</p>
<p>01000010100010100010111110011000</p>
<p>Oder als Hex-Wert:</p>
<p>0x428a2f98</p>
<p>Und im Dezimal-Zahlensystem:</p>
<p>1.116.352.408</p>
<p>Die Funktion dafür sieht folgendermaßen aus:</p>
<p>result_constants = []<br>
for prime_number in first_64_prime_numbers:<br>
cube_root = prime_number ** (1./3.)<br>
frac_part = cube_root - floor(cube_root)<br>
product = frac_part * (2**32)<br>
floored_product = floor(product)<br>
result_constants.append(bin(floored_product)[2:].zfill(32))</p>
<p>Das ganze nennen wir <strong>Ergebnis-Konstante</strong>, denn diese Liste ist der Anfang unsere finalen Ausgabe. Diese Liste heben wir gut auf und weil die Arbeit mit Primzahlen so befreiend ist, veranstalten wir für die ersten 8 Primzahlen einen ähnlichen Zirkus. Mit einem Unterschied: Als Grundlage dient diesmal die Quadrat-Wurzel:</p>
<p>compression_constants = []<br>
for prime_number in first_8_prime_numbers:<br>
square_root = prime_number ** (1./2.)<br>
frac_part = square_root - floor(square_root)<br>
product = frac_part * (2**32)<br>
floored_product = floor(product)<br>
compression_constants.append(bin(floored_product)[2:].zfill(32))</p>
<p>Die Namen haben übrigens eine Bedeutung, auf die ich später noch eingehe.</p>
<h3 id="epilog">Epilog</h3>
<p>Die Vorbereitungen sind damit abgeschlossen und wir können uns <a href="https://nickyreinert.de/blog/2021/10/31/wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/">im zweiten Teil</a> dem eigentlichen Algorithmus widmen.</p>

        
        
      ]]></content:encoded>
      
      
      
      <category>anleitungen</category>
      
      <category>blog</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;1/2) - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item><item>
      <title>Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;2/2)</title>
      <link>https://nickyreinert.de/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/</link>
      <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/</guid>
      <description>Wenn du den ersten Teil erfolgreich verarbeitet hast, bist du bestens gewappnet, um in diesem Teil zu erfahren, wie die einzelnen Komponenten bzw. Funktionen …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel behandelt Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;2/2) und bietet praktische Einblicke in das Thema.</p>
          
          
          <p><strong>Hauptthemen:</strong> Web, IT, Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>Wenn du <a href="https://nickyreinert.de/blog/2021/10/31/wie-funktioniert-der-sha256-algorithmusim-detail-teil-1-2/">den ersten Teil</a> erfolgreich verarbeitet hast, bist du bestens gewappnet, um in diesem Teil zu erfahren, wie die einzelnen Komponenten bzw. Funktionen nun zusammenspielen.</p>
<h3 id="vorbemerkung">Vorbemerkung</h3>
<p>Bevor es los geht möchte ich noch einmal die Zusammenhänge verdeutlichen: Wir werden gleich eine Nachricht (<strong>Message</strong>) erzeugen, deren Länge einem Vielfachen von <strong>512 Bit</strong> entspricht; im Beispiel genau <strong>512 Bit</strong>. Die Nachricht wird in <strong>Message-Blocks</strong> zerlegt, die exakt <strong>512 Bit</strong> lang sind. Jeder Message-Block wird wiederum zu einer <strong>Message-Schedule</strong> zerlegt, mit <strong>16 Wörtern</strong> (Words) zu je <strong>32 Bit</strong> Länge. Die Länge der Wörter muss und wird immer <strong>32 Bit</strong> sein! Der Message-Schedule wird dann aber erweitert, um <strong>64 Wörter zu</strong> enthalten. Seine Länge dann: <strong>2.048 Bit</strong>. Und grafisch:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-2.png" alt=""></p>
<p>Wichtige Zusammenhänge</p>
<h3 id="dekompressions">Dekompressions</h3>
<p>Wir wollen also aus einer Nachricht eine <strong>SHA-256</strong>-konforme Prüfsumme, den Hash, berechnen. Dazu muss die Nachricht, also der String, zunächst vorbereitet werden. Unsere Nachricht ist, klischeegerecht:</p>
<p>message = &lsquo;hello_world&rsquo;</p>
<p>Zunächst müssen wir für jeden Buchstabend die Position in der Zeichentabelle herausbekommen, sprich die Buchstaben (bzw genauer jedes Zeichen) in ihre numerische Repräsentation umwandeln:</p>
<p>dec_message = []<br>
for char in message:<br>
dec_message.append(ord(char))</p>
<p>Das Ergegnis ist eine Liste mit Integern:</p>
<p>[104, 101, 108, 108, 111, 95, 119, 111, 114, 108, 100]</p>
<p>Und da wir im ersten Teil so viel Spaß am Umgang mit binären Werten hatten, wandeln wir die Liste in binäre Werte um, die wir schlicht miteinander verknüpfen:</p>
<p>bin_message = &rsquo;&rsquo;<br>
for decimal in dec_message:<br>
bin_message += &lsquo;0&rsquo; + bin(decimal)[2:</p>
<p>Das Ergebnis:</p>
<p>0110100001100101011011000110110001101111010111110111011101101111011100100110110001100100</p>
<p>Hier gibt es allerdings eine Stolperfalle, und es widerstrebt mir das so stehen zu lassen, für die ich noch keine Erklärung gefunden habe: Bei der Umwandlung in die binäre Entsprechung stellen wir jedem binären Wert eine 0 voran. Aus <strong>104</strong> wird also nicht <strong>1101000</strong> sondern <strong>01101000</strong>, uswf.</p>
<p>Außerdem hängen wir an dieses Datum eine 1 heran, sozusagen als Trennzeichen für das, was jetzt gleich kommt.</p>
<p>Als nächstes berechnen wir die Länge dieser binären Zahl:</p>
<p>len_bin_message = len(bin_message)</p>
<p>Die Längenangabe darf bzw muss exakt <strong>64 Bit</strong> belegen. Wir wandeln sie also auch in eine binäre Zahl um hängen vorne ein paar Nullen ran um genau 64 Stellen zu erhalten:</p>
<p>rest_to_64 = 64 - len(bin(len_bin_message)[2:])</p>
<p>bin_message_len = &lsquo;0&rsquo; * rest_to_64 + bin(len_bin_message)[2:]</p>
<p>Nun müssen wir diese drei binären Informationen, Nachricht, trennende Eins und Längenangabe nicht nur verbinden, sondern auch mit so vielen Nullen auffüllen, damit die Gesamtlänge ein vielfaches von 512 ist.</p>
<p>payload = bin_message + &lsquo;1&rsquo; + bin_message_len</p>
<p>len_payload = len(payload)</p>
<p>pad_string = int(512 - (len_payload % 512))</p>
<p>full_message = bin_message + &lsquo;1&rsquo; + (&lsquo;0&rsquo; * pad_string) + bin_message_len</p>
<p>In unserem Beispiel belegen die drei Informationen 153 Bit. Wir müssen also 359 Nullen dazupacken. Genau genommen kommen die zwischen Nachricht und Längenangabe. Das Ergebnis ist immer <strong>n* 512 Bits</strong> lang:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-8.png" alt=""></p>
<p>Aufbau einer vorkodierten Nachricht</p>
<p>Zu guter Letzt nehmen wir diese sehr, sehr, sehr, sehr….sehr, sehr große Zahl (sie ist sehr groß, du solltest sie auch nicht als Zahl sehen, sondern als <strong>Bitfolge</strong>!) und teilen sie in sogenannte Message Blocks mit einer Länge von jeweils <strong>512 Bits</strong> auf:</p>
<p>message_block_length = 512<br>
message_blocks = [full_message[i:i+message_block_length] for i in range(0, len(full_message), message_block_length)]</p>
<p>Schnapp dir einen Kaffee, geh noch mal frische Luft schnappen, schüttel den Stuhl aus. Jetzt geht es los.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/beer.jpg" alt=""></p>
<p>8 Bits sind keine Bitfolge</p>
<h3 id="die-schleife">Die Schleife!</h3>
<p>Da es einfacher ist, den Vorgang ohne Schleife zu erklären, hier nur eine Schleife. Die programmatische Schleife findest du trotzdem auf <a href="https://gist.github.com/nickyreinert/00d631fe9a90108924b1df6e911c8cd5"><strong>Github</strong></a>.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-9.png" alt=""></p>
<p>Es folgt: Eine Schleife</p>
<p>Da unsere Nachricht genau 512 Bit groß ist und wir auch ohne Schleife arbeiten, können wir direkt in die Vollen gehen: Die mühsam zusammengeklebte Nachricht wird nun in den sog. Message Schedule zerlegt: Sprich in <strong>16 Wörter</strong> mit jeweils 32 Bit Länge.</p>
<p>Im ersten Durchlauf nehmen wir vier Wörter und führen folgende Modifikationen aus:</p>
<ul>
<li><strong>σ1</strong> wird auf <strong>Wort 1</strong> an Position 14 angewendet,</li>
<li><strong>Wort 2</strong> von Position 9 bleibt unverändert,</li>
<li><strong>σ0</strong> wird auf <strong>Wort 3</strong> an Position 1 angewendet und</li>
<li><strong>Wort 4</strong> an Position 0 bleibt wieder unberührt</li>
</ul>
<p>Die Werte werden zunächst addiert und jetzt gibt es wieder einen <strong>wichtigen Punkt</strong> zu beachten: Wir müssen strikt dafür sorgen, dass die Wörter nicht länger als <strong>32 Bit</strong> sind. Denn nur so können wir sicherstellen, dass der finale Hash immer die gleiche länge hat. Und spätestens jetzt, bei der <strong>Addition großer Werte</strong>, können wir die <strong>32 Bit</strong> recht schnell überschreiten. Das ist auch aus technischer Sicht eine Hürde. Deswegen gilt: Hier und bei allen Additionen müssen wir abschließend <strong>Modulo 2</strong>³² anwenden. Und jetzt kommt der dritte hoffentlich positive Knick in der Lernkurve: Auch für Modulo hält das binäre Universum eine schöne Vereinfachung parat: <strong>Das logische Und</strong> mit 2³²–1 (bzw 4.294.967.295, das ist eine sehr große Zahl, nicht so groß wie die im ersten Teil, sondern genau einen Zähler kleiner) führt zum gleichen Ergebnis.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-5.png" alt=""></p>
<p>Berechnung des ersten Schritts</p>
<p>Damit wäre der Message-Schedule vorbereitet und enthält nun <strong>64 wunderschöne Wörter</strong> zu <strong>je 32 Bit</strong>. Wir haben die Informationen aus dem Message Block also zunächst aufgeplustert und von <strong>512 Bit auf 2.048 Bit</strong> erweitert- sie sind aber immer noch lesbar:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-6.png" alt=""></p>
<p>Der erweiterte Message Schedule</p>
<p>Aber damit ist jetzt Schluss, wir kommen zum nächsten und wichtigsten Schritt:</p>
<h3 id="die-kompression">Die Kompression</h3>
<p>Der erweiterte Message-Schedule wird in diesem Schritt nicht direkt modifiziert, die Wörter werden vielmehr als Grundlage für die Modifikation der anfangs erzeugten <strong>Kompressions-Konstanten</strong> verwendet.</p>
<p>In 64 Schleifen-Durchläufen gehen wir durch den Message-Schedule. Aus jedem Wort des Schedules (also unserer ursprünglichen Nachricht) wird zusammen mit den <strong>64 Ergebnis-Konstanten</strong> und den <strong>8 Kompressions-Konstanten</strong> ein neues Wort berechnet. Das neue Wort wird dann den Kompressions-Konstanten vorangestellt, gleichzeitig wird der letzte Eintrag gelöscht. So enthält die Liste immer genau 8 Einträge.</p>
<p>new_compression_constants = compression_constants.copy()</p>
<p>for i, word in enumerate(message_schedule):</p>
<pre><code>term1 = (int(upper\_sigma1(new\_compression\_constants\[4\]), 2) + \\  
            int(choose(new\_compression\_constants\[4\], new\_compression\_constants\[5\], new\_compression\_constants\[6\]), 2) + \\  
            int(new\_compression\_constants\[7\], 2) + \\  
            int(result\_constants\[i\], 2) + \\  
            int(word, 2)) \\  
            &amp; int('11111111111111111111111111111111', 2)

term2 = (int(upper\_sigma0(new\_compression\_constants\[0\]), 2) + \\  
            int(majority(new\_compression\_constants\[0\], new\_compression\_constants\[1\], new\_compression\_constants\[2\]), 2)) &amp; int('11111111111111111111111111111111', 2)

new\_compression\_constants.insert(0, 1)  
new\_compression\_constants.pop()

new\_compression\_constants\[0\] = bin(  
            (term1 + term2) &amp; int('11111111111111111111111111111111', 2)  
            )\[2:\].zfill(32)

new\_compression\_constants\[4\] = bin(  
            (int(new\_compression\_constants\[4\], 2) + term1) &amp; int('11111111111111111111111111111111', 2)  
            )\[2:\].zfill(32)
</code></pre>
<p>Zunächst ein paar Berechnungen:</p>
<ul>
<li><strong>Term 1</strong> berechnet sich aus den Kompressions-Konstanten, einer der Ergebnis-Konstanten und dem jeweiligen Wort. Wir verwenden hier auf Bitebene und <strong>Σ1</strong> (upper_sigma1) sowie <strong>choose</strong>.</li>
<li><strong>Term 2</strong> ist eine Summe zweier anderer Kompressions-Konstanten, die mithilfe von <strong>Σ0</strong> (upper_sigma0) sowie <strong>majority</strong> modifiziert werden.</li>
</ul>
<p>Und jetzt achte mal drauf, dass die ursprüngliche Nachricht Teil des 1. Terms ist — in der Abbildung rot markiert:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-3.png" alt=""></p>
<p>Im ersten Schritt erfolgt die Berechnung zweier Terme</p>
<p>Die beiden Terme werden nun wiederum addiert (und wie immer mit <strong>Modulo 2³²</strong> auf 32 Bit-Kurs gebracht) und an den Anfang der Kompressions-Konstanten gestellt. Der erste Term wird außerdem mit der 4. Position dieser nun 9 Wörter langen List summiert:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-1.png" alt=""></p>
<p>Im zweiten Schritt wird die Listse der Kompression-Konstanten aktualisiert</p>
<p>Als nächstes wird der letzte Eintrag der Liste gelöscht, sie umfasst nun <strong>8 komplett neue Kompressions-Konstanten</strong> (wenn du aufmerksam aufgepasst hast, wird dir nicht entgangen sein, dass sie gar nicht mal so konstant sind).</p>
<p>Ein Teil der ursprünglichen Nachricht befindet sich nun an als <strong>Summand von Term 1</strong> and den <strong>Positionen 0 und 4</strong> und. Diese werden in den nächsten Durchläufen Teil der gleichen Berechnungen und immer weiter nach unten rutschen. So verteilt sich die ursprüngliche, bisher noch halbwegs lesbare Nachricht, über die gesamte Liste.</p>
<p>Diese Liste ist also die Grundlage für den zweiten Durchlauf, der sie erneut “durchrotiert”, um wiederum eine komplett neue Liste für den dritten Durchlauf zu erzeugen. Und so weiter, bis alle 64 Wörter des Message-Schedules verarbeitet wurden. Das Ergebnis sollte in etwa so aussehen:</p>
<p>11100010000000010111101011011001<br>
01000110110100101000001000010100<br>
11100011111110010111100001001011<br>
01110001100001100000010000011110<br>
01001000000111100100000000011000<br>
00011111110001101011001000110101<br>
11101001110010001101110111110100<br>
00001001011011110000111011111011</p>
<p>Oder in Hexadezimal:</p>
<p>0xe2017ad9 0x46d28214 0xe3f9784b 0x7186041e 0x481e4018 0x1fc6b235 0xe9c8ddf4 0x96f0efb</p>
<p>Abschließend gehen wird durch genau diese Liste der 8. Kompressions-Konstanten und addieren jede Positionen mit dem entsprechenden Wort der Ausgangs-Liste:</p>
<p>result = []</p>
<p>for i in range(0, 8):</p>
<pre><code>result.append(  
    bin(int(compression\_constants\[i\], 2) +   
    int(new\_compression\_constants\[i\], 2)  &amp;      
    int('11111111111111111111111111111111', 2))\[2:\].zfill(32))
</code></pre>
<p>Und im Klartext:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-4.png" alt=""></p>
<p>Letzter Schritt: Addieren der Listen</p>
<p>Die neue Liste ist nun die <strong>Ausgangs-Liste</strong> für den nächsten Message-Schedule. Da wir die Schleife hier aber nicht implementieren, war es das fürs erste. Im Folgenden noch mal eine beispielhafte Zusammenfassung der Schritte:</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/screenshot-7.png" alt=""></p>
<p>Schematische Darstellung des SHA-256 Algorithmus’</p>
<h3 id="haschee-gesundheit-was">Haschee. Gesundheit. Was?</h3>
<p>Wir haben es geschafft. Du hast es geschafft. Herzlichen Glückwunsch.</p>
<p><img src="/2021/2021-10-31-wie-funktioniert-der-sha256-algorithmusim-detail-teil-2-2/images/not-bad.jpg" alt=""></p>
<p>Quelle: memecreator.org</p>
<p>Nun können wir den Hash entweder als Hex-Wert ausgeben oder wieder in binärer Schreibweise darstellen, je nach Anwendungszweck.</p>
<p>for word in result:</p>
<pre><code>print(hex(int(word, 2))\[2:\].zfill(8) + '', end = '')
</code></pre>
<p>Das Ergebnis kann sich in jedem Fall sehen lassen.</p>
<p>35072c1ae546350e0bfa7ab11d49dc6f129e72ccd57ec7eb671225bbd197c8f1</p>
<p>Oder</p>
<p>110101000001110010110000011010111001010100011000110101000011101011111110100111101010110001111010100100111011100011011111001010011110011100101100110011010101011111101100011111101011110011100010010001001011011101111010001100101111100100011110001</p>
<h3 id="epilog">Epilog</h3>
<p>Eine komplette Implementierung, inklusive einer Schleife, um auch große Nachrichten zu verarbeiten, findest <a href="https://gist.github.com/nickyreinert/00d631fe9a90108924b1df6e911c8cd5">du in diesem Gist</a>.</p>
<p>Freilich ist Python nicht dazu geeignet, den SHA-256 Prozess zu optimieren, wohl aber um den Prozess zu verstehen und den Umgang mit elementaren binären Rechenoperation zu lernen.</p>
<p>Willst du den Prozess noch etwas interaktiver nachvollziehen, möchte ich dir <a href="https://www.youtube.com/watch?v=f9EbD6iY9zI">dieses Video</a> empfehlen. Dort wird der Algorithmus in Ruby nachgebaut und die einzelnen Rechenschritte auch etwas genauer erklärt.</p>
<p>Und warum ist SHA-256 für das Mining von Kryptowährungen jetzt so wichtig? Kurz: Der Hash validiert die Gültigkeit des <em>Kassenbuches</em>. Beim Mining geht es darum, aus einer gegebenen Nachricht und einem frei wählbaren Zusatz exakt einen gegebenen Ziel-Hash zu berechnen. Der Algorithmus muss also wahnsinng oft durchlaufen werden. Da das sehr aufwendig ist, kostet das Zeit und wird entsprechend belohnt.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> bitcoin, mining, sha</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>anleitungen</category>
      
      <category>blog</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Wie funktioniert der SHA256 Algorithmus…im Detail? (Teil&amp;nbsp;2/2) - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item><item>
      <title>Maze!</title>
      <link>https://nickyreinert.de/2021/2021-04-21-maze-game/</link>
      <pubDate>Wed, 21 Apr 2021 08:01:31 +0100</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2021/2021-04-21-maze-game/</guid>
      <description>&ldquo;Maze&rdquo; ist ein in JavaScript geschriebenes Browser-Spiel, bei dem es darum geht, in möglichst kurzer Zeit ein Labyrinth zu lösen. Das Labyrinth …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine kurze Vorstellung des Browser-Spiels &#34;Maze&#34;, das in JavaScript geschrieben wurde. Ziel des Spiels ist es, ein Labyrinth in kürzester Zeit zu lösen. Der Artikel erwähnt Konfigurations- und Exportmöglichkeiten und verlinkt auf das Spiel.</p>
          
          
          <p><strong>Hauptthemen:</strong> JavaScript, Browser-Spiel, Game-Development, Projekte</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> beginner</p>
          
        </div>
        
        
        <p>&ldquo;Maze&rdquo; ist ein in JavaScript geschriebenes Browser-Spiel, bei dem es darum geht, in möglichst kurzer Zeit ein Labyrinth zu lösen. Das Labyrinth lässt sich mit verschiedenen Parameter steuern und sogar exportieren.</p>
<p><a href="https://nickyreinert.github.io/maze/">https://nickyreinert.github.io/maze/</a></p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> JavaScript, Game, Projekt, Maze</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>projekte</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Maze! - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>project_showcase</dc:type>
      
      
    </item><item>
      <title>Augenblicke - Eine statistische Analyse des Flirt-Portals der BVG</title>
      <link>https://nickyreinert.de/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/</guid>
      <description>Was ist &ldquo;Augenblicke&rdquo;? Im Frühjahr 2006, mehr als 6 Jahre bevor Tinder die Herzen der Smarthphone-Besitzer im Sturm eroberte, startete die BVG auf …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel behandelt Augenblicke - Eine statistische Analyse des Flirt-Portals der BVG und bietet praktische Einblicke in das Thema.</p>
          
          
          <p><strong>Hauptthemen:</strong> Web, IT, Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <h2 id="was-ist-augenblicke">Was ist &ldquo;Augenblicke&rdquo;?</h2>
<p>Im Frühjahr 2006, mehr als 6 Jahre bevor <strong>Tinder</strong> die Herzen der Smarthphone-Besitzer im Sturm eroberte, startete die BVG <a href="https://www.bvg.de/de/Meine-BVG/Meine-Augenblicke/Alle-Augenblicke">auf ihrer Seite ein Portal mit dem Namen &ldquo;<strong>Augenblicke</strong>&rdquo;</a>. Im Gegensatz zu Tinder sind sich die Nutzer von <em>Augenblicke</em> in der Regel aber ziemlich sicher schon einmal über den Weg gelaufen - nämlich in einer der zahlreichen Fahrzeuge der BVG oder S-Bahn.</p>
<p><em><strong>Augenblicke</strong></em> will diese verlorenen Seelen nun zusammenbringen. Wer beim ersten Treffen nicht den Mut aufgebracht hat, das Gegenüber anzusprechen, darf das später mit einer Nachricht auf dem Portal nachholen. Das geschieht unter der Angabe eines <strong>Pseudonyms</strong>, <strong>ein paar Zeilen Text</strong>, <strong>der Tram-, Bus- oder Bahn-Linie</strong> und natürlich dem <strong>Zeitpunkt</strong>, wann man sich über den Weg gelaufen ist - der sogenannte und namensgebende <strong>Augenblick</strong>. Das Prinzip ist also recht einfach. Nach einem verhaltenen Start Anfang 2006 dauerte es erstmal einige Zeit, bis sich ein gewisser Erfolg zeigte.</p>
<p><em>(Hinweise zur Methodik und Fehlerquellen am Ende)</em></p>
<h2 id="kleinermannmitbart">KleinerMannMitBart</h2>
<p><a href="https://www.bvg.de/de/Meine-BVG/Meine-Augenblicke/Alle-Augenblicke?act=read-moment&amp;id=2846">Zum allerersten Augenblick</a> kam es an einem <strong>Valentinstag</strong>: Am 14. Februar 2006 um 5 Uhr traf es <strong>KleinerMannMitBart</strong> in der <strong>Buslinie 284</strong>:</p>
<blockquote>
<p>&ldquo;Du (blond, grüne Augen, schlank)&rdquo;</p>
<p>KleinerMannMitBart, 14. Februar 2006</p></blockquote>
<p>Der Dienst dümpelte dann eine Weile vor sich hin, bevor er in der Öffentlichkeit nachhaltig wahrgenommen wird. Erst in 2007 nahm das Portal tatsächlich <em>fahrt</em> auf: die monatliche Beitragszahl stieg auf über 100. Der vorläufige Höhepunkt wurde <strong>im Mai 2018 mit 291 Beiträgen</strong> im Monat erreicht, fast 10 Gesuche pro Tag! Doch dann war der Hype schon wieder vorbei, das <strong>Ende der fetten Flirtjahre</strong>:</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-21.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-21-700x435.png" alt=""></a></p>
<p>Anzahl Beiträge / Jahr nach Anbieter</p>
<p>Der Abwärtstrend ist insofern überraschend, da die Zahl der tatsächlichen Fahrgäste in den letzten Jahren stetig zunimmt.</p>
<p>Bis Januar 2021 haben die Besucher in 240 verschiedenen <strong>Linien der BVG, S-Bahn und sogar Deutschen Bahn (Regio!)</strong> <strong>genau 20.108 Augenblicke</strong> erlebt. Zu den meisten Begegnungen kommt es den <strong>U-Bahnen und S-Bahnen</strong>:</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-2.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-2-700x367.png" alt=""></a></p>
<p>Wenn man etwas mehr ins Detail geht, zeigt sich, dass die <strong>U-Bahn</strong> mit <strong>8.149 Einträgen</strong> leicht vorne liegt, dicht gefolgt von der <strong>S-Bahn</strong> (<strong>6.581</strong>)</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-3.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-3-700x803.png" alt=""></a></p>
<p>Für dieses Ranking kann es übrigens drei Erklärungen geben:</p>
<ol>
<li>Entweder gibt es mehr Singles, die bevorzugt die U-Bahn benutzen, oder</li>
<li>die Fahrt unter der Erde ermutigt die Menschen eher zum Flirten.</li>
<li>Oder die Menschen sind in der U-Bahn besonders schüchtern und müssen daher vermehrt auf dieses Portal zurückgreifen.</li>
</ol>
<h2 id="trakl-und-2151-anonyme">Trakl und 2.151 Anonyme</h2>
<blockquote>
<p>[&hellip;]Ihr Lächeln, mal amüsiert, gelegentlich auch erstaunt, aber immer von feinster Anmut - ach, es macht(e)mich zufrieden. Nun, die hellen Tage [&hellip;]</p>
<p>Takl am 21. März 2011 in der M1</p></blockquote>
<p><em>Trakl</em> ist nicht nur der Name eines expressionistischen Dichters aus Österreich. Der Name taucht auch auf der Plattform auf und ist mit <strong>39 Einträgen</strong> das am meisten genutzte <strong>Synonym</strong>. Insgesamt wurden <strong>12.298 verschiedene Pseudonyme</strong> genutzt. <strong>2.151 Benutzer</strong> <strong>haben keinen Namen</strong> angeben. Das ist die Top-10 der beliebtesten Namen auf dem Portal:</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-4.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-4-700x210.png" alt=""></a></p>
<p>Schaut man sich an, auf welchen Linien <em>die Autoren:innen</em> unterwegs waren, kommt schnell der Verdacht auf, dass es sich jeweils um ein und dieselbe Personen handelt.</p>
<p>Natürlich lässt der Datensatz auch Rückschlüsse auf die <strong>genau Uhrzeit</strong> oder die <strong>exakte</strong> <strong>Linienbezeichnung</strong> und damit vermutlich sogar eine <strong>Pendelstrecke</strong> zu. <em>Aus Gründen</em> möchte ich diese Details hier nicht weiter vertiefen.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-6.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-6-700x184.png" alt=""></a></p>
<h2 id="tageszeiten-und-wochentage">Tageszeiten und Wochentage</h2>
<p>Zurück zur grauen Masse und der Frage: <strong>Zu welcher Tageszeit</strong> und an welchem Wochentag sind die Portal-Nutzer am aktivsten? Zunächst zum offensichtlichen: Die Pendlerzeiten liegen zwischen 7 und 9 Uhr sowie 16 und 19 Uhr. An den Werktagen zeigt sich, dass die Bereitschaft zu Flirten am müden Morgen noch relativ gering ist. Abends, zum Feierabendverkehr - kommt es dagegen zu sehr vielen Kontakten.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-7.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-7-700x768.png" alt=""></a></p>
<p>Beiträge je Wochentag und Tageszeit</p>
<p>Wenig überraschend sieht es am Wochenende etwas anders aus. Hier verlagert sich die Anzahl der Einträge zunächst auf den frühen Nachmittag.</p>
<p>Ein kurzer Blick auf die Stimmung der Beiträge: Eine klare Tendenz lässt sich hier nicht erkennen. In den frühen Morgenstunden scheint die Stimmung stärker zu schwanken als Abends.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-9.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-9-700x771.png" alt=""></a></p>
<p>Stimmung im Wochenverlauf (-1: negativ, 1: positiv)</p>
<h2 id="textanalyse">Textanalyse</h2>
<p>Zunächst ein grober Überblick über die Stimmung im Verlauf der Jahre sowie die durchschnittliche Länge der Beiträge und Wortanzahl.</p>
<p>Die Wortlänge über alle Nachrichten hat sich im Laufe der Jahre kaum verändert. Die Ausschläge zu Beginn der Messung sind auf die geringe Fallzahl zurückzuführen. Danach sind es zwischen 70 und 80 Wörter pro Nachricht. Ab Ende 2014 gibt es einen kurzlebigen Aufwärtstrend in Richtung 90 Wörter pro Eintrag.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-10.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-10-700x364.png" alt=""></a></p>
<p>Zwischen 2011 und 2014 lässt sich ein kleines Stimmungstief erkennen. In 2020 gibt es noch mal einen deutlichen Knick - Auswirkungen von Corona? Auch die (durchschnittliche) Länge der Nachrichten und die Wortanzahl scheint ab 2015 leicht zu steigen.</p>
<p>Die nächste Abbildung zeigt die Stimmung aller Autoren:innen sowie die Objektivität ihrer Nachrichten. Die Objektivität liefert kaum Erkenntnisgewinn und wird hier nur einmal erwähnt. Interesssanter ist die Stimmung, die in den allermeisten Fällen positiv ist, mitunter sogar stark positiv.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-11.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-11-700x435.png" alt=""></a></p>
<p>Stimmung und Objektivität aller Autoren</p>
<p>Weiter geht es mit der Stimmung nach Fahrzeugklasse. Die Abbildung zeigt neben der Stimmung auch die Anzahl der Beiträge (blaue Punkte). So dürfte sich die relativ hohe mittlere Stimmung bei den Nachtbussen erklären. Insgesamt lässt sich vielleicht festhalten, dass die Stimmung in den S- und U-Bahnen sowie Regionalzügen am geringsten ist.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-13.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-13-700x562.png" alt=""></a></p>
<p>Das passt zu der Erkenntnis oben, dass Beiträge mit Bezug zu z.B. Bussen vergleichsweise selten vorkomen: <strong>Sind die Menschen dort glücklicher und demnach vor Ort kontaktfreudiger</strong>?</p>
<p>Die <strong>längsten Nachrichten</strong> mit den <strong>meisten Wörtern</strong> kommen übrigens nicht aus den Linien-Favoriten S-Bahn oder U-Bahn. Nein, es sind Regionalbahnen und die Nacht-Busse, die sich offenbar äußerst fruchtbar auf die Fantasie der Fahrgäste auswirken. Eine Erklärung: Hat man hier mehr Zeit zum Schreiben?</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-15.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-15-700x463.png" alt=""></a></p>
<p>Noch mal zurück zur Auswertung der Stimmung. Für das folgende Histogramm habe ich die Stimmungswerte in 0,05 Schritten geclustert um deutlich zu machen, in welchem Bereichen sich die Stimmung der meisten Nachrichten bevorzugt zeigt. Hier ist ganz klar eine Dominanz im neutralen Bereich (0) bis hin zu mittelmäßig positiv (0,5) zu erkennen.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-16.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-16-700x454.png" alt=""></a></p>
<p>Lässt man sich die Cluster im Tagesverlauf anzeigen, dass die Stimmung fast gleichmäßig verteilt zu sein scheint. Nur am Freitag gibt es im Bereich um 0,2 eine höhere Konzentration an Nachrichten (je dunkler die Farbe, desto mehr Nachrichten in diesem Cluster):</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-18.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-18-700x556.png" alt=""></a></p>
<h2 id="phrasen-und-wörter">Phrasen und Wörter</h2>
<p>Zum Abschluss noch ein kleiner Blick auf beliebte Phrasen und Wörter. Zunächst alle Wörter (die mindestens 1.000 mal gezählt wurden):</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-19.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-19-700x285.png" alt=""></a></p>
<p>Wenig überraschend sind hier beschreibende Wörter wie <strong>Auge, Haar, Jacke</strong>, <strong>Braune</strong>, <strong>Rucksack</strong> oder <strong>Mantel</strong> zu finden. Interessant auch: Das Wort <strong>leider</strong> wird über <strong>6.000</strong> mal verwendet. Nachvollziehbar: Die Plattform ist ja eine Anlaufstelle, für verpasste Chancen. Das absolut häufigste Wort ist <strong>haben</strong> mit über 22.000 Vorkommen. Zur Erklärung: Da die Wortstämme gezählt werden, fallen darunter auch <strong>hat, hast, habe</strong> usw. Sprich: <strong>Ich habe dich gesehen, hast du mich gesehen</strong>.</p>
<p>Nun noch ein kurzer Blick auf die beliebtesten Phrasen:</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/grafik-20.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/grafik-20-700x315.png" alt=""></a></p>
<p>Sehr schön gefällt mir hier das Vorkommen von &ldquo;<strong>unsere Blicke</strong>&rdquo; - was sich nicht nur wunderbar auf den Namen des Portals - Augenblicke - sondern auch seinen Zweck beziehen lässts. Ansonsten finden sich hier natürlich auch naheliegende, beschreibende Phrasen. Es geht ja um die &ldquo;Personensuche&rdquo;: <strong>Blonde Haare, dein Lächeln, schwarze Jacke</strong>.</p>
<h2 id="methodik-und-fehlerquellen">Methodik und Fehlerquellen</h2>
<h3 id="datenerfassung-und-grobes-datenmodell">Datenerfassung und grobes Datenmodell</h3>
<p>Um die Beiträge <a href="https://www.bvg.de/de/Meine-BVG/Meine-Augenblicke/Alle-Augenblicke">von der Hauptseite</a> abzugreifen, nutze ich ein in <strong>PHP</strong> geschriebenes Script (<a href="https://github.com/nickyreinert/crawl-augenblicke">crawl-augenblicke auf Github</a>). In einer <strong>MySQL</strong>-Tabelle speichere ich dann den <strong>Titel der Nachricht</strong>, den <strong>Nachrichten-Text</strong>, den <strong>Verfasser der Nachricht</strong>, das <strong>Datum</strong> an dem die Nachricht verfasst wurde sowie das <strong>Datum, an dem der &ldquo;Augenblick&rdquo; stattgefunden</strong> hat. Dazu wird die <strong>URL</strong> zum Beitrag sowie die <strong>Linie</strong> erfasst. Zusätzlich nutze ich einige selbstgeschriebene <strong>MySQL-Funktionen</strong>, um die <strong>Anzahl der Wörter im Titel</strong> und dem <strong>Nachrichten-Text</strong> sowie die <strong>Differenz zwischen den beiden Zeitpunkten</strong> zu erfassen. Ein paar eigene Views erleichtern das anfängliche Finden von Fehlern.</p>
<p>Daneben gibt es zwei weitere Tabellen mit Meta-Informationen. Dies ist zunächst eine <strong>Blacklist</strong>-Tabelle, die bei einer Aggregation der Wort-Häufigkeiten ignoriert werden sollen. Das betrifft nicht den Vorgang des Zählens der Wörter! In einer weiteren Tabelle wird eine <strong>Zuordnung der Linien</strong> zu den Linientypen sowie Subtypen festgehalten. Zu den Linientypen zählen nur Bus, Tram, Zug sowie Fähre. Anhand der Subtypen kann außerdem in besondere Liniengruppen unterschieden werden, wie z.B. Metro-Bus, Express-Bus usw.</p>
<p><a href="https://www.nickyreinert.de/files/augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/datenbankschema.png"><img src="/2021/2021-01-21-augenblicke-eine-statistische-analyse-des-flirt-portals-der-bvg/images/datenbankschema-300x182.png" alt="Datenbankschema"></a></p>
<p>Datenbankschema</p>
<p>Mit einem <strong>Python-Script</strong> lese ich den Datensatz ein und bereinige die Texte. Stoppwörter werden aussortiert, Steuerzeichen, HTML-Entitites und andere Störquellen werden entfernt. Dann berechen ich für jedes Wort die <strong>IDF</strong> (<strong>Inverse Document Frequency</strong>) nach der Formel <strong>log 1 + (doc_count_total / doc count with word occurrence</strong>). Für die NLP-Aufgaben nutze ich das NLTK bzw. den <strong>HannoverTagger</strong> (<a href="https://nickyreinert.de/blog/2020/12/09/einfuehrung-in-stemming-und-lemmatisierung-deutscher-texte-mit-python/">siehe auch</a>). Für die Erkennung der Phrasen und der Stimmung nutze ich <strong>TextBlob</strong> mit deutschen <a href="https://github.com/markuskiller/textblob-de">Trainingsdaten von hier</a>.</p>
<h3 id="mögliche-fehlerquellen">Mögliche Fehlerquellen</h3>
<p>Grundsätzlich gibt es zwei Dinge zu beobachten: Die Auswertungen werden nicht in Relation zur tatsächlichen Anzahl der Fahrgäste der jeweiligen Linie betrachtet, da diese nur auf Jahresebene zu Verfügung stehen. Es kann also nur ein Vergleich der absoluten Zahlen stattfinden. In Relation betrachtet kann die Gegenüberstellung der Linien ein anderes Ergebnis liefern.</p>
<p>Außerdem kann die Anzahl der Einträge je Linie auf zwei Arten interpretiert werden: Die Passagiere sind in der Linie mit vielen Einträgen entsprechend flirtfreudiger und offener und deshalb kommt es auf der Plattform zu mehr Gesuchen. Oder aber es ist genau andersrum: Da die Menschen einer bestimmten Linie schüchterner sind, trauen sie sich erst im Nachhinein die Kontaktaufnahme über diese Plattform zu starten. Diese Erkenntnisse müssen also mit Vorsicht betrachtet werden.</p>
<p>Leider gab es im Laufe der Zeit einige technische Anpassungen auf den Seiten der BVG, die einige Analysen etwas erschweren bzw. verhindern. Das betrifft vor allem das Datum, an dem die Beiträge verfasst (<strong>date_posted</strong>) wurden. Es fällt auf, dass sehr viele Einträge offenbar am 13. August 2014 verfasst wurden, das Datum des Augenblicks (<strong>date_met</strong>) aber sehr lange zurück liegt, teilweise bis 2006. Das älteste Datum in date_posted ist der 30.06.2014, bei date_met allerdings der 14.02.2006. Die Vermutung ist also, dass das Datum, an dem der Beitrag verfasst wurde, erst ab Juni 2014 mit erfasst wurde. Im August hat man dann vermutlich alle älteren Beiträge auf das feste Datum, nämlich den 13.08.2014 gesetzt. Insgesamt betrifft das immerhin 15.560 Datensätze.</p>
<p>Die Stimmungsanalyse nutzt einen fertigen Trainingsdatensatz und ist nur so gut, wie die Qualität der Texte. Rechtschreibfehler und Umgangssprache können hierbei nur unzureichend erfasst werden.</p>
<h2 id="verwendete-technologie">Verwendete Technologie</h2>
<p>Für das Abgreifen des BVG-Portals verwende ich ein <a href="https://github.com/nickyreinert/crawl-augenblicke">PHP-Script</a>. Das Python-Script zur Normalisierung, Anreicherung und Bereinigung der Daten ist nicht öffentlich. Ganz offensichtlich verwende ich Wordpress. In einer früheren Variante habe ich zwei selbstgeschriebene Plugins verwendet. Das ist zum einen das Plugin für die Darstellung der <a href="https://github.com/nickyreinert/data-heatmap">HTML-Heatmap</a> sowie das Plugin für die <a href="https://github.com/nickyreinert/wordCloud-for-Wordpress">WordCloud</a>, basierend auf dem fantastischen wordCloud2.js von Tim Dream. Die Idee war, die Zahlen dynamisch zu aktualisieren. Mittlerweile bin ich auf einfache Screenshots von Tableau Public umgestiegen.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> analyse, augenblicke, berlin, bvg, oepnv, statistik, tinder</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>projekte</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Augenblicke - Eine statistische Analyse des Flirt-Portals der BVG - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item>
  </channel>
</rss>