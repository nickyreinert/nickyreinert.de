<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>2010s auf Nicky Reinert</title>
    <link>http://localhost:1313/2010/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Thu, 16 Sep 2010 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/2010/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Tutorial: Web-Scraping mit VBA - Teil 1</title>
      <link>http://localhost:1313/2010/2010-09-16-tutorial-web-scraping-mit-vba-teil-1/</link>
      <pubDate>Thu, 16 Sep 2010 00:00:00 +0000</pubDate>
      <author></author>
      <guid>http://localhost:1313/2010/2010-09-16-tutorial-web-scraping-mit-vba-teil-1/</guid>
      <description>In dieser kleinen Tutorial-Serie will ich anhand einer Online-Handy-Datenbank zeigen, wie man mit VBA Seiten aus dem Internet abruft und nach Informationen …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dies ist der erste Teil einer Tutorial-Reihe, die zeigt, wie man mit VBA in Excel Web-Scraping betreibt. Der Artikel erklärt die Grundlagen des Abrufens von Webseiten-Inhalten mittels &#39;WinHttpRequest&#39; und des Parsens von HTML, um eine Liste von Hersteller-Links von einer Handy-Datenbank-Website zu extrahieren.</p>
          
          
          <p><strong>Hauptthemen:</strong> VBA, Web-Scraping, Excel, HTML-Parsing, Automatisierung</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>In dieser kleinen Tutorial-Serie will ich anhand einer Online-Handy-Datenbank zeigen, wie man mit VBA Seiten aus dem Internet abruft und nach Informationen sucht, die sich dann in einer Tabelle abspeichern lassen. Warum VBA? Es gibt vermutlich elegantere Lösungen, doch Excel ist eine Software, die die meisten zuhause nutzen. Man benötigt also keine zusätzliche Entwicklungsumgebung. Außerdem hat diese Methode den  Vorteil, dass die Daten sofort zur weiteren Verarbeitung verfügbar sind. VBA ist vielleicht nicht die performanteste Programmiersprache, dafür aber relativ leicht zu beherrschen.</p>
<p><a href="http://www.rechtzweinull.de/archives/100-screen-scraping-wann-ist-das-auslesen-und-die-veroeffentlichung-fremder-daten-zulaessig.html">(FYI: Rechtliches zum Thema Web- oder Screen-Scraping)</a></p>
<p> 
Diese Artikelserie richtet sich an den fortgeschrittenen Nutzer. Für den Einsteiger gehe ich nicht auf grundlegendes Programmierwissen ein (was sind Klassen, welche Variablen-Typen bietet Excel, etc.pp.) und für den professionellen Softwareentwickler sind meine Codebeispiele vermutlich zu infantil. Ich habe aber die Erfahrung gemacht, dass VBA und Excel für kurzfristige und kleine Projekte dieser Art recht nützliche Hilfsmittel sind. Außerdem bin ich kein &ldquo;ausgebildeter Softwareentwickler&rdquo;, weshalb ich an der Stelle auch gleich darauf Hinweise, dass Verbesserungsvorschläge sehr gerne gesehen sind!</p>
<p>Welches wissen solltest du also mitbringen?  Da es um das Parsen von HTML-Code geht, solltest du zumindest Bescheid wissen, wenn ich von div- und a-Elementen und css-Klassen rede. Du solltest auch wissen, wie man in VBA Variablen deklariert oder was eine if-Abfrage ist.</p>
<p>Das Endergebnis ist eine Tabelle mit technischen Spezifikationen zu den Mobiltelefonen, die inside-handy.de listet. Insgesamt werden drei Routinen genutzt, die - in umgekehrter Reihenfolge des Vorgehens - folgende Aufgabe haben:</p>
<p>Die letzte Routine greift auf eine Liste von URL zu, die auf die Datenblätter der Geräte verweisen. Von dort wird der HTML-Quellcode nach den  technischen Informationen durchsucht.</p>
<p>Auf inside-handy.de sind die Geräte nach Herstellern sortiert. Jede Herstellerseite verweist auf die entsprechenden Geräte. Wir werden also jede Herstellerseite (bzw. den entsprechenden HTML-Code) zunächst nach den URL zu den Geräten durchsuchen. Diese Aufgabe übernimmt die zweite Routine bzw. Prozedur.</p>
<p>Die erste Routine schließlich liefert die Liste aller URL zu den Herstellern, die wir uns aus dem HTML-Code der Herstellerübersicht auf inside-handy.de laden. Und damit geht es nun los:</p>
<p>1. Die URL zu den Hersteller-Unterseiten auslesen - sub getManufacturer</p>
<p>1.1 Datei per HTTP von einem Server laden</p>
<p>Im ersten Schritt laden wir die komplette HTML-Datei in den Zwischenspeicher. Dazu gibt es mindesten zwei Methoden, die gängigste ist vermutlich die über <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa384106%28v=vs.85%29.aspx">WinHttpRequest</a>. Bevor du das nutzen kannst, musst du bei VBA unter Extras - Verweise jedoch erst die Microsoft HTML Object Library einbinden.</p>
<p>&lsquo;&lsquo;&lsquo;vba
Dim url As String
Dim result As String
Dim winHttpReq As Object
url = &ldquo;<a href="http://www.inside-handy.de/hersteller/handys%22">http://www.inside-handy.de/hersteller/handys"</a></p>
<p>Set winHttpReq = CreateObject(&ldquo;WinHttp.WinHttpRequest.5.1&rdquo;)
winHttpReq.Open &ldquo;GET&rdquo;, url, False
winHttpReq.send
result = winHttpReq.responseText
&rsquo;&rsquo;&rsquo;</p>
<p>Die Deklaration der Variablen erklärt sich von selbst. Nachdem ich eine Instanz vom WinHTTP-Objekt erzeugt habe, kann ich die Parameter übergeben. Dazu gehört neben der URL auch die Bestimmung des HTTP-Requests - nämlich GET. Der letzte, booleansche, Paramter gibt an, ob die Verbindung im asynchronen Modus geöffnet werden soll. Mit .send wird der Request tatsächlich ausgelöst und das Ergebni dann an die String-Variable result zurückgegeben. Dort befindet sich nun unser HTML-Code</p>
<p>Wir können unseren Request natürlich auch per POST absetzen und noch andere Header-Informationen anhängen:</p>
<p>&lsquo;&lsquo;&lsquo;vba
Set winHttpReq = CreateObject(&ldquo;WinHttp.WinHttpRequest.5.1&rdquo;)</p>
<p>winHttpReq.Open = &ldquo;Post&rdquo;, url, False
winHttpReq.setRequestHeader &ldquo;User-Agent&rdquo;, &ldquo;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&rdquo;
winHttpReq.setRequestHeader &ldquo;Content-type&rdquo;, &ldquo;application/x-www-form-urlencoded&rdquo;
winHttpReq.send (URLEncode(&ldquo;username=user1&amp;password=secret&rdquo;) )</p>
<p>result = winHttpReq.responseText
&rsquo;&rsquo;&rsquo;</p>
<p>So ist es z.B. möglich, Formulardaten zu übermitteln, um an eine passwortgeschützte Seite oder die Ergebnisseite einer Suche zu gelangen. Dabei werden die POST-Daten als weiterer Parameter beim Senden mitgegeben. Eine weitere Möglichkeit ist die Durchführung einer HTTP-Authentifizierung:</p>
<p>&lsquo;&lsquo;&lsquo;vba
Dim HTTPREQUEST_SETCREDENTIALS_FOR_SERVER As Boolean</p>
<p>winHttpReq.Open &ldquo;GET&rdquo;, url, False
winHttpReq.SetCredentials &ldquo;user&rdquo;, &ldquo;password&rdquo;, HTTPREQUEST_SETCREDENTIALS_FOR_SERVER
winHttpReq.send
&rsquo;&rsquo;&rsquo;</p>
<p>Neben dem winHttpRequest-Objekt gibt es noch eine weniger elegante Methoden, in dem direkt eine Instanz des Internet Explorers erzeugt wird:</p>
<p>&lsquo;&lsquo;&lsquo;vba
Dim sPostData As String
Dim bPostData() As Byte
Dim WebBrowser: Set WebBrowser = CreateObject(&ldquo;InternetExplorer.Application&rdquo;)</p>
<p>WebBrowser.Visible = True</p>
<p>sPostData = URLEncode(&ldquo;username=user1&amp;password=secret&rdquo;)
ReDim bPostData(Len(sPostData) - 1)
bPostData = StrConv(sPostDataData, vbFromUnicode)</p>
<p>WebBrowser.navigate url, 2 + 4 + 8, , bPostData, &ldquo;Content-type: application/x-www-form-urlencoded&rdquo;
Do While WebBrowser.Busy
DoEvents
Loop
result = WebBrowser.document.body.innerHTML
WebBrowser.Quit
&rsquo;&rsquo;&rsquo;</p>
<p>Da diese Methode - wie gesagt - nicht sonderlich elegant ist, werde ich aber nicht weiter darauf eingehen.</p>
<p>Nun zurück zu unserem Skript. Den HTML-Code der Seite haben wir nun erstmal in einen String gelegt. Damit wir das HTML-Dokument bequem lesen können, erzeugen wir ein HTML-Document, an das wir den HTML-Code übergeben:</p>
<p>&lsquo;&lsquo;&lsquo;vba
Set HTMLDoc = New HTMLDocument
Set HTMLDoc = CreateObject(&ldquo;htmlfile&rdquo;)
HTMLDoc.Open
HTMLDoc.write (CStr(result))
HTMLDoc.Close
&rsquo;&rsquo;&rsquo;</p>
<p>Auch hier erklärt sich der Code fast von selber: Eine Instanz des Objektes erzeugen, diese Instanz zum &ldquo;Befüllen&rdquo; vorbereiten, den String übergebne und die Instanz wieder &ldquo;schließen&rdquo;. Soweit, so unkompliziert. Im nächsten Schritt geht es nun direkt an das Parsen des Quellcodes um die Links zu den Herstellerseiten zu erhalten. Die Schleife dazu ist nicht sehr aufwendig:</p>
<p>&lsquo;&lsquo;&lsquo;vba
Dim oneElement1, allElements1 As IHTMLElementCollection
Dim oneElement2, allElements2 As IHTMLElementCollection
Dim oneElement3, allElements3 As IHTMLElementCollection</p>
<pre><code>Worksheets(&quot;srcURL&quot;).Range(&quot;a2&quot;).Select
i = 0
Set allElements1 = HTMLDoc.getElementsByTagName(&quot;a&quot;)
      
i = 0
For Each oneElement1 In allElements1
    If oneElement1.parentElement.className = &quot;h\_img&quot; Then
        If oneElement1.parentElement.parentElement.ID = &quot;h\_alle&quot; Then
            If InStr(1, oneElement1.getAttribute(&quot;href&quot;), &quot;/tablets&quot;) &lt;= 0 Then
                Selection.Offset(i, 0).Value = Replace(oneElement1.getAttribute(&quot;href&quot;), &quot;about:&quot;, &quot;http://www.inside-handy.de&quot;)
                i = i + 1
            End If
        End If
        
    End If    
Next oneElement1
</code></pre>
<p>End Sub
&rsquo;&rsquo;&rsquo;</p>
<p>Wie bin ich vorgegangen? Ich habe mir zunächst den Quellcode der Seite angeschaut. Die Liste der Hersteller ist dort eine Tabelle mit den Logos der Unternehmen. Die gewünschte Information befindet sich in a-Elementen, die wiederum innerhalb eines div-Elements liegen. Das gemeinsame &ldquo;Oberelement&rdquo; ist ein div-Container mit der CSS-Klasse &ldquo;h_img&rdquo; bzw. einem weiterne div-Container (&ldquo;h_alle&rdquo;). Außerdem gibt es einen ausgeblendeten div-Container mit einer Liste von Tablet-Herstellern, diese haben den Begriff &ldquo;/tablet&rdquo; in der href-Angabe und müssen ignoriert werden.</p>
<p>&lsquo;&lsquo;&lsquo;html</p>
<div id="h\_alle">
	<div class="h\_img">
		<a href="/hersteller/xyz" title="Handys Hersteller: XYZ">
			<img />
		</a>
	</div>
</div>
'''
<p>Mit &ldquo;Set allElements1 = HTMLDoc.getElementsByTagName(&ldquo;a&rdquo;)&rdquo; lasse ich mir also erst alle a-Elemente aus dem Quellcode in meinen &ldquo;Container&rdquo; legen.</p>
<p>Mit der ersten for-each-Schleife durchlaufe ich nun diesen Container und prüfe mit den ersten zwei if-Abfragen, ob sich das a-Element unterhalb der erwähnten div-Container befindet. Da auf der Seite noch ein weitere identische div-Container mit diesen css-Klassen für die Liste der Tablet-Hersteller existiert, muss ich mit einer dritten if-Abfrage die URL des a-Elements überprüfen. Erst dann kann ich das Attribut des a-Elements auslesen und in mein Excel-Worksheet schreiben.</p>
<p>Fertig ist der erste Schritt - eine Liste der URL zu den jeweiligen Herstellern. Im nächsten Teil werde ich diese Liste durchgehen und von den jeweiligen Seiten die URL zu den Geräten auslesen.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> VBA, Excel, Web-Scraping, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>office</category>
      
      <category>anleitungen</category>
      
      
      
      
      <media:content url="http://localhost:1313/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Tutorial: Web-Scraping mit VBA - Teil 1 - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item><item>
      <title>NTFS unter Mac OS / OS X</title>
      <link>http://localhost:1313/2010/2010-06-24-ntfs-unter-mac-os-os-x/</link>
      <pubDate>Thu, 24 Jun 2010 00:00:00 +0000</pubDate>
      <author></author>
      <guid>http://localhost:1313/2010/2010-06-24-ntfs-unter-mac-os-os-x/</guid>
      <description>NTFS und MacOs gehören nicht unbedingt zusammen. Man kommt also nicht um 3rd-Party-Software herum, um die NTFS unter MacOs nachzurüsten. Hier hilft ein Tool …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel bietet eine Anleitung zur Aktivierung von NTFS-Lese- und Schreibzugriff unter Mac OS X. Es wird die Verwendung von Drittanbieter-Tools wie MacFuse und NTFS-3G beschrieben, um die Kompatibilität mit NTFS-formatierten Laufwerken zu gewährleisten.</p>
          
          
          <p><strong>Hauptthemen:</strong> Mac OS, NTFS, Dateisysteme, Software-Installation, System-Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> beginner</p>
          
        </div>
        
        
        <p>NTFS und MacOs gehören nicht unbedingt zusammen. Man kommt also nicht um 3rd-Party-Software herum, um die NTFS unter MacOs nachzurüsten. Hier hilft ein Tool namens <strong>MacFuse</strong> weiter, das auf dem Mac verschiedene Dateisysteme implementieren kann sowie <strong>NTFS-3G</strong>, eben der passende Treiber für NTFS-Laufwerke.</p>
<p>Beide Programme (bzw. Treiber) stehen als DMG-Datei zur Verfügung. Von NTFS-3G existiert auch eine kommerzielle Variante, die <a href="http://macntfs-3g.blogspot.com/">von Tuxera vertrieben</a> wird. Die kostenlose Variante fällt unter den &ldquo;Verantwortungsbereich&rdquo; von catacombae und reicht für unsere Zwecke eigentlich völlig aus.</p>
<p><a href="http://code.google.com/p/macfuse/">MacFuse auf code.google.com</a></p>
<p><a href="http://sourceforge.net/projects/catacombae/files/NTFS-3G%20for%20Mac%20OS%20X/2010.10.2/">NTFS-3G auf sourceforge.net</a> 1. MacFuse herunterladen und installieren</p>
<p>2. Neustart</p>
<p>3 NTFS-3G herunterladen und installieren</p>
<p>4. Neustart</p>
<p>Fertig.  Der Rest funktioniert automatisch. Viel Spass.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Mac OS, NTFS, Anleitung, Software</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>os-x</category>
      
      <category>anleitungen</category>
      
      
      
      
      <media:content url="http://localhost:1313/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>NTFS unter Mac OS / OS X - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>how-to_guide</dc:type>
      
      
    </item>
  </channel>
</rss>