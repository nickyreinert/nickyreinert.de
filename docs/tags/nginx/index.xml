<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Nginx auf Nicky Reinert</title>
    <link>https://nickyreinert.de/tags/nginx/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Fri, 23 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/tags/nginx/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Das Memory Limit von PHP und WordPress erhöhen - die vollständige Anleitung</title>
      <link>https://nickyreinert.de/2020/2020-10-23-das-memory-limit-von-php-wie-funktioniert-es/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2020/2020-10-23-das-memory-limit-von-php-wie-funktioniert-es/</guid>
      <description>Das Memory Limit, sprich die Speichergrenze, von PHP ist für viele oft ein Rätsel. Es ist nicht klar, wie bzw. wo es gesetzt wird und welche Auswirkungen die …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine vollständige und detaillierte Anleitung zum PHP `memory_limit`. Der Artikel erklärt die Funktionsweise der Speichergrenze und beschreibt die komplexe Hierarchie der verschiedenen Konfigurationsorte – von der globalen `php.ini` über Webserver-Einstellungen in Apache und Nginx (`.htaccess`, `httpd.conf`) bis hin zu anwendungsspezifischen Definitionen in WordPress (`wp-config.php`) und auf Skriptebene (`ini_set`).</p>
          
          
          <p><strong>Hauptthemen:</strong> PHP, Server-Administration, WordPress, Nginx, Apache, Performance-Tuning, Troubleshooting</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Das Memory Limit, sprich die Speichergrenze, von PHP ist für viele oft ein Rätsel. Es ist nicht klar, wie bzw. wo es gesetzt wird und welche Auswirkungen die unterschiedlichen Einstellungsorte haben. <a href="https://wp-ninjas.de/wordpress-php-memory-limit">Viele</a> <a href="https://www.hosttest.de/artikel/was-ist-das-php-memory-limit-1411.html">Anleitungen</a> <a href="https://socialmediadozent.com/php-memory-limit-erhoehen/#Drei_Loesungen_um_das_PHP_Memory_Limit_zu_erhoehen">sind</a> <a href="https://www.how-to-wordpress.de/php-memory-limit/">oft</a> <a href="http://juliusbeckmann.de/blog/php-memory-limit-erhohen.html">unvollständig</a>, und tragen damit eher zur Irritation bei. Denn tatsächlich gibt es unzählige Möglichkeiten das Memory Limit zu setzen:</p>
<ul>
<li>super-global in der php.ini</li>
<li>global in der pool.conf, bei Verwendung von PHP-FPM</li>
<li>oder global in der httpd.conf (Apache) oder server.conf (nginx)</li>
<li>auf Ordner-Ebene in der user.ini</li>
<li>auf Ordner-Ebene in der .htaccess-Datei</li>
<li>auf Applikations-Ebene über die WordPress-Konstanten WP_MEMORY_LIMIT und WP_MAX_MEMORY_LIMIT</li>
<li>oder auf Datei-Ebene im Script mit ini_set();</li>
</ul>
<p><a href="https://www.nickyreinert.de/files/das-memory-limit-von-php-wie-funktioniert-es/grafik-7.png"><img src="/2020/2020-10-23-das-memory-limit-von-php-wie-funktioniert-es/images/grafik-7-700x246.png" alt=""></a></p>
<p>Unterschiedliche Orte, um das PHP Memory Limit (und andere Parameter) zu setzen</p>
<p>Die Reihenfolge entspricht übrigens der Hierarchie. Wird das Limit also im PHP-Script mit ini_set() gesetzt, überschreibt das die Einstellung in der <strong>httpd.conf</strong> oder <strong>server.conf</strong>. Wie sich das vermeiden lässt, dazu unten mehr. Das trifft natürlich nicht nur auf das Memory Limit, sondern so ziemlich jede PHP-Einstellung zu.</p>
<p>Außerdem hängen die Möglichkeiten stark davon ab, wie du PHP nutzt, also ob als Modul oder über CGI. Um das Vorgehen besser zu verdeutlichen, gehe ich im Folgenden von zwei WordPress-Setups aus. Einmal wird nginx als HTTP-Server genutzt und dort PHP-FPM über CGI angesprochen. Das zweite Setup nutzt Apache2 als HTTP-Server und dort PHP als Modul (php-mod).</p>
<h2 id="was-bedeutet-das-memory-limit-von-php">Was bedeutet das Memory Limit von PHP?</h2>
<p>Jeder Dienst benötigt für seine Ausführung Platz im Arbeitsspeicher. So auch PHP. Und mit jedem Aufruf eines PHP-Scripts wird PHP aktiviert und fordert somit Platz im Arbeitsspeicher ein. Und genau dort spielt die Speichergrenze eine Rolle: Um zu vermeiden, dass bei der Verarbeitung <strong>eines PHP-Scripts</strong> zu viel Speicher verbraucht und damit der ganze Server in Mitleidenschaft gezogen wird, legt man eine Obergrenze fest, das <strong>memory_limit</strong>.</p>
<p>Diese Grenze gilt <strong>für jeden einzelnen Script-Aufruf</strong>. Ein Beispiel: Dein Server hat 8 GByte (<strong>8.192 MByte</strong>) Arbeitsspeicher. Der Aufruf der Datei index.php, die eine sehr aufwendige Datenbankabfrage durchführt und damit viele Daten verarbeitet, erfordert 10 MByte Arbeitsspeicher (das ist übrigens relativ viel und <a href="https://www.deimeke.net/dirk/blog/index.php?/archives/304-Bytes-auf-Papier-....html">entspricht etwa 5.000 bedruckten A4 Seiten</a>). Das Memory-Limit ist auf <strong>32 MByte</strong> eingestellt. Das physikalische Limit beträgt allerdings <strong>8.192 MByte</strong>. Die index.php kann also <strong>819 mal</strong> gleichzeitig (!) aufgerufen werden; erst dann ist der Arbeitsspeicher voll. Das Memory-Limit hat hier also keine Auswirkungen.</p>
<p>Gehen wir nun davon aus, dass bei einem der <strong>819</strong> Aufrufe bestimmte Parameter gesetzt werden, die eine weitaus größere Datenmenge in der Datenbank abfragen. Die Datenmenge erhöht sich auf <strong>40 MByte</strong>. An dieser Stelle wird das memory_limit aktiv. Der Aufruf dieses Scripts wird abgebrochen mit der Fehlermeldung, dass die erlaubte Speichergrenze überschritten wurde. PHP wird in diesem Fall eine Fehlermeldung wie diese anzeigen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Fatal error: Allowed memory size of 33554432 bytes exhausted…” followed by something like “(tried to allocate 8388608 bytes) in /home/www/index.php on line 42.”
</span></span></code></pre></div><p>Das Gute daran: Der Aufruf der anderen Scripte wird davon nicht in Mitleidenschaft gezogen.</p>
<p>Es gibt sehr viele Wege, das Speicherlimit zu setzen. Das hat Vorteile aber auch Nachteile: So wird die Suche nach den gesetzen Einstellungen oft zur Suche nach der berühmten Nadel im Heuhaufen. Der Vorteil: Du kannst das Speicherlimit sehr granular an die Anforderungen deiner verschiedenen Anwendungen anpassen. Bereit? Los gehts&hellip;</p>
<h2 id="grundsätzliches">Grundsätzliches</h2>
<p>Der Wert, den du für das Memory Limit übermittelst, kann als einfache Ziffer übergeben werden und legt die Speichergrenze somit in <strong>Byte</strong> fest. PHP unterstützt darüber hinaus einige <strong><a href="https://www.php.net/manual/de/faq.using.php#faq.using.shorthandbytes">Kurzschreibweisen</a></strong>, also z.B. K für Kilobyte (32K), M für Megabyte (256M) und G für Gigabye (2G).</p>
<p>Willst du verhindern möchtest, dass die Speichergrenze später an anderer Stelle überschrieben wird, definierst du sie mithilfe von <strong>php_admin_value</strong> anstatt nur <strong>php_value</strong>. Also z.B.:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">php_admin_value[memory_limit] = 256M
</span></span><span class="line"><span class="ln">2</span><span class="cl"># oder
</span></span><span class="line"><span class="ln">3</span><span class="cl">fastcgi_param PHP_ADMIN_VALUE &#34;memory_limit = 256M&#34;;
</span></span><span class="line"><span class="ln">4</span><span class="cl"># oder
</span></span><span class="line"><span class="ln">5</span><span class="cl">php_admin_value memory_limit = 256M
</span></span></code></pre></div><p>Willst du das Memory LImit komplett deaktivieren, dann setzt du es auf -1:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">memory_limit = -1
</span></span></code></pre></div><p>Aber Achtung: Zu Testzwecken mag das sinnvoll sein, in einer Live-Umgebung solltest du immer mit einer Obergrenze arbeiten.</p>
<p>Und abschließend noch der Verweis auf zwei nützliche Funktionen, die eigentlich bekannt sein sollten:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">echo ini_get(&#39;memory_limit&#39;); // zeigt das aktuell gesetzte Memory Limit
</span></span><span class="line"><span class="ln">2</span><span class="cl">phpinfo(); // zeigt alle relevanten Parameter, u.a. Memory Limit und verwendete .ini-Dateien
</span></span></code></pre></div><p><a href="https://www.nickyreinert.de/files/das-memory-limit-von-php-wie-funktioniert-es/grafik-1.png"><img src="/2020/2020-10-23-das-memory-limit-von-php-wie-funktioniert-es/images/grafik-1-700x25.png" alt=""></a></p>
<p><strong>Wichtig</strong>: Derartige Funktionen dienen der Fehlersuche und sollten im Live-System nicht unbedingt öffentlich abrufbar sein!</p>
<h2 id="das-memory-limit-in-php-einstellen">Das Memory Limit in PHP einstellen</h2>
<h3 id="super-global-in-der-phpini">Super global in der php.ini</h3>
<p>Die erste &ldquo;Konfigurations-Stufe&rdquo; befindet sich natürlich direkt innerhalb von PHP. Wenn du wissen willst, wo sich die Einstellungen für PHP befinden, nutze ganz einfach phpinfo(); Die entsprechende Datei heißt <strong>php.ini</strong> und befindet sich in der Regel in /etc/php/7.0/apache2/php.ini (für PHP als Modul, z.B. in <strong>Apache2</strong>) oder /etc/php/7.4/fpm/php.ini (für PHP als Dienst, z.B. in <strong>nginx</strong>). Der Parameter ist in beiden Fällen gleich:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">memory_limit = 256M
</span></span></code></pre></div><p>Wenn du PHP als Modul unter Apache nutzt, musst du Apache2 neustarten, bzw. die Konfiguration neu einlesen lassen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">service</span> <span class="n">apache2</span> <span class="n">restart</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">service</span> <span class="n">apache2</span> <span class="n">reload</span>
</span></span></code></pre></div><p>Analog, bei PHP als Dienst, wie z.B. in nginx, erfolgt das Neustarten folgendermaßen (In der Regel reicht es aus, mit reload nur die Konfiguration neu zu laden. Sollte es zu Komplikationen kommen, hilft ein kompletter Neustart des Dienstes eventuell weiter).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">service</span> <span class="n">php7</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">fpm</span> <span class="n">restart</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">service</span> <span class="n">php7</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">fpm</span> <span class="n">reload</span>
</span></span></code></pre></div><h3 id="für-jeden-php-fpm-pool-in-der-poolconf">Für jeden PHP-FPM Pool in der pool.conf</h3>
<p>Nutzt du PHP-FPM über CGI (also mein erstes Setup mit nginx), gibt es für jeden Server (bzw. virtuellen Host) einen eigenen <strong>Pool</strong>, lies eine Art eigene getrennte PHP-Umgebung für jeden einzelnen virtuellen Host. Die Einstellungen dazu befinden sich z.B. unter <strong>/etc/php/7.4/fpm/pool/my_host.conf</strong>. Hier wird der entsprechende Parameter folgendermaßen gesetzt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">[my_host_de]
</span></span><span class="line"><span class="ln">2</span><span class="cl">...
</span></span><span class="line"><span class="ln">3</span><span class="cl">php_value[memory_limit] = 1024M
</span></span><span class="line"><span class="ln">4</span><span class="cl">...
</span></span></code></pre></div><p>Die Einstellung an dieser Stelle überschreibt den Wert in der <strong>php.ini</strong>. Nach der Änderung muss der PHP-Dienst natürlich neu gestartet werden.</p>
<h2 id="das-memory-limit-in-apache2-und-nginx-setzen">Das Memory-Limit in Apache2 und nginx setzen</h2>
<h3 id="super-global-in-der-nginxconf--httpdconf">Super global in der nginx.conf / httpd.conf</h3>
<p>Für die beiden HTTP-Server nginx und Apache2 gibt es die beiden globalen Einstellungsdateien <strong>/etc/nginx/nginx.conf</strong> bzw. <strong>/etc/apache2/httpd.conf</strong>. In nginx kann das PHP-Limit im sogenannten <strong>http-Kontext</strong> gesetzt werden und gilt damit für die komplette Nginx-Instanz. Ich gehe hier und im Folgenden übrigens davon aus, dass nginx den PHP-Interpreter über FastCGI anspricht und PHP eigenständig als FPM läuft.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">http {
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  fastcgi_param PHP_VALUE &#34;memory_limit = 256M&#34;;
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">}
</span></span></code></pre></div><p>Im Falle von Apache2 gehe ich davon aus, dass PHP als Modul konfiguriert ist. Hier wird das PHP Limit in der <strong>httpd.conf</strong> folgendermaßen gesetzt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">php_value memory_limit = 256M
</span></span></code></pre></div><h3 id="global-für-jeden-virtuellen-host">Global für jeden virtuellen Host</h3>
<p>In nginx lässt sich die entsprechende Einstellung auch innerhalb des Server-Blocks setzen und gilt somit für einen ganzen virtuelle Host. Üblicherweise findest du diese Einstellung in <strong>/etc/nginx/conf.d/my_host.conf:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">server {
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  fastcgi_param PHP_VALUE &#34;memory_limit = 256M&#34;;
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">}
</span></span></code></pre></div><p>Nutzt du Apache2, findest du die entsprechende Einstellungs-Datei in der Regel unter <strong>/etc/apache2/sites-enabled/my_host.conf</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&lt;VirtualHost&gt;
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">php_value memory_limit 256M
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">&lt;/VirtualHost&gt;
</span></span></code></pre></div><h3 id="global-für-jeden-ordner">Global für jeden Ordner</h3>
<p>Weiter geht es mit dem Ordner-Spezifische Memory-Limit in nginx im location-Kontext (die Datei dürfte in der Regel unverändert sein).</p>
<p>Achtung: <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">In nginx kann die Direktive fastcgi_param</a> auch im übergeordneten http-Kontext oder auf Ordner-Ebene innerhalb des location-Blocks gesetzt werden:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">location ~ .(php|php.*)$ {
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  fastcgi_param PHP_VALUE &#34;memory_limit = 256M&#34;;
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">}
</span></span></code></pre></div><p>Analog dazu kannst du in Apache2 das Limit global in apache2.conf oder auf Ordner-Ebene in der my_host.conf:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="o">&lt;</span><span class="ne">Directory</span><span class="s2">&#34;/var/www/example_de/htdocs/&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">php_value</span> <span class="n">memory_limit</span> <span class="mi">256</span><span class="n">M</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="o">&lt;/</span><span class="ne">Directory</span><span class="o">&gt;</span>
</span></span></code></pre></div><h2 id="das-memory-limit-auf-ordner-ebene-setzen">Das Memory-Limit auf Ordner-Ebene setzen</h2>
<h3 id="für-jeden-ordner-mit-der-userini">Für jeden Ordner mit der .user.ini</h3>
<p>Mit der Datei <strong>.super.ini</strong> kannst du PHP-Einstellungen für beliebige Ordner individuell konfigurieren. Dieser Weg steht dir allerdings nur offen, <a href="https://www.php.net/manual/en/configuration.file.per-user.php">wenn du PHP nicht als Modul nutzt, sondern über CGI/FastCGI</a>. In meinem Beispiel-Setup mit Apache2 und php-mod fällt diese Option also weg.</p>
<p>Du kannst die Datei in jedem Ordner anlegen und dort Parameter so einstellen, wie du es von der php.ini gewohnt bist. Dieser Weg muss allerdings vorher &ldquo;freigeschaltet&rdquo; werden, indem in der php.ini (bzw. den anderen o.g. Orten), der folgende Parameter gesetzt ist:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">user_ini.filename = .user.ini
</span></span></code></pre></div><p>Ob das der Fall ist, erfährst du, wie immer, mithilfe von phpinfo();. Dort siehst du unter &ldquo;Additional .ini files parsed&rdquo; auch, ob sich im aktuellen Ordner eine .user.ini befindet und diese gelesen wurde:</p>
<p><a href="https://www.nickyreinert.de/files/das-memory-limit-von-php-wie-funktioniert-es/grafik-4.png"><img src="/2020/2020-10-23-das-memory-limit-von-php-wie-funktioniert-es/images/grafik-4-700x164.png" alt=""></a></p>
<p>Überprüfen, welche .ini-Dateien PHP gelesen hat</p>
<p>Wenn das alles passt, verwendest du die .user.ini wie die php.ini und setzt das Speicherlimit demnach folgenermaßen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">memory_limit=256M
</span></span></code></pre></div><h3 id="für-jeden-ordner-mit-der-htaccess">Für jeden Ordner mit der .htaccess</h3>
<p>Diese Option wiederum steht dir nur mit Apache2 zur Verfügung, da nginx keine .htaccess-Dateien unterstützt. Du setzt das Limit in der .htaccess-Datei folgendermaßen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">php_value memory_limit = 256M
</span></span></code></pre></div><h2 id="das-memory-limit-auf-applikations-ebene-setzen">Das Memory-Limit auf Applikations-Ebene setzen</h2>
<p>WordPress verwendet standardmäßig eine Memory Limit von <strong>40</strong> <strong>MByte</strong> im Frontend (bzw. 64 MByte bei einem Multi-Site-Setup) sowie (mindestens) <strong>256 MByte</strong> für das Backend. Wenn du diese Werte ändern möchtest, kannst du dafür die beiden folgenden Konstanten in der <strong>wp-config.php</strong> setzen - achte darauf, diese Konstanten vor der Einbindung von <strong>wp-settings.php</strong> zu definieren:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">define(&#39;WP_MEMORY_LIMIT&#39;, &#39;256M&#39;);
</span></span><span class="line"><span class="ln">2</span><span class="cl">define(&#39;WP_MAX_MEMORY_LIMIT&#39;, &#39;256M&#39;);
</span></span><span class="line"><span class="ln">3</span><span class="cl">[...]
</span></span><span class="line"><span class="ln">4</span><span class="cl">require_once(ABSPATH . &#39;wp-settings.php&#39;);
</span></span></code></pre></div><p>WordPress nutzt intern allerdings auch nur die PHP-Funktion ini_set um das Memory Limit festzulegen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ini_set( &#39;memory_limit&#39;, WP_MEMORY_LIMIT );
</span></span></code></pre></div><h2 id="das-memory-limit-auf-datei-ebene-setzen">Das Memory-Limit auf Datei-Ebene setzen</h2>
<p>Zum Abschluss gibt es auch die Möglichkeiten das Memory Limit in jedem Script individuell zu setzen. Diese Möglichkeit steht an letzter Stelle und überschreibt damit alle vorhergehenden Einstellungen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ini_set(&#39;memory_limit&#39;,&#39;256M&#39;);
</span></span></code></pre></div><p>Durch die Verwendung von <strong>include()</strong>, <strong>require_once()</strong> oder <strong>require()</strong> lassen sich andere PHP-Dateien innnerhalb eines Scripts einzubinden. Grundsätzlich wird das Memory Limit dann zwar vererbt. Was nicht heißt, dass es durch später eingebundene Scripte überschrieben werden kann. Das macht sich z.B. auch bei WordPress bemerkbar: Du kannst das Memory Limit zwar mit WP_MEMORY_LIMIT für WordPress definieren, ein Plugin oder Theme kann das Limit aber trotzdem später überschreiben.</p>
<p>Ein Beispiel: So sieht die Datei <strong>index.php</strong> aus:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">&lt;?php  ini_set(&#39;memory_limit&#39;,&#39;256M&#39;);  (...aufwendige Operation...);  include(&#39;file.php&#39;); 
</span></span></code></pre></div><p>Die Datei <strong>file.php</strong> sieht folgendermaßen aus:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"> &lt;?php
</span></span><span class="line"><span class="ln">2</span><span class="cl"> echo ini_get(&#39;memory_limit&#39;);
</span></span><span class="line"><span class="ln">3</span><span class="cl"> (…aufwendige Operation…)
</span></span><span class="line"><span class="ln">4</span><span class="cl"> ini_set(&#39;memory_limit&#39;,&#39;32M&#39;);
</span></span><span class="line"><span class="ln">5</span><span class="cl"> (…aufwendige Operation…);
</span></span></code></pre></div><p>Die zweite Zeile in der file.php gibt als Rückgabe <strong>256M</strong> aus. Das Memory-Limit wird vererbt. Die vierte Zeile setzt das Limit allerdings auf 32 MByte und überschreibt damit den Wert von 256 MByte. Belegt die &ldquo;aufwendige Operation&rdquo; in index.php nur <strong>12 MByte</strong>, in der file.php nur jeweils <strong>5 MByte</strong>, funktioniert das gesamte Script einwandfrei. Wenn die &ldquo;aufwendige Operation&rdquo; in der Datei index.php z.B. mehr als <strong>22 MByte</strong> beansprucht, bricht PHP die Verarbeitung des Scripts ab. Warum? Weil das Limit nachträglich nach unten korrigiert wurde.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> apache, apache2, memory-limit, nginx, php</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>anleitungen</category>
      
      <category>blog</category>
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Das Memory Limit von PHP und WordPress erhöhen - die vollständige Anleitung - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>comprehensive_guide</dc:type>
      
      
    </item><item>
      <title>Zugriff nicht loggen, wenn ein bestimmter HTTP-Request-Header gesetzt ist</title>
      <link>https://nickyreinert.de/2018/2018-11-28-zugriff-nicht-loggen-wenn-ein-bestimmter-http-request-header-gesetzt-ist/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-11-28-zugriff-nicht-loggen-wenn-ein-bestimmter-http-request-header-gesetzt-ist/</guid>
      <description>OK, ich tu mich etwas schwer, das folgende in einen Titel zu gießen, der nicht länger ist, als die eigentlich Anleitung. Wenn du an deiner Webseite arbeitest, …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieses Tutorial beschreibt eine Methode, um eigene Zugriffe bei der Web-Entwicklung aus den Nginx-Logdateien auszuschließen. Die Lösung kombiniert ein Browser-Plugin zur Modifikation von HTTP-Headern mit einer serverseitigen Nginx-Konfiguration, die das Logging auf Basis eines benutzerdefinierten Headers bedingt deaktiviert.</p>
          
          
          <p><strong>Hauptthemen:</strong> Nginx, Webserver-Konfiguration, Logging, Web-Development, HTTP</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>OK, ich tu mich etwas schwer, das folgende in einen Titel zu gießen, der nicht länger ist, als die eigentlich Anleitung. Wenn du an deiner Webseite arbeitest, möchtest du vielleicht vermeiden, dass deine Aufrufe mit deinem Browser im Log-File von <strong>nginx</strong> landen. Dafür gibt es eine Menge Möglichkeiten, ich mag die folgende aber besonders.</p>
<p>Zuerst benötigst du dafür ein Plugin, um den <strong>HTTP-Request-Header</strong> zu modifizieren. Ich nutze dafür <a href="https://addons.mozilla.org/en-US/firefox/addon/modheader-firefox/">ModHeader für Firefox,</a> für Chrome gibt es ähnliche Plugins. Dort legst du einen benutzerdefinierten Header an, dem du z.B. &ldquo;true&rdquo; als Wert zuweist. Bei diesem Plugin kannst du außerdem festlegen, dass der Header nur auf einer bestimmten Seite hinzugefügt wird.</p>
<p>[caption id=&ldquo;attachment_2395&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/zugriff-nicht-loggen-wenn-ein-bestimmter-request-header-gesetzt-ist/modHeader.png"><img src="/2018/2018-11-28-zugriff-nicht-loggen-wenn-ein-bestimmter-http-request-header-gesetzt-ist/images/modHeader-300x163.png" alt="ModHeader Firefox Plugin"></a> ModHeader Firefox Plugin[/caption]</p>
<p>Als nächstes definierst du in deiner nginx-Config eine Regel, die diesen Header ausliest:</p>
<p>map $http_ignoreMe $log_this {</p>
<pre><code>~true 0;

default 1;
</code></pre>
<p>}</p>
<p>Mit $http_ignoreMe sprichst du den zuvor angelegten Header an, $log_this erzeugt eine Variable, auf die du später zugreifen kannst. Enthält der Header &ldquo;true&rdquo; (~true), wird die Variable $log_this auf 0 gesetzt, ansonsten bleibt sie 1. Als nächstes öffnest du den Server-Bereich deiner Webseite und suchst nach deiner Logging-Einstellung (alternativ kannst du natürlich auch die globale Logging-Einstellung anpassen:</p>
<pre><code>access\_log /var/logs/access.log main if=$log\_this;
</code></pre>
<p>Der zweite Parameter ist das Log-File - natürlich. Der dritte Parameter verweist auf mein benutzerdefiniertes Log-Format, das muss hier nicht unbedingt stehen. Und am Ende schließlich kommt die Bedingung, dass nämlich nur geloggt wird, wenn $log_this wahr bzw. 1 ist. Jetzt startest du nginx neu&hellip; et voilá - Anfragen an deine Seite von deinem Browser aus werden ignoriert.</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Nginx, Logging, Tutorial, Web-Dev</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Zugriff nicht loggen, wenn ein bestimmter HTTP-Request-Header gesetzt ist - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item><item>
      <title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten</title>
      <link>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</link>
      <pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/</guid>
      <description>Ich habe mich eine ganze weile erfolgreich vor Docker als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Eine umfassende Anleitung zur Einrichtung einer lokalen Web-Entwicklungsumgebung auf macOS mit Docker. Das Tutorial beschreibt detailliert, wie man Container für Nginx, PHP-FPM und MySQL aufsetzt und miteinander verknüpft. Ein besonderer Fokus liegt auf der Erstellung eines benutzerdefinierten Docker-Images mittels Dockerfile, um Xdebug für das PHP-Debugging zu installieren und in Visual Studio Code zu integrieren.</p>
          
          
          <p><strong>Hauptthemen:</strong> Docker, macOS, Nginx, PHP-FPM, MySQL, Xdebug, Web-Development, DevOps</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> advanced</p>
          
        </div>
        
        
        <p>Ich habe mich eine ganze weile erfolgreich vor <strong>Docker</strong> als lokale Entwicklungsumgebung gedrückt. Der Grund: Ich nutze eine kommerzielle Parallels Lizenz, über die ich Ubuntu virtualisiert laufen lasse und bin damit bisher ganz gut gefahren. Bisher. Paralles hat nämlich immer wieder Problem gemacht. So konnte ich nach manchen Updates von Parallels oder Ubuntu die <em>Parallels Tools</em> nicht mehr nutzen und musste diese umständlich neu installieren. Da die Doku dazu auch nur unvollständig vorliegt, war das regelmäßig eine ziemliche Zeitverschwendung. Die <em>Parallels Tools</em> sind aber notwendig, um von Ubuntu aus auf die Dateien des Gastsystems, Mac OS X, zuzugreifen.</p>
<p>Beim letzten Update auf Ubuntu 18.04 ließen sich die <em>Parallels Tools</em> gar nicht mehr installieren. Die Ursache dafür ist wohl irgendeine Inkompatibilität eines abhängigen Paketes mit dem neuen Linux-Kernel. Wie auch immer: Ich war die Sorgen leid und auf der Suche nach einer Alternative. Weshalb ich <strong>Docker</strong> stieß. Der Vorteil: Docker ist weitaus performanter und portabler. Der Nachteil: Um damit eine funktionierende Entwicklungsumgebung zu schaffen, kommt man um die Shell nicht herum. Das mitgelieferte UI Kitematic liegt noch als Beta vor und lässt einige Funktionen einfach vermissen. Es gibt also einige kleinere Fallstricke, die es zu überwinde galt. Was mir gelungen ist. Wie, das werde ich nun genauer erläutern. <em>Viel Spass</em>.</p>
<p>[caption id=&ldquo;attachment_2166&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-scho%CC%88n-aber-noch-nutzlos.png"><img src="images/kitematic-scho%CC%88n-aber-noch-nutzlos-300x181.png" alt="Kitematic - schön aber (noch) weitestgehend nutzlos"></a> Kitematic - schön aber (noch) weitestgehend nutzlos[/caption]</p>
<h2 id="erste-schritte">Erste Schritte</h2>
<p>Grundsätzlich kann man bei der  Installation der Docker-Anwendung nicht viel falsch machen: Account anlegen, Docker herunterladen, installieren, anmelden - fertig. Auf die zugrunde liegende Technologie will ich hier nicht weiter eingehen, das machen andere weitaus besser (z.B. <a href="https://www.ab-heute-programmieren.de/docker-teil-1-was-ist-docker/">ist diese Anleitung sehr zu empfehlen</a>).</p>
<p>Nur soviel soll gesagt sein: Du lädst ein <strong>Image</strong> herunter, dass du dann <em>starten</em> kannst. Dadurch erhältst du einen <strong>Container</strong>, der bestimmte Dienste bereitstellt. Dieser Container ist kein vollständiges Betriebssystem mit all seinem Ballast. So kannst du z.B. nicht ohne weiteres per SSH darauf zugreifen. Das funktioniert nur, wenn der entsprechende SSH-Dienst auch im Image vorgesehen ist. Das schöne an Docker ist aber, dass du das Image mit beliebigen Funktionalitäten über ein sogenanntes <strong>Dockerfile</strong> relativ unkompliziert nachrüsten kannst. Das erfordert zwar eine gewisse Umgewöhnung im Arbeitsablauf ab, bringt aber auch viele Vorteile mit sich.</p>
<p>Wer will kann sich mit der <strong>Kitematic UI</strong> durch die vorhandenen Docker-Images wühlen und auch direkt herunterladen. Diese stehen dann natürlich auch auf der Kommandozeile zur Verfügung. Mit <strong>docker image ls</strong> zeigst du alle verfügbaren Images an. Analog dazu listet <strong>docker container ls</strong> alle erstellten Container auf. Außerdem gibt es noch ein paar andere, für den Anfang ganz brauchbare Befehle:</p>
<p># alle lokal verfügbaren Images auflisten
docker image ls</p>
<h1 id="alle-gestarteten-bzw-erzeugten-container-auflisten">alle gestarteten bzw. erzeugten Container auflisten</h1>
<p>docker container ls</p>
<h1 id="die-kommandozeile-für-den-container-mit-dem-namen-mysql-die-kommandozeile-starten">die Kommandozeile für den Container mit dem Namen &ldquo;mysql&rdquo; die Kommandozeile starten</h1>
<p>docker exec -it mysql /bin/bash</p>
<h1 id="für-den-container-mit-dem-namen-mysql-das-setup-anzeigen">für den Container mit dem Namen &ldquo;mysql&rdquo; das Setup anzeigen</h1>
<p>docker inspect mysql</p>
<p>Für eine lokale Entwicklungsumgebung benötigt man zunächst einen <strong>HTTP- und einen MySQL-Server.</strong> Natürlich gehört zu jeder guten Entwicklungsumgebung auch ein Debugger - für PHP wäre das wohl <strong>xdebug</strong>. Ich nutze hier die beiden Images: <a href="https://hub.docker.com/r/richarvey/nginx-php-fpm/">nginx-php-fpm von Ric Harvey</a> und <a href="https://hub.docker.com/_/mysql/">das sehr aktuelle und offizielle MySQL-Image</a>, die ich erstmal ganz unkompliziert über Kitematic herunterlade. Das nginx-Image werde ich schließlich mit einem <strong>Dockerfile</strong> anpassen um auch <strong>xdebug</strong> nutzen zu können.</p>
<p>[caption id=&ldquo;attachment_2167&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/kitematic-auswahl-von-images.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/kitematic-auswahl-von-images-300x152.png" alt="Die Auswahl neuer Images über Kitematic ist sehr bequem"></a> Die Auswahl neuer Images über Kitematic ist sehr bequem[/caption]</p>
<p>Ab hier verlasse ich Kitematic allerdings wieder und werde Docker nur noch über die Kommandozeile und ein paar selbst geschriebene Scripte nutzen. Los gehts&hellip;</p>
<h2 id="den-mysql-container-starten">Den MySQL-Container starten</h2>
<p>&hellip; es mit dem MySQL-Container. Da der nginx-Container auf MySQL zugreift, muss der MySQL-Container auch zuerst dasein. Der Aufruf dafür sieht folgendermaßen aus:</p>
<p>docker run \
&ndash;name mysql \
&ndash;publish 3306:3306 \
&ndash;volume /Users/nicky/Development/MySQL:/var/lib/mysql \
&ndash;env MYSQL_ALLOW_EMPTY_PASSWORD=yes \
&ndash;env MYSQL_ROOT_HOST=% \
&ndash;detach \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Mit &ndash;name vergebe ich einen festen und vor allem lesbaren Namen. Ohne diesen Parameter würde Docker eine Id anlegen, die den Zugriff später aber unnötig kompliziert macht. Der Parameter <em>--publish</em> legt fest, welcher Port &ldquo;von draußen&rdquo; auf einen Port im Docker-Container gemappt wird. Da sich die Dateien für die Datenbank physikalisch natürlich nicht im Docker-Container, sondern im Dateisystem vom Host befinden, muss ich dem Container mitteilen, wie er darauf zugreifen kann. Das passiert mit dem Parameter <em>--volume</em>. Damit kann ich nich nur Ordner im Container verfügbar machen, sondern auch Dateien. Das ist ganz praktisch, um z.B. Configurations-Dateien von außerhalb beim Start des Containers mitzuliefern.</p>
<p>Der Parameter <em>--env</em> dient dazu, Umgebungsvariablen zu setzen. Diese sind natürlich abhängig vom verwendeten Container. Für den MySQL-Container möchte ich hier zwei Parameter übergeben: Ich will eine Root-Benutzer ohne Passwort anlegen (<em>MYSQL_ALLOW_EMPTY_PASSWORD</em>) (das mag unsicher erscheinen, da ich hier aber lokal nur mit Testdaten arbeite, ist das erstmal einfach nur pragmatisch). Außerdem soll sich jeder Client verbinden können, also setzte ich <em>MYSQL_ROOT_HOST</em> auf %.</p>
<p>Eine Besonderheit ist der Parameter <em>default-authentication-plugin</em>. Wenn du ein Root-Passwort vergibst, solltest du zusätzlich diesen Parameter setzen. Zur Erklärung: Es handelt sich hier um ein MySQL 8-Image. Dort wird als Authentifizierungs-Methode <em>caching_sha2_password</em> verwendet, was sich mit Docker leider nicht verträgt und mit dieser Fehlermeldung quittiert wird:</p>
<blockquote>
<p>Unable to load authentication plugin &lsquo;caching_sha2_password</p></blockquote>
<p>Und schließlich gibt es noch den Parameter &ndash;detach, der einfach dafür sorgt, dass der Container im Hintergrund gestartet wird.</p>
<p>Das war es fast. Was jetzt noch fehlt, ist der Name des Images, dass die Grundlage für deinen neuen Container bilden soll: <em>mysql</em>. Wenn das Image lokal nicht vorhanden ist, lädt Docker es hilfsbereiterweise einfach herunter.</p>
<p>Es empfiehlt sich, den Aufruf in ein Shell-Script zu packen und diese Zeilen voranzustellen. Beim Aufruf wird also ein vorhandener Container erst gestoppt und gelöscht und dann neu gestartet:</p>
<p>#!/bin/bash
docker stop mysql
docker rm mysql
docker run \
&ndash;name mysql \
-p 3306:3306 \
-v /Users/nicky/Development/MySQL:/var/lib/mysql \
-e MYSQL_ALLOW_EMPTY_PASSWORD=yes \
-e MYSQL_ROOT_HOST=% \
-d \
&ndash;default-authentication-plugin=mysql_native_password \
mysql</p>
<p>Et voilà: Ein MySQL-Server im Docker-Container auf Knopfdruck!</p>
<h2 id="den-http-container-starten">Den HTTP-Container starten</h2>
<p>Am Vorgehen ändert sich nicht viel. Auch für den <strong>nginx-Server</strong> erstelle ich mir ein kleines Script. Dieses befindet sich aber in einem Unterordner meiner Wordpress-Installation. Mit dem Platzhalter <strong>${PWD}</strong> im Parameter <em>--volume</em> kann ich Docker das aktuelle Verzeichnis mitgeben. Dadurch kann  ich das Script auch innerhalb andere Wordpress-Installationen verwenden (und muss lediglich den Namen des Containers anpassen). Hier sorge ich also dafür, dass Docker das aktuelle Verzeichnis als Root-Verzeichnis für den HTTP-Server nutzt. Außerdem liefere ich eine eigene ini-Datei für PHP mit. Wichtig ist außerdem die Verknüpfung zu meinem zuvor erstellen MySQL-Container über den Parameter <em>--link</em>. Der Rest wird analog des ersten Containers vorgegeben: Port, Name, Image, usw.</p>
<p>#!/bin/bash
docker stop nickyreinert-de
docker rm nickyreinert-de
docker run \
&ndash;link mysql \
&ndash;name nickyreinert-de \
&ndash;volume ${PWD}/dev/wordpress.ini:/usr/local/etc/php/conf.d/uploads.ini \
&ndash;volume ${PWD}:/var/www/html \
&ndash;publish 80:80 \
&ndash;detach \
richarvey/nginx-php-fpm</p>
<h2 id="xdebug-installieren">xdebug installieren</h2>
<p>Leider liefert das nginx-Image kein <strong>xdebug</strong> mit. Bzw: Zurecht - der Sinn des ganzen Konzeptes ist es ja, schlanke Container nutzen zu können. Eine All-In-One-Lösung entspräche letztlich ja wieder einer kompletten virtuellen Maschine. Für mich jedenfalls heißt das, dass ich das nginx-Image nun irgendwie mit <strong>xdebug</strong> füttern muss. Das passiert mit <strong>docker build</strong>. Dazu benötige ich zunächst ein Dockerfile, dass auch genau so heißt und folgendermaßen aufgebaut ist - Erklärung folgt darunter:</p>
<p>FROM richarvey/nginx-php-fpm</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS
RUN apk add &ndash;no-cache nano</p>
<p>RUN pecl install xdebug
RUN echo &lsquo;zend_extension = /usr/local/lib/php/extensions/no-debug-non-zts-20170718/xdebug.so&rsquo; &raquo; /usr/local/etc/php/php.ini
RUN touch /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_enable=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_autostart=1 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_connect_back=0 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_host=192.168.0.11  &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_port=9000 &raquo; /usr/local/etc/php/conf.d/xdebug.ini; \
echo xdebug.remote_log=/tmp/php-xdebug.log &raquo; /usr/local/etc/php/conf.d/xdebug.ini;</p>
<p>Zunächst einmal lege ich mit <em>FROM</em> fest, welches Images als Grundlage genutzt werden soll - in meinem Fall also nginx-php-fpm von richarvey. Mit <em>RUN</em> übergebe ich dann, zum Image passende, Befehle. So könnte ich xdebug zum Beispiel einfach mit pecl install xdebug installieren lassen. Du wirst dann aber recht schnell feststellen, dass das nicht ohne weiteres funktioniert. PHP ist in diesem Docker-Image natürlich nur mit den wichtigsten Paketen eingerichtet, <em>phpize</em> gehört so z.B. nicht dazu und der Aufruf würde mit folgender Fehlermeldung quittiert werden:</p>
<p>Cannot find autoconf. Please check your autoconf installation and the # $PHP_AUTOCONF environment variable. Then, rerun this script.</p>
<p>Die Lösung ist, <em>phpize</em> im Voraus mit allen notwendigen Abhängigkeiten zu installieren. Dazu dient der Aufruf</p>
<p>RUN apk add &ndash;no-cache &ndash;virtual .phpize-deps $PHPIZE_DEPS</p>
<p>Das das nicht immer so umfangreich vonstatten gehen muss, soll die Installation des Texteditors <em>nano</em> zeigen: Man kann gewünschte Pakete auch einfach mit <em>apk add <paketname></em> zum Docker-Image hinzufügen. Der apk-Parameter <em>--virtual</em> besagt, dass die genannten Pakete zu einem &ldquo;virtuellen Paket&rdquo; hinzugefügt werden, dass sich dann mit <em>apk del <paketname></em> leicht wieder entfernen lässt. Danach schließlich kann <strong>xdebug</strong> mit <em>pecl install</em> installiert werden. Die letzten beiden RUN-Aufrufe sorgen dafür, dass eine Standard-Konfiguration für xdebug eingerichtet wird. Hier wird es tatsächlich noch etwas tricky, wenn es um den <em>remote_host</em> geht. Docker lässt den Container später in einem eigenen Netzwerk laufen. Der Docker-Host, also in meinem Fall OS X,erhält dafür eine eigene IP-Adresse, wie z.B. 172.17.0.1. Das Problem: Das ist nicht die IP-Adresse, unter der OS X bzw. der Debug-Client (z.B. Visual Studio Code) erreichbar ist. Jeder Debug-Versuch wurde (in meinem Fall) in <em>/tmp/php-xdebug.log</em> mit folgender Fehlermeldung quittiert:</p>
<p>W: Creating socket for &lsquo;127.0.0.1:9000&rsquo;, poll success, but error: Operation in progress (29).</p>
<p>Der Remote-Host ist also die tatsächliche IP-Adresse deines Hosts, unabhängig von Docker. Hier demnach die IP-Adresse <em>192.168.0.11</em>.</p>
<p>Zum Abschluss muss das Dockerfile nur noch verarbeitet werden. Das passiert mit folgendem Aufruf:</p>
<p>docker build &ndash;tag nginx-php-fpm-xdebug .</p>
<p>Mit dem Parameter <em>--tag</em> gibst du dem modifizierten Image einen eigenen Namen. Der letzte Parameter - ein Punkt - zeigt docker, in welcher Datei sich die Build-Anweisung befindet. Docker sucht standardmäßig nach einer Datei mit dem Namen Dockerfile. Deshalb verweise ich mit dem Punkt einfach nur auf den aktuellen Ordner, in dem sich diese Datei auch befindet.</p>
<p>Docker wird nun die Anweisungen aus dem Dockerfile verarbeiten und ein neues Image erzeugen. Der erste Aufruf wird etwas länger dauern. Wenn du an dem Dockerfile nur geringfügige Änderungen vornimmst und den build-Prozesse erneut startest, ist Docker so clever und nimmt nur die notwendigen Änderungen vor - alles andere befindet sich bereits in einer Art &ldquo;Zwischenspeicher&rdquo;.</p>
<p>Denke nun daran, den oben bereits zusammengebauten Container-Aufruf des HTTP-Servers den Image-Name anzupassen: <em>nginx-php-fpm-xdebug</em>!</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<p>Der Vollständigkeit halber möchte ich nun noch die Schritte dokumentieren, die bei Microsofts Visual Studio Code (VSC) notwendig sind. Hier installiert man zunächst das Paket <strong>PHP Debug</strong>. Im Debug-Bereich fügt man dann eine neue Konfiguration hinzu, die VSC mitteilt, unter welcher IP-Adresse xdebug erreichbar ist - nämlich 127.0.0.1 und dem üblichen Port: 9000:</p>
<p>{
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: <a href="https://go.microsoft.com/fwlink/?linkid=830387">https://go.microsoft.com/fwlink/?linkid=830387</a>
&ldquo;version&rdquo;: &ldquo;0.2.0&rdquo;,
&ldquo;configurations&rdquo;: [
{
&ldquo;name&rdquo;: &ldquo;Listen for XDebug&rdquo;,
&ldquo;type&rdquo;: &ldquo;php&rdquo;,
&ldquo;request&rdquo;: &ldquo;launch&rdquo;,
&ldquo;port&rdquo;: 9000,
&ldquo;host&rdquo;: &ldquo;127.0.0.1&rdquo;
}
]
}</p>
<p>Fertig. Mit einem Klick auf den grünen Playbutton wird VSC sich nun mit xdebug verbinden.</p>
<p>[caption id=&ldquo;attachment_2199&rdquo; align=&ldquo;aligncenter&rdquo; width=&ldquo;300&rdquo;]<a href="https://www.nickyreinert.de/files/nginx-mit-php-fpm-und-mysql-mit-docker-auf-mac-os-einrichten/visual-studio-code-den-debugger-starten.png"><img src="/2018/2018-09-16-nginx-mit-php-fpm-mysql-und-xdebug-mit-docker-auf-mac-os-einrichten/images/visual-studio-code-den-debugger-starten-300x162.png" alt="Visual Studio Code - den Debugger starten"></a> Visual Studio Code - den Debugger starten[/caption]</p>
<h2 id="fazit">Fazit</h2>
<p>Docker hat mich voll überzeugt. Ich bereue es, dass ich nicht schon früher umgestiegen bin. Es läuft sauber und wenn man das Konzept erstmal verstanden hat, ist es auch sehr intuitiv zu bedienen und lässt vor allem keine Wünsche auf. Im Nachhinein betrachtet hat mich die komplette Einrichtung der virtuellen Maschine mit Ubuntu unter Parallels auch weitaus mehr Zeit - und Nerven! - gekostet. Was jetzt noch fehlt, ist das etwas dynamischere Verwalten mehrerer lokaler Websiten mit Docker. Dazu komme ich später - <em>stay tuned</em>.</p>
<h2 id="referenzen">Referenzen</h2>
<p>Mein Dank gilt <a href="http://paislee.io/a-minimal-development-server-with-nginx-and-docker/">Caleb Sotelo</a>, von wo ich einen Großteil der Scripte habe. Ein Teil des Dockerfiles stammt von <a href="https://blog.philipphauer.de/debug-php-docker-container-idea-phpstorm/">philipphauer.de</a>. Danke!</p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> Docker, macOS, Nginx, PHP, Xdebug, Tutorial</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>NGinx mit PHP-FPM, MySQL und Xdebug mit Docker auf Mac OS einrichten - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>tutorial</dc:type>
      
      
    </item>
  </channel>
</rss>