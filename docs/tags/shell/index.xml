<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Shell auf Nicky Reinert</title>
    <link>https://nickyreinert.de/tags/shell/</link>
    <description>Blog &amp; Projekte von Nicky Reinert (Institut für digitale Herausforderungen): Webentwicklung &amp; Software Development, SEO &amp; Analytics, Hosting &amp; DevOps, WordPress &amp; Hugo, Tools &amp; Projekte, Datenschutz und digitale Kultur – plus Texte zu KI sowie Autismus &amp; Gesellschaft.</description>
    <generator>Hugo 0.148.2</generator>
    <language>de</language>
    <managingEditor></managingEditor>
    <webMaster></webMaster>
    <copyright></copyright>
    <lastBuildDate>Fri, 24 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://nickyreinert.de/tags/shell/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Die OS X - Bash</title>
      <link>https://nickyreinert.de/2018/2018-08-24-die-os-x-bash/</link>
      <pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-08-24-die-os-x-bash/</guid>
      <description>Da ich mit meinem Mac sehr oft auf der Kommandozeile unterwegs bin (dazu empfehle ich übrigens iTerm2 - ein Terminal-Ersatz der alle anderen Anwendungen dieser …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel behandelt Die OS X - Bash und bietet praktische Einblicke in das Thema.</p>
          
          
          <p><strong>Hauptthemen:</strong> Mac, Tools, System</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>Da ich mit meinem Mac sehr oft auf der Kommandozeile unterwegs bin (dazu empfehle ich übrigens <a href="https://www.iterm2.com/">iTerm2</a> - ein Terminal-Ersatz der alle anderen Anwendungen dieser Art auch auf Linux und Windows aussticht) habe ich mir dafür ein paar kleine Einstellungen zusammengesammelt, die das Leben und Arbeiten auf der Kommandozeile etwas erleichtern.</p>
<h2 id="was-ist-bash">Was ist Bash?</h2>
<p>Bash steht für &ldquo;Bourn again shell&rdquo; und ist eine Erweiterung der älteren Bourne-Shell, eine Shell die auf Unix-(ähnlichen) Systemen als Benutzerschnittstelle dient. Und diese ist vor allem daran erkennbar, dass die Steuerung des Systems nur über die Tastatur, ohne Maus und Fenster funktioniert.</p>
<p>Seit der Version 10.3 ist Bash auch Bestandteil von Mac OS X und bringt damit eine Menge Vorteile für die Arbeit auf der Kommandozeile mit sich.</p>
<h2 id="die-bash-konfigurationsdateien">Die Bash Konfigurationsdateien</h2>
<p>Die globalen Einstellungen für die Bash befinden sich in der Datei <strong>/etc/bashrc</strong> und der <strong>/etc/profile</strong>. Wer Einstellungen auf bestimmte Benutzer beschränken will, kann im Benutzerverzeichnis (du gelangst mit <em>cd ~</em> dorthin) eine Datei mit dem Name <strong>.profile</strong>, <strong>.bash_login</strong> oder <strong>.bash_profile</strong> anlegen. Beachte, dass <strong>.profile</strong> nur geladen wird, wenn <strong>.bash_login</strong> nicht existiert, welche wiederum durch <strong>.bash_profile</strong> überschrieben wird. Das gilt allerdings nicht, wenn du dich als <strong>root-Benutzer</strong> anmeldest - dann wird nur die Datei <strong>.profile</strong> gelesen. Der Grund ist, dass der Root-Benutzer nicht <strong>bash</strong> sondern <strong>sh</strong> ausführt, wodurch nur die <strong>~/.profile</strong>-Datei berücksichtigt wird.</p>
<p><img src="/2018/2018-08-24-die-os-x-bash/images/image-8.png" alt=""></p>
<p>Hierarchie der Bash-Konfigurations-Dateien</p>
<p>Daneben gibt es theoretisch auch die Möglichkeit, im Benutzerverzeichnis eine Datei mit dem Namen <strong>.bashrc</strong> anzulegen. Diese wird jedoch nur dann geladen, wenn Bash ausgeführt wird, ohne dass sich ein Benutzer dazu anmeldet (die sogenannte <em>non-login-shell</em>). Im OS X-Umfeld wird das aber nicht benötigt. Du kannst das erzwingen, indem du auf der Kommandozeile <strong>/bin/bash</strong> ausführst - wir wollen die jetzt schon komplizierte Geschichte aber nicht unnötigen verkomplizieren. ;)</p>
<h2 id="die-bash-aufhübschen">Die Bash aufhübschen</h2>
<p>Nach der langweiligen aber notwendige Theorie, gibts jetzt ein paar Zeilen Code, mit denen die Kommandozeile gleich viel besser aussieht. Ich hab aus oben genannten Gründen das Ganze in die Datei <strong>~/.profile</strong> gepackt. Zunächst einmal ein paar Aliase um die Verzeichnislisten etwas übersichtlicher zu gestalten oder auch das oft benutzte <strong>cd</strong> (<em>change dir</em>) zu vereinfachen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">alias l=&#39;ls -alCFGA&#39;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">alias ll=&#34;ls -CFGla&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">alias h=&#34;history&#34;
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">alias .=&#34;cd ~&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">alias ..=&#34;cd ..&#34;
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">alias ...=&#34;cd ../..&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"># -p: erzeuge Unterverzeichnis, falls sie nicht existieren
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"># -v: gebe erzeugtes Verzeichnis zurück
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">alias mkdir=&#34;mkdir -pv&#34;
</span></span><span class="line"><span class="ln">10</span><span class="cl"># grep Ausgabe farbig gestalten
</span></span><span class="line"><span class="ln">11</span><span class="cl">alias grep=&#39;grep --color=auto&#39;
</span></span><span class="line"><span class="ln">12</span><span class="cl">alias fgrep=&#39;fgrep --color=auto&#39;
</span></span><span class="line"><span class="ln">13</span><span class="cl">alias egrep=&#39;egrep --color=auto&#39;
</span></span><span class="line"><span class="ln">14</span><span class="cl"># das aktuelle Verzeichnis im Finder öffnen
</span></span><span class="line"><span class="ln">15</span><span class="cl">alias f=&#39;open -a Finder ./&#39;
</span></span></code></pre></div><p>Die folgende Zeile ist kein Alias sondern eine Funktion. Damit wird ein Verzeichnis (mit allen benötigten Unterverzeichnissen erstellt) und dann mit cd direkt in das Verzeichnis gewechselt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mcd () { mkdir -p &#34;$1&#34; &amp;&amp; cd &#34;$1&#34;; }
</span></span></code></pre></div><p>Als nächstes will ich die Darstellung der zuletzt benutzten Befehle (<strong>history</strong> bzw. jetzt <strong>h</strong>) etwas anpassen:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># Duplikate ignorieren
</span></span><span class="line"><span class="ln">2</span><span class="cl">HISTCONTROL=ignoreboth
</span></span><span class="line"><span class="ln">3</span><span class="cl"># Befehle anhängen und die Historie nicht jedes mal neu überschreiben
</span></span><span class="line"><span class="ln">4</span><span class="cl">shopt -s histappend
</span></span><span class="line"><span class="ln">5</span><span class="cl"># die maximale Größe bzw. Länge der Historie erhöhen
</span></span><span class="line"><span class="ln">6</span><span class="cl">HISTSIZE=1000
</span></span><span class="line"><span class="ln">7</span><span class="cl">HISTFILESIZE=2000
</span></span></code></pre></div><p>Der folgende Befehl sorgt dafür, dass sich die Anzahl der dargestellten <strong>Spalten und Zeilen</strong> an die Fenstergröße anpasst. Die Funktion sollte per default aktiviert sein, zur Sicherheit legen wir das hier trotzdem fest! Mit dem Parameter -u kann die Option übrigens wieder deaktiviert werden.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">shopt -s checkwinsize
</span></span></code></pre></div><p>Hiermit wird das Aussehen und die Farbe der Kommandozeile geändert. Ich hab mich für eine relativ bunte Variante entschieden. Die Einstellung für den sog. Prompt wird in der globalen Variable <strong>PS1</strong> (<em>prompt statement 1</em>) gespeichert. Die folgenden Parameter sind hier geläufig:</p>
<ul>
<li>\u - Benutzername</li>
<li>\h - Name des Hosts / Computers</li>
<li>\w - der komplette aktuelle Pfad</li>
<li>\n  - Ein Zeilenumbruch</li>
</ul>
<p>Mit <strong>PS2</strong>, <strong>PS3</strong>, <strong>PS4</strong> lassen sich noch andere Prompts konfigurieren, wie z.B. der für interaktive Eingaben in Bash-Scripten. Die Variable <strong>PROMPT_COMMAND</strong> wird sogar noch vor <strong>PS1</strong> dargestellt. Wer mehr dazu erfahren möchte, <a href="https://wiki.ubuntuusers.de/Bash/Prompt/#source-2">schaut einfach mal dort vorbei</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">export</span> <span class="n">PS1</span><span class="o">=</span><span class="s2">&#34;$(date +%k:%m:%S) \[</span><span class="se">\033</span><span class="s2">[36m\]\u\[</span><span class="se">\033</span><span class="s2">[m\]@\[</span><span class="se">\033</span><span class="s2">[32m\]\h:\[</span><span class="se">\033</span><span class="s2">[33;1m\]\w\[</span><span class="se">\033</span><span class="s2">[m\]\$ &#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"># Diese Konstanten steuern die Farben für die Ausgabe von cd.</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">export</span> <span class="n">CLICOLOR</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">export</span> <span class="n">LSCOLORS</span><span class="o">=</span><span class="n">ExFxBxDxCxegedabagacad</span>
</span></span></code></pre></div><p>Das ganze sieht dann so aus:</p>
<p><img src="/2018/2018-08-24-die-os-x-bash/images/image-9.png" alt=""></p>
<p>Eine bunte aber informative Kommandozeile</p>
<p>Diese Funktion zeigt alle Prozesse, die unter dem aktuellen Benutzer aktiv sind:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">me() { ps $@ -u $USER -o pid,%cpu,%mem,start,time,bsdtime,command ; }
</span></span></code></pre></div><p>Als nächstes ein paar Aliase um das Netzwerk ein bisschen einfacher im Griff zu behalten:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl"># alle Verbindungen, die gerade &#34;Lauschen&#34;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">alias cons=&#39;sudo lsof -i | grep LISTEN&#39;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"># alle offenen Sockets
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">alias socks=&#39;sudo /usr/sbin/lsof -i -P&#39;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"># alle offenen TCP/IP-Sockets
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">alias tsocks=&#39;lsof -i&#39;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"># alle offenen UDP-Sockets
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">alias usocks=&#39;sudo /usr/sbin/lsof -nP | grep UDP&#39;
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"># alle offenen TCP-Sockets
</span></span><span class="line"><span class="ln">10</span><span class="cl">alias lsocks=&#39;sudo /usr/sbin/lsof -nP | grep TCP&#39; 
</span></span><span class="line"><span class="ln">11</span><span class="cl"># grundlegende Netzwerkeinstellungen
</span></span><span class="line"><span class="ln">12</span><span class="cl">alias net=&#39;ipconfig getpacket en0&#39;
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"># den DNS-Cache leeren
</span></span><span class="line"><span class="ln">15</span><span class="cl">alias cleardns=&#39;dscacheutil -flushcache&#39;
</span></span></code></pre></div><p>Die ganzen Inhalte gibt es hier noch einmal in kompakter Version:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">case</span> <span class="o">$-</span> <span class="ow">in</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="p">)</span> <span class="p">;;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      <span class="o">*</span><span class="p">)</span> <span class="k">return</span><span class="p">;;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="n">esac</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="n">alias</span> <span class="n">l</span><span class="o">=</span><span class="s1">&#39;ls -alCFGA&#39;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">alias</span> <span class="n">ll</span><span class="o">=</span><span class="s2">&#34;ls -CFGla&#34;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">alias</span> <span class="n">h</span><span class="o">=</span><span class="s2">&#34;history&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="n">alias</span> <span class="o">.=</span><span class="s2">&#34;cd ~&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">alias</span> <span class="o">..=</span><span class="s2">&#34;cd ..; pwd&#34;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="n">alias</span> <span class="o">...=</span><span class="s2">&#34;cd ../..; pwd&#34;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">alias</span> <span class="n">mkdir</span><span class="o">=</span><span class="s2">&#34;mkdir -pv&#34;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="n">alias</span> <span class="n">grep</span><span class="o">=</span><span class="s1">&#39;grep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">alias</span> <span class="n">fgrep</span><span class="o">=</span><span class="s1">&#39;fgrep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">alias</span> <span class="n">egrep</span><span class="o">=</span><span class="s1">&#39;egrep --color=auto&#39;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="n">alias</span> <span class="n">f</span><span class="o">=</span><span class="s1">&#39;open -a Finder ./&#39;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="n">HISTCONTROL</span><span class="o">=</span><span class="n">ignoreboth</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="n">shopt</span> <span class="o">-</span><span class="n">s</span> <span class="n">histappend</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="n">HISTSIZE</span><span class="o">=</span><span class="mi">1000</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="n">HISTFILESIZE</span><span class="o">=</span><span class="mi">2000</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="n">shopt</span> <span class="o">-</span><span class="n">s</span> <span class="n">checkwinsize</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="k">case</span> <span class="s2">&#34;$TERM&#34;</span> <span class="ow">in</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="n">xterm</span><span class="o">-</span><span class="n">color</span><span class="o">|*-</span><span class="mi">256</span><span class="n">color</span><span class="p">)</span> <span class="n">color_prompt</span><span class="o">=</span><span class="n">yes</span><span class="p">;;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="n">esac</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="k">export</span> <span class="n">PS1</span><span class="o">=</span><span class="s2">&#34;$(date +%k:%m:%S) \[</span><span class="se">\033</span><span class="s2">[36m\]\u\[</span><span class="se">\033</span><span class="s2">[m\]@\[</span><span class="se">\033</span><span class="s2">[32m\]\h:\[</span><span class="se">\033</span><span class="s2">[33;1m\]\w\[</span><span class="se">\033</span><span class="s2">[m\]\$ &#34;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="k">export</span> <span class="n">CLICOLOR</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="k">export</span> <span class="n">LSCOLORS</span><span class="o">=</span><span class="n">ExFxBxDxCxegedabagacad</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="n">mcd</span> <span class="p">()</span> <span class="p">{</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&#34;$1&#34;</span> <span class="o">&amp;&amp;</span> <span class="n">cd</span> <span class="s2">&#34;$1&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="n">me</span><span class="p">()</span> <span class="p">{</span> <span class="n">ps</span> <span class="o">$</span><span class="err">@</span> <span class="o">-</span><span class="n">u</span> <span class="o">$</span><span class="n">USER</span> <span class="o">-</span><span class="n">o</span> <span class="n">pid</span><span class="p">,</span><span class="o">%</span><span class="n">cpu</span><span class="p">,</span><span class="o">%</span><span class="n">mem</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">bsdtime</span><span class="p">,</span><span class="n">command</span> <span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="n">alias</span> <span class="n">cons</span><span class="o">=</span><span class="s1">&#39;sudo lsof -i | grep LISTEN&#39;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="n">alias</span> <span class="n">socks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -i -P&#39;</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="n">alias</span> <span class="n">tsocks</span><span class="o">=</span><span class="s1">&#39;lsof -i&#39;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="n">alias</span> <span class="n">usocks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -nP | grep UDP&#39;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="n">alias</span> <span class="n">lsocks</span><span class="o">=</span><span class="s1">&#39;sudo /usr/sbin/lsof -nP | grep TCP&#39;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="n">alias</span> <span class="n">net</span><span class="o">=</span><span class="s1">&#39;ipconfig getpacket en0&#39;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="n">alias</span> <span class="n">cleardns</span><span class="o">=</span><span class="s1">&#39;dscacheutil -flushcache&#39;</span>
</span></span></code></pre></div>
        
        
        <div class="tags">
          <p><strong>Tags:</strong> profile, alias, bash, mac, os-x, shell</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>development</category>
      
      <category>os-x</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Die OS X - Bash - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item><item>
      <title>Den eigenen Web-Server sichern</title>
      <link>https://nickyreinert.de/2018/2018-08-23-den-eigenen-web-server-sichern/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      <author></author>
      <guid>https://nickyreinert.de/2018/2018-08-23-den-eigenen-web-server-sichern/</guid>
      <description>Die Datensicherung des eigenen, öffentlichen Webservers ist nicht nur wichtig, sie kann auch auf vielen Wegen geschehen und wirft vermutlich gerade deshalb sehr …</description>
      
      
      <content:encoded>&lt;![CDATA[
        
        <div class="ai-summary">
          <h3>AI-Zusammenfassung</h3>
          <p>Dieser Artikel behandelt Den eigenen Web-Server sichern und bietet praktische Einblicke in das Thema.</p>
          
          
          <p><strong>Hauptthemen:</strong> Web, IT, Tools</p>
          
          
          
          <p><strong>Schwierigkeitsgrad:</strong> intermediate</p>
          
        </div>
        
        
        <p>Die <strong>Datensicherung</strong> des eigenen, öffentlichen Webservers ist nicht nur wichtig, sie kann auch auf vielen Wegen geschehen und wirft vermutlich gerade deshalb sehr viele Fragen auf. Soll ich ein Image des ganzen Servers anlegen oder nur einzelne Ordner sichern? <strong>Wie oft</strong> muss ich ein Backup machen und wie gelange ich im Notfall an die Daten? Reicht es aus, z.B. als Wordpress-Nutzer, ein Plugin zu verwenden oder ist es sinnvoller externe Software zu nutzen?</p>
<p>Ich habe versucht ein paar solcher Fragen, auch für mich selber, zu beantworten und als Konsequenz daraus ein <strong>Backup-Strategie</strong> zu entwickeln und dann auch umzusetzen. Das Ziel ist ein gesunder <strong>Mittelweg zwischen Sicherheit und Bedienbarkeit</strong>. Da ich selber sehr oft mit Wordpress arbeite, soll dieser Beitrag vornehmlich die Wordpress-Nutzer ansprechen. Wenn du Wordpress allerdings nur als Service nutzt (z.B. auf wordpress.org), wird dir dieser Beitrag wenig weiterhelfen. Außerdem ist es sehr hilfreich, wenn du per <strong>SSH Zugriff</strong> auf deinen Server hast. Sicherlich gibt es auch Möglichkeiten, den hier aufgezeigten Weg ohne SSH zu beschreiten - wie das funktioniert, muss man aber im Einzelnen sehen.</p>
<h2 id="die-backup-strategie">Die Backup-Strategie</h2>
<h3 id="wo-soll-das-backup-gespeichert-werden">Wo soll das Backup gespeichert werden?</h3>
<p>Die erste Frage die ich mir gestellt habe war: <strong>Wo soll das Backup landen</strong>? Direkt auf dem Web-Server? Dann sind die Daten verloren, sobald der ganze Server weg ist. Auf einem Cloud-Speicher? Das ist bequem, birgt allerdings auch Probleme mit den <strong>Datenschutzgesetzen</strong>. Oder auf einem privaten NAS? Das ist aus Datenschutzsicht zwar in Ordnung, aber dann muss das NAS über das Internet erreichbar sein. Das wollte ich vermeiden.</p>
<p>Ich habe mich deshalb für einen Zwischenweg entschieden: Für den schnellen Zugriff lege ich das Backup <strong>auf dem Server</strong> ab. Gleichzeitig nutze ich das kostenlose Angebot von <a href="https://www.blaucloud.de/"><strong>blaucloud.de</strong></a>. Das ist ein Cloud-Speicher, dessen Server in Deutschland stehen. Außerdem unterstützt blaucloud, das auf nextcloud basiert, das WebDav-Protokoll. Zusätzlich, aber das ist nur ein Bonus. Außerdem habe ich auf meinem NAS eine Synchronisierung mit der blaucloud eingerichtet. Dadurch bleibt das NAS im Internet verborgen und ich habe trotzdem eine <strong>3. Kopie des Backups</strong> in meinen eigenen, sicheren vier Wänden.</p>
<h3 id="welche-software-soll-ich-nutzen">Welche Software soll ich nutzen?</h3>
<p>Die Auswahl von Plugins für automatische Backups mit Wordpress ist sehr umfangreich, einige davon sind kostenlos und die große Mehrheit ist sehr bequem zu bedienen. Die Backups laufen automatisch und auch die Wiederherstellung ist nur einen Mausklick entfernt. Das klingt paradiesisch, aber der Schein trügt. Zunächst halte ich es für absurd, ein System aus sich selber heraus zu sichern. Das ist wie ein <strong>Feuerlöscher</strong>, der bei <strong>Waldbrandgefahr</strong> zwischen den trockenen Bäumen steht.</p>
<p>Sicher kann ich mit den zahlreichen Wordpress-Plugins die Datenbank und das Dateisystem sichern. Aber der Prozess wird eben innerhalb eines System ausgeführt, das auch von außen erreichbar ist. Wenn nur ein anderes Plugin kompromittiert wird, gefährdet das die ganze Backup-Strategie. Außerdem muss ich, bei der Verwendung mehrerer Wordpress-Instanzen jedes Backup-Plugin einzeln pflegen.</p>
<p>Auch die regelmäßige Datensicherung, die viele Hoster von sich aus anbieten, reicht mir nicht aus, da diese nur minimal gesteuert werden kann und dort immer das ganze System gesichert wird, man also bei der Wiederherstellung nicht selektieren kann, welche Backup, welcher Ordner oder welche Datenbank zurück gespielt werden soll. Ich habe mich also für <strong>duplicity</strong> entschieden. <a href="http://duplicity.nongnu.org/"><strong>Duplicity</strong></a> wird über die Kommandozeile bedient (deshalb der notwendige SSH-Zugang), unterstützt viele Protokolle (FTP, <strong>WebDav</strong>, Amazon S3, rsync, &hellip;) und es gibt sogar eine grafische Benutzeroberfläche - wenn man doch nicht ohne kann. Außerdem bietet duplicity die Verschlüsselung mit <strong>GnuPG</strong> an und ist damit auch bestens geeignet, um die Datensicherung in der Cloud abzulegen.</p>
<h3 id="wie-oft-soll-ich-ein-backup-anlegen">Wie oft soll ich ein Backup anlegen?</h3>
<p>Die Frage sollte mich nicht länger beschäftigen, vor allem weil ich dazu <a href="https://blog.yadutaf.fr/2012/09/08/lazy-man-backup-strategy-with-duplicity-part-1/">einen sehr schönen Blog-Eintrag gefunden</a> habe. Dazu muss erklärt werden, dass <strong>duplicity</strong> mit <strong>inkrementellen Backups</strong> arbeitet. Dabei wird initial ein komplettes Backup angelegt. Danach werden nur noch die Änderungen an den zu sichernden Dateien erfasst. Für die Wiederherstellung muss also erst das letzte volle Backup zurückgespielt werden, um darauf dann die inkrementellen Backups &ldquo;anzuwenden. Der Backup-Plan lautet also wie folgt:</p>
<ul>
<li>es erfolgt initial eine volle Datensicherung</li>
<li>danach gibt es jeden Tag eine inkrementelle Datensicherung</li>
<li>jeden Monat erfolgt eine volle Datensicherung</li>
<li>inkrementelle, tägliche Backups, die älter sind als ein Monat, werden gelöscht</li>
<li>volle Backups, die älter als 12 Monate sind, werden gelöscht</li>
</ul>
<p>Im Notfall muss also zuerst das letzte volle Backup eingespielt werden, das nicht älter als ein Monat ist. Muss man Daten wiederherstellen, die älter sind als ein Monat, stehen diese immer nur für die monatlichen vollen Backups zur Verfügung. Für die Zeit vor 12 Monaten gibt es keine Datensicherung.</p>
<h3 id="welche-daten-sollen-gesichert-werden">Welche Daten sollen gesichert werden?</h3>
<p>Wie bereits erwähnt, stört mich bei den meisten Hostern, dass immer ein Backup des ganzen Servers angelegt wird. Da auf einem Server gerne aber mehr als eine Domain untergebracht ist, möchte ich die Datensicherung gerne je Domain und Datenbank durchführen. Mein Ziel ist es also, jeden Ordner im Dateisystem der einer (Sub-)Domain zugeordnet ist sowie jede Datenbank getrennt zu sichern. So kann ich eine Wiederherstellung auch punktuell anstoßen.</p>
<h2 id="vorbereitung">Vorbereitung</h2>
<p><em>Bevor es jetzt ans Eingemachte geht, der übliche Hinweis zur gebotenen <strong>Vorsicht</strong>: Wenn du nicht weißt, was hier passiert, lass dich von jemanden unterstützen, der weiß, was hier passiert. Wer auf der Konsole arbeitet, kann sehr schnell sehr viel falsch machen.</em></p>
<h3 id="duplicity-und-verschlüsselung-einrichten">Duplicity und Verschlüsselung einrichten</h3>
<p>Die erste Hürde, die du nehmen musst, ist die Installation von <strong>duplicity</strong>. Entweder du bekommst das über die Konsole selber hin - oder du fragst bei deinem Hoster nach. In vielen Fällen kann auch ein Shared Hostern das für dich installieren:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">sudo apt-get install duplicity
</span></span></code></pre></div><p>Als nächstes benötigst du <a href="https://www.gnupg.org/">GnuPG</a>. Das ist bei den meisten Hostern vorinstalliert. Sollte dem nicht so sein, fragst du entweder den Support oder erledigst das mit folgendem Befehl selber:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">sudo apt-get install gnupg2
</span></span></code></pre></div><p><a href="https://wiki.ubuntuusers.de/GnuPG/">GnuPG</a> ist ein Software zur <strong>Verschlüsselung</strong> von Informationen bzw. Dateien, das z.B. auch bei der Verschlüsselung von E-Mails zum Einsatz kommt. Für diesen Prozess werden zwei sogenannte <strong>Schlüssel</strong> benötigt - der private und der öffentliche Schlüssel. Der öffentliche Schlüssel dient dazu, die Daten zu verschlüsseln, mit dem privaten Schlüssel kannst du den Prozess &ldquo;umkehren&rdquo; - die Daten also entschlüsseln. Diese beiden Schlüssel müssen zunächst einmal erzeugt werden:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">gpg --gen-key
</span></span></code></pre></div><p>Du musst dazu ein paar Fragen beantworten. Die Frage nach der Schlüssel-Art beantwortest du mit 1, bzw. <em>RSA and RSA</em>. Als Schlüssellänge (<em>keysize</em>) empfiehlt sich 2.048 bits. Die Gültigkeitsdauer beträgt &ldquo;unendlich&rdquo;. Danach kannst, musst aber nicht, du deinen Namen und Kontaktdaten angeben. Abschließend wirst du nach einem Passwort für den privaten Schlüssel gefragt und aufgefordert durch ein paar zufällige Tasteneingaben eine Entropie zu erzeugen. Danach befindet sich im Ordner <strong><em>~/.gnupg</em></strong> dein Schlüsselpaar.</p>
<p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/gnupg.png" alt="Ein GnuPG Schlüsselpaar erzeugen"></p>
<p>Außerdem quittiert dir <strong>gnupg</strong> die Erstellung des Schlüsselpaars mit einer Statistik, aus der du dir die <strong>Id für den öffentlichen Schlüssel</strong> merken musst:</p>
<p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/gnupg-ausgabe.png" alt=""></p>
<h3 id="cloud-speicher-einrichten">Cloud-Speicher einrichten</h3>
<p>Der kostenlose <a href="https://www.blaucloud.de/">blaucloud</a>-Account für 5 GByte-Speicher ist ziemlich schnell eingerichtet. Dazu benötigst du nur einen beliebigen Benutzernamen, eine E-Mail-Adresse und ein Passwort. Über den Benutzerbnamen wird später auch deine Cloud erreichbar sein. Ich habe eine zufällige Zeichenkette verwendet, damit die Verbindung zur Funktion als Backup-Speicher nicht auf den ersten Blick ersichtlich ist (z.B. <em>qwertz123.blaucloud.de</em>). Danach musst du nur noch deine E-Mail-Adresse bestätigen und schon ist der Cloud-Speicher über folgende URL verfügbar:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">webdav://benutzername:passwor@benutzername.blaucloud.de/remote.php/webdav/
</span></span></code></pre></div><h3 id="mysql-benutzer-einrichten">MySQL-Benutzer einrichten</h3>
<p>Natürlich kannst du für das Backup einfach den Benutzer nutzen, den du auch für administrative Zwecke nutzt. Ich verrate dir aber kein Geheimnis wenn ich dir sage, dass es sehr sinnvoll ist, dafür einen eigenen Benutzer anzulegen, insofern deine Hosting-Umgebung das zulässt. Dazu führst du auf einer beliebigen Oberfläche (phpMyAdmin, MySQL Workbench oder direkt über das MySQL-CLI) folgende Query aus. Hier setzt du nur einen Benutzernamen und ein Passwort ein.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">GRANT LOCK TABLES, SELECT ON *.* TO &#39;USERNAME&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;PASSWORD&#39;;
</span></span><span class="line"><span class="ln">2</span><span class="cl">GRANT SHOW VIEW ON *.* TO &#39;USERNAME&#39;@&#39;localhost&#39;
</span></span></code></pre></div><p>Das ging schnell und hat auch gar nicht weh getan. ;)</p>
<h2 id="die-backup-strategie-umsetzen">Die Backup-Strategie umsetzen</h2>
<h3 id="die-zugangsdaten-ablegen">Die Zugangsdaten ablegen</h3>
<p>Die Informationen, die wir oben gesammelt haben, werden erstmal in der Datei <strong>backup.conf</strong> abgelegt. Bitte beachte, dass die Id für den öffentlichen Schlüssel nur ein Verweis ist. Die tatsächlichen Schlüssel liegen im Benutzerordner unter <em>~/.gnugpg/</em>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1"># mit diesem Wert steuerst du die Ausgabe von duplicity</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"># je höher, desto mehr Debug-Nachrichten werden ausgegeben</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"># das hilft bei der Fehlersuche</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="k">export</span> <span class="n">DUPLICITY_VERBOSITY</span><span class="o">=</span><span class="mi">2</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"># die Passphrase ist das Passwort für den privaten Schlüssel</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># die Id für den öffentlichen Schlüssel wird utner GPG_PUP_KEY abgelegt</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="k">export</span> <span class="n">PASSPHRASE</span><span class="o">=</span><span class="n">secret_gpgp_key_password</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">export</span> <span class="n">GPG_PUB_KEY</span><span class="o">=</span><span class="n">public_gpgp_key_id</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"># dieser Ordner wird für die lokalen Backups verwendet</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">export</span> <span class="n">BASE_PATH_BACKUP</span><span class="o">=/</span><span class="n">private</span><span class="o">-</span><span class="n">backup</span><span class="o">/</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"># dieser Ordner enthält die temporären MySQL-Dumps sowie den Cache von duplicity</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="k">export</span> <span class="n">BASE_PATH_TEMP</span><span class="o">=/</span><span class="n">private</span><span class="o">-</span><span class="n">backup</span><span class="o">/</span><span class="n">temp</span><span class="o">/</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">export</span> <span class="n">LOG_FILE</span><span class="o">=</span><span class="n">backup</span><span class="o">.</span><span class="n">log</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"># das sind die Zugangsdaten zu deinem WebDav-Anbieter</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_USER</span><span class="o">=</span><span class="n">webdav_user</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_PASSWORD</span><span class="o">=</span><span class="n">webdav_password</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">export</span> <span class="n">WEBDAV_URL</span><span class="o">=</span><span class="n">somewhere</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">de</span><span class="o">/</span><span class="n">webdav</span><span class="o">.</span><span class="n">php</span><span class="o">/</span><span class="n">folder</span><span class="o">/</span><span class="n">backup</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"># schließlich hinterlegst du noch eine E-Mail-Adresse </span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"># an die Fehlernachrichten geschickt werden </span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="k">export</span> <span class="n">SUPERVISOR_EMAIL</span><span class="o">=</span><span class="n">error_messages</span><span class="err">@</span><span class="n">foobar</span><span class="o">.</span><span class="n">com</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"># und die E-Mail-Adresse des Absenders</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="k">export</span> <span class="n">LOCAL_EMAIL</span><span class="o">=</span><span class="n">sender</span><span class="err">@</span><span class="n">foobar</span><span class="o">.</span><span class="n">com</span>
</span></span></code></pre></div><p>Die Zugangsdaten für den MySQL-Server gehören in eine andere Datei, nämlich <strong>database.conf</strong>:</p>
<p>[client]
user=mysql_user
password=mysql_password
host=localhost</p>
<h3 id="die-ordner-der-virtuellen-hosts-sichern">Die Ordner der virtuellen Hosts sichern</h3>
<p>Im Folgenden werde ich die Shell-Scripte und den Prozess ganz kurz erklären.</p>
<p>Zunächst will ich zwei Server-System unterstützen: nginx und apache2. Dazu frage ich den ersten Parameter ab:</p>
<p>if [[ $1 == &lsquo;apache&rsquo;  ]]
then</p>
<pre><code>    SERVER\_SOFTWARE='apache'
</code></pre>
<p>elif [[ $1 == &rsquo;nginx&rsquo;  ]]
then
SERVER_SOFTWARE=&lsquo;nginx&rsquo;</p>
<p>else</p>
<pre><code>    echo 'Keine Server-Architektur angegeben, probiere mal nginx oder apache'
</code></pre>
<p>fi</p>
<p>Wie oben schon angedeutet, will ich nicht einmal das ganze Dateisystem sichern, sondern nur <strong>relevante Ordner</strong>. Dazu muss ich erwähnen, dass ich für jede Domain eine Konfigurations-Datei angelegt habe - so ist es im übrigen auch üblich (siehe z.B. <em>/etc/apache2/sites-enabled/</em>). Jede dieser Dateien enthält den Verweis auf den Ordner der jeweiligen Domain (oft z.B. <em>/var/www/&hellip;</em>) Diese Informationen gilt es nun automatisch herauszufinden. Ich nutze dafür zunächst den folgenden Aufruf, der mir erstmal eine <strong>ungefilterte  Liste der gesamten Webserver-Konfiguration</strong> ausgibt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">/usr/sbin/apache2ctl -S
</span></span></code></pre></div><p><img src="/2018/2018-08-23-den-eigenen-web-server-sichern/images/apachectl-ausgabe.png" alt=""></p>
<p>Die Ausgabe ist stark gekürzt und enthält natürlich mehr als nur eine Domain und diese auch immer doppelt - einmal für https und einmal für http. Ich benötige aus dieser Liste nun einmal den Pfad zur Konfigurations-Datei jeder Domain. Dazu reduziere ich die Ausgabe also auf die gewünschten Zeilen und extrahiere dann mit <em>awk</em> und <em>sed</em> den Verweis zu der jeweiligen Konfigurations-Datei. Das ist der komplette Aufruf:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">/usr/sbin/apache2ctl -S | grep &#34;port 80 namevhost&#34; | awk -F &#39; &#39; &#39;{ print $5 }&#39; | sed -E &#39;s/[:()]//g&#39; | sed -E &#39;s/[ 0-9]$//g&#39;
</span></span></code></pre></div><p>Das Ergebnis ist eine Liste von Konfigurationsdateien, die ich mit <em>grep</em> nach der Angabe des Ordners durchsuchen kann:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">grep -oE &#39;DocumentRoot \&#34;(.*)\&#34;&#39; $configFile | awk -F &#39; &#39; &#39;{ print $2 }&#39; | sed -E &#39;s/[&#34;]//g&#39;
</span></span></code></pre></div><p>Diesen Ordner kann ich dann an das Backup-Script übergeben, auf das ich später zurück kommen werden. Das ganze Script ist auf github verfügbar.</p>
<p>Ich muss hier allerdings erwähnen, dass das ganze eine <strong>kleinen Nachteil</strong> hat: Es werden nur aktivierte virtuelle Hosts erkannt. Wer zusätzliche andere Ordner sichern will, die z.B. nicht über die virtual host-Konfiguration genutzt werden, muss dies per Hand tun - doch dazu später mehr.</p>
<p>Für nginx nutze ich eine etwas einfachere Variante: Ich nehme einfach alle Dateien mit der Endung conf aus dem Konfigurations-Ordner von nginx. Das funktioniert eben nur, solange du die Konfiguration zentral an einem Ort verwaltest. Der ganze Abschnitt sieht dann so aus:</p>
<p>if [[ $SERVER_SOFTWARE == &lsquo;apache&rsquo; ]]
then
configFilesString=$(/usr/sbin/apache2ctl -S | grep &ldquo;port 80 namevhost&rdquo; | awk -F &rsquo; &rsquo; &lsquo;{ print $5 }&rsquo; | sed -E &rsquo;s/[:()]//g&rsquo; | sed -E &rsquo;s/[ 0-9]$//g&rsquo;)
configFiles=($(echo &ldquo;$configFilesString&rdquo; | tr &lsquo;,&rsquo; &rsquo; &lsquo;))</p>
<p>elif [[ $SERVER_SOFTWARE == &rsquo;nginx&rsquo; ]]
then</p>
<pre><code>    configFiles=(/etc/nginx/conf.d/\*.conf)
</code></pre>
<p>fi</p>
<p> </p>
<p><strong>Update November 2018:</strong></p>
<p><em>Da ich mittlerweile auf nginx und php-fpm umgestiegen bin, habe ich auch das Script entsprechend angepasst. Es kann nun für beide Server-Typen angewendet werden.</em></p>
<p>Nun kann ich jede Config-Datei einmal einlesen um herauszubekommen, an welcher Stelle im Dateisystem sich der Ordner mit dem Document Root befindet - den wollen wir ja schließlich sichern:</p>
<p>if [[ $SERVER_SOFTWARE == &lsquo;apache&rsquo; ]]
then</p>
<pre><code>srcFolder=$(grep -oE 'DocumentRoot \\&quot;(.\*)\\&quot;' $configFile | awk -F ' ' '{ print $2 }' | sed -E 's/\[&quot;\]//g')
dstFolder=$(basename $srcFolder)
</code></pre>
<p>elif [[ $SERVER_SOFTWARE == &rsquo;nginx&rsquo; ]]
then</p>
<pre><code>srcFolder=$(grep -oE 'root (.\*);' $configFile | awk -F ' ' '{ print $2 }' | sed -E 's/\[;\]//g')
dstFolder=$(basename ${srcFolder%htdocs})
</code></pre>
<p>fi</p>
<p> </p>
<h3 id="die-datenbanken-des-mysql-servers-sichern">Die Datenbanken des MySQL-Servers sichern</h3>
<p>Nun geht es an die Datenbanken. Dazu nutze ich den CLI-MySQL-Client und frage erstmal einfach alle Datenbanken ab:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">mysql --defaults-extra-file=database.conf -Bse &#39;show databases&#39;
</span></span></code></pre></div><p>Die Zugangsdaten zum Server übergebe ich in der Datei <strong>database.conf</strong>. Ich könnte das auch über die Kommandozeile tun, würde dann aber eine Warnung von MySQL erhalten, dass das nicht sicher sei:</p>
<blockquote>
<p><em>Warning: Using a password on the command line interface can be insecure.</em></p></blockquote>
<p>Da die Ausgabe von mysql nur einen String zurückgibt, muss ich den erst in ein Array umwandeln, dass ich dann durch-loopen kann. Dazu gibt es zwei Wege - den unteren finde ich etwas eleganter. Entscheide dich einfach für einen:</p>
<p>databasesArray=($(echo &ldquo;$databasesString&rdquo; | tr &lsquo;,&rsquo; &rsquo; &lsquo;))
IFS=&rsquo;_&rsquo; read -r -a databasesArray&laquo;&lt; &ldquo;$databasesString&rdquo;</p>
<p>Nun hast du also ein Array, dass deine Datenbanken enthält. Als nächstes brauchst du eine Schleife um für jede Datenbank ein Dump anzulegen:</p>
<p>ignoreDatabases=[&lsquo;information_schema,sys,performance_schema&rsquo;]
for database in &ldquo;${databasesArray[@]}&rdquo;
do</p>
<pre><code>    if \[\[ ! &quot; ${ignoreDatabases\[\*\]} &quot; == \*&quot;${database}&quot;\* \]\]
    then
        ...
    fi
</code></pre>
<p>done</p>
<p>Wie du siehst, habe ich noch eine Abfrage eingebaut, damit nicht benötigte System-Datenbanken ausgelassen werden. Jetzt kümmern wir uns um den eigentlichen Dump. Die folgenden Zeilen kommen an die Stelle mit den drei Punkten&hellip;</p>
<p>Jetzt werden die Daten aus der jeweiligen Datenbank gezogen. Wenn <strong>mysqldump</strong> einen Fehler zurück gibt, schicke ich mir diesen per E-Mail. Danach wird das Script aufgerufen, dass den Dump mit duplicity an einen &ldquo;sicheren&rdquo; Ort kopiert. Zum Abschluss wird der Dump wieder entfernt.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">result=&#34;$( ( mysqldump --defaults-extra-file=database.conf ${database} &gt; ${BASE\_PATH\_TEMP}${database}.sql ) 2&gt;&amp;1 )&#34;
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">len=${#result}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">if \[ &#34;$len&#34; -gt &#34;0&#34; \]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">then
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	echo $result | mail -s &#34;Error when dumping mysql database ${database}&#34; $SUPERVISOR\_EMAIL -r $LOCAL\_EMAIL
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">fi
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">./backupFilesystem.sh -f ${BASE\_PATH\_TEMP}${database}.sql -d &#34;${BASE\_PATH\_BACKUP}databases/${database}&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">rm ${BASE\_PATH\_TEMP}${database}.sql
</span></span></code></pre></div><p> </p>
<p>Eine Sache gibt es zu beachten, die ich hier nicht weiter beschreiben: Ich nutze &ldquo;<strong>mail</strong>&rdquo; um die Fehlernachrichten zu versenden. Ihr könnte hier einen eigenen E-Mail-Client oder eine andere Variante der Fehlerbenachrichtigung nutzen, das bleibt euch überlassen.</p>
<h3 id="die-daten-mit-duplicity-verschlüsselt-sichern">Die Daten mit duplicity verschlüsselt sichern</h3>
<p>Nun geht es ans Eingemachte bzw. die tatsächliche Datensicherung. Das Script <strong>backupFilesystem.sh</strong> erwartet zwei Parameter: Die Dateien bzw. der Ordner, der gesichert werden soll und der Name des Zielordners.</p>
<p>Danach wird duplicity mehr als ein mal aufgerufen. Zunächst wird, wenn das letzte Vollbackup älter ist als 1 Monat, ein komplettes Backup angelegt. Danach wird duplicity angewiesen, Backups, die älter sind als 12 Monate, zu entfernen. Dann werden außerdem die inkrementellen Backups entfernt, die älter sind als 1 Monat. Das ganze wird einmal aufgerufen um die Backups lokal abzulegen und dann ein 2. Mal für den WebDav-Speicher.</p>
<p>Wer Ordner und Dateien <strong>manuell sichern</strong> will, kann also dieses Script mit den entsprechenden Parametern aufrufen.</p>
<h3 id="automatisieren-mit-cron">Automatisieren mit cron</h3>
<p>Jetzt muss der ganze Spaß natürlich noch automatisch laufen. Dazu werden die folgende Zeilen in die Datei <em>/etc/cron.d/dailyBackup</em> gepackt:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl"># m h dom mon dow user  command
</span></span><span class="line"><span class="ln">2</span><span class="cl">0 1 * * * root /bin/bash /backup/backupVirtualhosts.sh
</span></span><span class="line"><span class="ln">3</span><span class="cl">0 2 * * * root /bin/bash /backup/backupDatabase.sh
</span></span></code></pre></div><p>Willst du zusätzliche Ordner sichern, kannst du das über das Script <em>backupFilesystem.sh</em> tun, z.B:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">0 1 * * * root /bin/bash /backup/backupFilesystem.sh -f /home/ -d /private-backup/home/
</span></span></code></pre></div><h3 id="github">Github</h3>
<p>Die gesammelten Scripte und Vorlagen für die Konfigurationsdateien findest du auf <a href="https://github.com/nickyreinert/completeWebServerBackup">github.com</a>. Du kopierst einfach den Inhalt des Ordners <em>scripts</em> an einen Ort auf deinen Server, wie z.B. <em>/backup.</em></p>

        
        
        <div class="tags">
          <p><strong>Tags:</strong> backup, bash, hosting, shell, web-server</p>
        </div>
        
      ]]></content:encoded>
      
      
      
      <category>hosting</category>
      
      
      
      
      <media:content url="https://nickyreinert.de/images/posts/placeholder.jpg" type="image/jpeg">
        <media:title>Den eigenen Web-Server sichern - Titelbild</media:title>
      </media:content>
      
      
      
      
      <dc:subject>Lesezeit: 5 Minuten</dc:subject>
      
      
      
      <dc:type>guide</dc:type>
      
      
    </item>
  </channel>
</rss>